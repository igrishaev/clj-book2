\chapter{REPL, Cider, Emacs}

\begin{teaser}
Эта глава расскажет о REPL~--- фундаментальном свойстве Clojure. Так называют интерактивную работу с языком, когда программу наращивают постепенно. Мы рассмотрим, что такое REPL-driven development и почему, однажды познав, от него трудно отказаться.
\end{teaser}

Аббревиатура REPL происходит от четырех слов: Read, Eval, Print и Loop. Дословно они означают прочитать, выполнить, напечатать и повторить. REPL~--- устойчивый термин, под которым понимают интерактивный режим программы.

Многие современные языки предлагают интерактивный режим. Как правило, он запускается, если вызвать интерпретатор без параметров. Например, команды \code{python} или \code{node} запустят интерактивные сеансы Python и Node.js. В Ruby для этого служит утилита \code{irb} (где i означает interactive). REPL поддерживают не только интерпретаторы, но и языки, которые компилируются в байт-код (Java, Scala) или машинный код (Haskell, SBCL).

Несмотря на это разнообразие, именно в Лисп-системах REPL имеет решающее значение. Если в Python или Node.js его рассматривают как приятное дополнение, то в Лиспе он необходим. Разработка на любом Лиспе зависит от того, насколько хорошо вы взаимодействуете с REPL. На REPL так или иначе опираются все инструменты и практики, документация, видеоуроки и так далее.

В мире Лиспа ходит понятие REPL-driven development. Это стиль разработки, когда код пишут малыми порциями и запускают в REPL. С таким подходом сразу видно поведение программы. Легче проверить неочевидные случаи, например вызвать функцию с \code{nil} или обратиться к ресурсу, которого не существует.

Другой полезный сценарий для REPL~--- извлечь данные из сети и исследовать их. Эта задача идеально ложиться на интерактивный режим. Как правило, HTTP-запрос предполагает несколько этапов: его подготовку, отправку, чтение тела и поиск нужных полей. Эти шаги проходят интерактивно методом проб и ошибок. Позже мы рассмотрим пример HTTP-запроса в сеансе REPL.

\subsection{Исторический экскурс}

\def\urllispmachine{https://en.wikipedia.org/wiki/Lisp\_machine}

\def\urldart{https://en.wikipedia.org/wiki/Dynamic\_Analysis\_and\_Replanning\_Tool}

REPL отсчитывает свою историю от \footurl{первых Лисп-машин}{\urllispmachine}[Lisp machine]. Это были мейнфреймы с запущенным на них интерпретатором Лиспа. Подобные машины использовали в Xerox для печати, обработки изображений, управления оборудованием, решения задач на оптимизацию и машинного обучения. Разработку Лисп-машин \footurl{поддерживал отдел DARPA}{\urldart}[DART], в том числе потому, что их применяли в военной отрасли.

Золотой век Лисп-машин пришелся на период с 1977 по 1985 год, после чего последовал спад их популярности. Из-за особенностей архитектуры они не могли конкурировать с процессором x86 и компилируемыми языками,~--- как в плане цены, так и производительности. В итоге Лисп-машины полностью ушли с рынка, но подход REPL, придуманный полвека назад, навсегда остался в индустрии.

Подход и вправду был инновационным. До него программу набирали в редакторе, компилировали и только потом запускали (для краткости опустим перфокарты и прочую рутину). Процесс был долгим и дорогим. Наоборот, Лисп-машина принимала код и выполняла его мгновенно. Для своего времени Лисп был очень высокоуровневым языком. На нем легко выразить сложную логику, не отвлекаясь на низкоуровневые проблемы. Именно в Лиспе появился автоматический контроль за памятью и сборщик мусора. Все это делало Лисп-машину идеальной площадкой для экспериментов.

Интерпретатор Лисп-машины был не просто программой по запуску кода. Фактически он был ее операционной системой, потому что имел доступ к регистрам процессора, оперативной памяти и устройствам ввода-вывода. В REPL можно было просмотреть все переменные и функции, переопределить и удалить их. Это свойство~--- полный контроль системой~--- тоже стало неотъемлемой частью REPL.

Язык Clojure, как и другие диалекты Лиспа, активно поддерживает REPL и все связанное с ним. Без знания REPL работа с Clojure будет неэффективна. Классический подход, когда сначала вы пишете программу, а потом запускаете, здесь не работает. Цель этой главы~--- показать практическую, REPL-ориентированную разработку, принятую в Clojure.

\subsection{Пробуем REPL}

Чтобы познакомиться с REPL, запустим его. Это можно сделать несколькими способами.

\def\urllein{https://leiningen.org/}

\textbf{Первый}~--- установить утилиту \footurl{Leiningen}{\urllein}[Leiningen] для управления проектами на Clojure. Инструкции по установке вы найдете на официальном сайте. Когда утилита установлена, выполните в терминале:

\begin{english}
  \begin{bash}
> lein repl
  \end{bash}
\end{english}

\def\urlinstallclj{https://clojure.org/guides/install\_clojure}

\textbf{Второй} способ~--- установить набор утилит \footurl{Clojure CLI}{\urlinstallclj}[Clojure CLI]. На официальном сайте Clojure представлены команды установки для Linux и MacOS. После установки появятся команды \code{clojure} и \code{clj} для запуска проекта. Если вызвать любую из них, запустится REPL:

\begin{english}
  \begin{bash}
> clj
#or
> clojure
  \end{bash}
\end{english}

**Третий** способ~--- выполнить архив jar. Старые версии Clojure (до 1.8 включительно) состоят из одного jar-файла, который запускается командой \code{java -jar}:

\begin{english}
  \begin{bash}
> java -jar clojure-1.8.0.jar
  \end{bash}
\end{english}

Другой вариант, когда архив находится в CLASSPATH и явно указан класс \code{clojure.main}:

\begin{english}
  \begin{bash}
> java -cp clojure-1.8.0.jar clojure.main
  \end{bash}
\end{english}

\def\urlmaven{https://mvnrepository.com}

С версии 1.9 Clojure состоит из нескольких jar-файлов. Библиотека Clojure.spec, которую мы рассмотрели в первой книге, поставляется отдельно. Скачайте jar-файлы из \footurl{репозитория Maven}{\urlmaven}[Maven] в разделах \code{org.clojure/clojure} и \code{org.clojure/spec.alpha}. Далее выполните команду:

\begin{english}
  \begin{bash}
> java -cp clojure-1.11.1.jar:spec.alpha-0.3.218.jar clojure.main
  \end{bash}
\end{english}

Когда REPL запущен, вы увидите приглашение:

\begin{english}
  \begin{text}
user=>
  \end{text}
\end{english}

Слово \code{user} означает текущее пространство имен. Если не задано иное, REPL запускается в пространстве \code{user}. Позже мы узнаем, как задать другое пространство или переключить его.

Введите любое выражение на Clojure: число, строку в двойных кавычках или кейворд. Эти значения вычисляются сами в себя:

\begin{english}
  \begin{clojure}
user=> 1
1

user=> :test
:test

user=> "Hello REPL!"
"Hello REPL!"
  \end{clojure}
\end{english}

Задайте глобальную переменную:

\begin{english}
  \begin{clojure}
user=> (def amount 3)
#'user/amount
  \end{clojure}
\end{english}

и сошлитесь на нее в выражении:

\begin{english}
  \begin{clojure}
user=> (+ amount 4)
7
  \end{clojure}
\end{english}

Более сложный пример. Определите функцию \code{add}, которая складывает два числа. Введите ее в одну строку:

\begin{english}
  \begin{clojure}
user=> (defn add [a b] (+ a b))
#'user/add
  \end{clojure}
\end{english}

и проверьте вызов:

\begin{english}
  \begin{clojure}
user=> (add 2 3)
5
  \end{clojure}
\end{english}

REPL поддерживает ввод нескольких строк за раз. Предположим, вы бы хотели задать функцию с переносом после параметров, чтобы код выглядел аккуратней:

\begin{english}
  \begin{clojure}
(defn add [a b]
  (+ a b))
  \end{clojure}
\end{english}

Если напечатать \code{(defn add [a b]} и нажать ввод, по незакрытой скобке REPL определит, что выражение неполное. Ошибки не произойдет, и следующая строка дополнит исходную. Как только скобки станут сбалансированы, REPL выполнит форму.

\begin{english}
  \begin{clojure}
user=> (defn add [a b]
  #_=> (+ a b))
#'user/add
  \end{clojure}
\end{english}

Подключите любой из модулей Clojure, например \code{clojure.string} для работы со строками:

\begin{english}
  \begin{clojure}
user=> (require '[clojure.string :as str])
nil
  \end{clojure}
\end{english}

С его помощью разбейте строку или выполните автозамену:

\begin{english}
  \begin{clojure}
user=> (str/split "one two three" #"\s+")
["one" "two" "three"]
  \end{clojure}
\end{english}

\begin{english}
  \begin{clojure}
user=> (str/replace "Two minutes, Turkish!", #"Two" "Five")
"Five minutes, Turkish!"
  \end{clojure}
\end{english}

Модуль \code{clojure.inspector} предлагает примитивный графический отладчик. Его функция \code{inspect-tree} принимает данные и выводит окно Swing с деревом папок. Значок папки означает коллекцию; если его раскрыть, появятся дочерние элементы с иконками файлов. Чтобы изучить переменные среды, выполните:

\begin{english}
  \begin{clojure}
(require '[clojure.inspector :as insp])
(insp/inspect-tree (System/getenv))
  \end{clojure}
\end{english}

Содержимое окна будет примерно таким:

\begin{english}
  \begin{text}
TODO
{}
  JAVA_MAIN_CLASS_68934=clojure.main
  LC_TERMINAL=iTerm2
  COLORTERM=truecolor
  LOGNAME=ivan
  TERM_PROGRAM_VERSION=3.3.12
  PWD=/Users/ivan/work/book-sessions
  SHELL=/bin/zsh
  \end{text}
\end{english}

Опробуйте случай с ошибкой: поделите число на ноль или сложите число с \code{nil}. REPL не завершится, но выведет исключение на экран:

\begin{english}
  \begin{clojure}
user=> (/ 1 0)
Execution error (ArithmeticException) at user/eval554...
Divide by zero
  \end{clojure}
\end{english}

Это правильное поведение: в разработке ошибки случаются часто, и нам бы не хотелось завершать JVM. Однако это справедливо только для сеанса REPL. В боевом запуске программы на Clojure ведут себя как обычно: если исключение не поймано, программа завершается.

По умолчанию REPL выводит краткое сообщение об ошибке. Объект исключения остается в переменной \code{*e}. Исследуем ее:

\begin{english}
  \begin{clojure}
user=> *e

#error {
 :cause "Divide by zero"
 :via
 [{:type java.lang.ArithmeticException
   :message "Divide by zero"
   :at [clojure.lang.Numbers divide "Numbers.java" 188]}]
 :trace
 [[clojure.lang.Numbers divide "Numbers.java" 188]
  [clojure.lang.Numbers divide "Numbers.java" 3901]
  [user$eval8888 invokeStatic "form-init3207458389100610076.clj" 1]
  [user$eval8888 invoke "form-init3207458389100610076.clj" 1]
  ...
  [nrepl.middleware.session$session_exec$main_loop__1048 invoke "session.clj" 201]
  [clojure.lang.AFn run "AFn.java" 22]
  [java.lang.Thread run "Thread.java" 829]]}
  \end{clojure}
\end{english}

В первой книге мы рассмотрели, что можно сделать с исключением: напечатать в удобном виде, записать в лог, отправить в систему сборки ошибок.

Когда REPL что-то вычислил, результат остается в переменной \code{*1}. С ней легко избежать повторных вычислений. Предположим, мы ввели код, который дает объемный результат:

\begin{english}
  \begin{clojure}
(into {} (System/getenv))

{"HOME" "/Users/ivan"
 "LC_TERMINAL_VERSION" "3.3.12"
 "USER" "ivan"
 ...}
  \end{clojure}
\end{english}

Чтобы сослаться на результат, не вычисляя повторно, введите:

\begin{english}
  \begin{clojure}
(get *1 "USER")
;; "ivan"
  \end{clojure}
\end{english}

Переменная \code{*1} полезна для записи в файл. Предположим, мы хотим сохранить переменные среды, чтобы исследовать позже. Для этого введите:

\begin{english}
  \begin{clojure}
(spit "dump.edn" (pr-str *1))
  \end{clojure}
\end{english}

На диске появится файл \code{dump.edn} с данными. Позже мы прочтем его комбинацией \code{slurp} и \code{read-string}:

\begin{english}
  \begin{clojure}
user=> (read-string (slurp "dump.edn"))

{"HOME" "/Users/ivan"
 "LC_TERMINAL_VERSION" "3.3.12"
 "USER" "ivan"
 ...}
  \end{clojure}
\end{english}

Доступны три переменных результата: \code{*1}, \code{*2} и \code{*3}. С каждым вычислением результаты смещаются: последний будет в \code{*1}, предпоследний в \code{*2} так далее. Покажем это на примере:

\begin{english}
  \begin{clojure}
user=> 1
1

user=> 2
2

user=> 3
3

user=> (println *1 *2 *3)
3 2 1
  \end{clojure}
\end{english}

Чтобы загрузить в REPL несколько определений, используйте функцию \code{load-file}. Она принимает один аргумент~--- путь к файлу с кодом на Clojure:

\begin{english}
  \begin{clojure}
(load-file "my_functions.clj")
  \end{clojure}
\end{english}

Эффект аналогичен тому, как если бы вы скопировали содержимое файла и вставили в REPL. Функция не влияет на текущее пространство имен, как это делают формы \code{ns} или \code{require}. В боевом коде \code{load-file} не используют, потому что такая загрузка делает код неочевидным: неясно, откуда взялось то или иное определение. Но для экспериментов \code{load-file} подходит идеально.

REPL предлагает макросы для интроинспеции. Выражение \code{(doc ...)} напечатает справку указанной функции, например:

\begin{english}
  \begin{text}
(doc assoc)
-------------------------
clojure.core/assoc
([map key val] [map key val & kvs])
  assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be <= (count vector).
  \end{text}
\end{english}

А форма \code{(source ...)}~--- ее исходный код (приведем в сокращении):

\begin{english}
  \begin{clojure}
(source assoc)
;;
(def
 ^{:arglists '([map key val] [map key val & kvs])
   :doc "..."
   :added "1.0"
   :static true}
 assoc
 (fn ^:static assoc
   ([map key val] (clojure.lang.RT/assoc map key val))
   ([map key val & kvs]
    (...)))) ;; truncated
  \end{clojure}
\end{english}

REPL предлагает и другие возможности, о которых мы поговорим позже. Пока что завершите сеанс нажатием \code{Ctrl+D} или выполните \code{(quit)} или \code{(exit)}.

\subsection{Более сложный сценарий}

REPL подходит не только для быстрых экспериментов; опытные разработчики проводят в нем часы и дни. Одна из причин в том, что REPL~--- лучший способ разведать ситуацию, когда вы не знаете точно, какие данные приходят из внешних источников.

\def\urljokeapi{https://jokeapi.dev/}

Предположим, мы пишем бота для Telegram, который публикует шутки для программистов. Понадобится сервис, который бы выступил в роли источника шуток. Быстрый поиск дает нам сервис \footurl{Joke API}{\urljokeapi}[Joke API] с удобным API по протоколу HTTP.

Прежде чем писать бота, убедимся в работе сервиса. Для этого понадобятся HTTP-клиент и парсер JSON. Если вы запускаете REPL при помощи \code{lein}, создайте файл \code{project.clj} с содержимым:

\begin{english}
  \begin{clojure}
(defproject repl-chapter "0.1.0-SNAPSHOT"
  :dependencies [[org.clojure/clojure "1.10.0"]
                 [clj-http "3.9.1"]
                 [cheshire "5.8.1"]])
  \end{clojure}
\end{english}

Для утилит Clojure CLI файл \code{deps.edn} выглядит так:

\begin{english}
  \begin{clojure}
{:deps
 {clj-http/clj-http {:mvn/version "3.9.1"}
  cheshire/cheshire {:mvn/version "5.8.1"}}}
  \end{clojure}
\end{english}

Запустите REPL. Обе библиотеки, если еще не были установлены локально, скачаются на ваш компьютер. Подключите их в сеансе:

\begin{english}
  \begin{clojure}
(require '[clj-http.client :as client])
(require 'cheshire.core)
  \end{clojure}
\end{english}

Подготовим словарь запроса:

\begin{english}
  \begin{clojure}
(def request
  {:url "https://v2.jokeapi.dev/joke/Programming"
   :method :get
   :as :json})
  \end{clojure}
\end{english}

Получим ответ:

\begin{english}
  \begin{clojure}
(def response
  (client/request request))
  \end{clojure}
\end{english}

Каждый результат мы связываем с переменной при помощи \code{def}, чтобы позже сослаться на него. Такой стиль не подходит для промышленного кода, но приемлем в REPL. Поместим тело в отдельную переменную и напечатаем его:

\begin{english}
  \begin{clojure}
(def data
  (:body response))

{:category "Programming"
 :delivery "They only like chicken NuGet."
 :type "twopart"
 :setup ".NET developers are picky when it comes to food."
 :lang "en"
 :id 49
 :error false
 :safe true
 :flags
 {:nsfw false
  :religious false
  :political false
  :racist false
  :sexist false
  :explicit false}}
  \end{clojure}
\end{english}

Чтобы лучше понять структуру ответа, исследуем его в инспекторе:

\begin{english}
  \begin{clojure}
(require '[clojure.inspector :as insp])
(insp/inspect-tree data)
  \end{clojure}
\end{english}

Из данных видно, что шутка состоит из двух частей: \code{setup} и \code{delivery} (термины можно перевести как "заход" и "разрешение"). Такая структура полезна, когда разрешение показывают не сразу, а после паузы или под тегом спойлера. Так у читателя будет шанс придумать свой вариант. В нашем случае мы просто объединим обе фразы:

\begin{english}
  \begin{clojure}
(def joke
  (let [{:keys [setup
                delivery]} data]
    (format "%s %s" setup delivery)))

".NET developers are picky when it comes to food. They only like chicken NuGet."
  \end{clojure}
\end{english}

Если передать необязательный параметр \code{contains}, получим шутку на заданную тему. Например, если это чат о языке Python, будем шутить про JavaScript:

\begin{english}
  \begin{clojure}
(def request
  {:url "https://v2.jokeapi.dev/joke/Programming"
   :method :get
   :query-params {:contains "javascript"}
   :as :json})

...

"Why was the JavaScript developer sad?
Because they didn't Node how to Express themself!"
  \end{clojure}
\end{english}

Итак, мы написали фрагменты кода под каждый шаг. Составим функцию, которая принимает язык, про который нужно шутить, и возвращает текст шутки:

\begin{english}
  \begin{clojure}
(defn get-joke [lang]
  (let [request
        {:url "https://v2.jokeapi.dev/joke/Programming"
         :method :get
         :query-params {:contains lang}
         :as :json}

        response
        (client/request request)

        {:keys [body]}
        response

        {:keys [setup delivery]}
        body]

    (format "%s %s" setup delivery)))
  \end{clojure}
\end{english}

В действии:

\begin{english}
  \begin{clojure}
(get-joke "python")
"Why did the Python programmer not respond to the foreign mails he got?
Because his interpreter was busy collecting garbage."

(get-joke "javascript")
"How did you make your friend rage?
I implemented a greek question mark in his JavaScript code."
  \end{clojure}
\end{english}

На этом этапе еще рано завершать REPL: данные, что мы получили с сервера, пригодятся в тестах. Сохраним их json-файл. Для этого выполним:

\begin{english}
  \begin{clojure}
(spit "joke-ok.json"
      (cheshire.core/generate-string
       data {:pretty true}))

;; or

(require '[clojure.java.io :as io])
(cheshire.core/generate-stream
  data (io/writer "joke-ok.json") {:pretty true})
  \end{clojure}
\end{english}

Обратите внимание на параметр \code{:pretty}. С ним JSON будет красиво оформлен, то есть записан с отступами и переносами, а не в одну строку.

Важно знать, как ведет себя сторонний сервис в случае ошибки. Если пошутить о Clojure, получим неприятный результат:

\begin{english}
  \begin{clojure}
(get-joke "clojure")
"null null"
  \end{clojure}
\end{english}

Чтобы понять, почему так получилось, исследуем ответ сервера:

\begin{english}
  \begin{clojure}
(def data
  (-> {:url "https://v2.jokeapi.dev/joke/Programming"
       :method :get
       :query-params {:contains "clojure"}
       :as :json}
      (client/request)
      (:body)))
  \end{clojure}
\end{english}

Данные:

\begin{english}
  \begin{clojure}
{:error true
 :internalError false
 :code 106
 :message "No matching joke found"
 :causedBy ["No jokes were found that match your provided filter(s)."]
 :additionalInfo
 "Error while finalizing joke filtering: No jokes were found that match your provided filter(s)."
 :timestamp 1651054623055}
  \end{clojure}
\end{english}

Сервер не нашел подходящих шуток и вернул словарь с полем \code{{:error true}}. Перепишите функцию так, чтобы в случае ошибки мы получили \code{nil}, а не строку с \code{null}.

Негативный ответ тоже пригодится в тестах. Запишите его в файл с понятным именем:

\begin{english}
  \begin{clojure}
(cheshire.core/generate-stream
  data (io/writer "joke-err.json") {:pretty true})
  \end{clojure}
\end{english}

Итак, разведка выполнена. Мы убедились, что сервис отвечает на запросы. Мы получили данные для тестов. Стало ясно, как ведет себя сервис в случае ошибки. Во время экспериментов появились наброски кода, из которых легко составить конечную версию.

Важно, что эти наброски опираются на реальные данные, а не документацию или систему классов. И то и другое может устареть и не давать реальной картины~--- что именно передается по сети. В случае с REPL подобной ошибки быть не может.

Только теперь, с багажом опыта и данных, можно садиться за промышленный код. Мы уже проделали основную работу, и остальная часть не потребует усилий. Все это благодаря REPL, который выполнил роль черновика, отладчика и поля экспериментов.

\subsection{Свой REPL}

Чтобы лучше понять устройство REPL, напишем свою реализацию. Подготовьте минимальный проект с файлом \code{project.clj} или \code{deps.edn}. В файл \code{src/my\_repl.clj} поместите следующий код:

\begin{english}
  \begin{clojure}
(ns my-repl
  (:gen-class))

(defn -main [& args]
  (repl))
  \end{clojure}
\end{english}

Форма \code{(:gen-class)} в теле \code{ns} означает, что при компиляции пространства получится одноименный класс. Это же пространство должно быть указано главным в файле \code{project.clj}:

\begin{english}
  \begin{clojure}
:main my-repl
  \end{clojure}
\end{english}

Функция \code{-main}~--- точка входа в будущий класс~--- запускает функцию \code{repl}, которую предстоит написать. Вот ее черновик:

\begin{english}
  \begin{clojure}
(defn repl []
  (loop []
    (let [input (read-line)
          expr (read-string input)
          result (eval expr)]
      (println result)
      (recur))))
  \end{clojure}
\end{english}

Это бесконечный цикл, где на каждом шаге происходит следующее:

**Чтение (Read)**

Функция \code{read-line} читает строку из стандартного канала ввода (stdin). Если канал пуст, система ожидает ввода с клавиатуры. Пользователь набирает текст в терминале и жмет Enter. В переменной \code{input} окажется строка.

Функция \code{read-string} читает объект Clojure из строки. Числа, строки и другие примитивы выражаются сами в себя. Например, из строки "1" получим единицу. Символы остаются невычисленными: строка \code{"(foo bar)"} вернет список с символами \code{foo} и \code{bar}. В переменной \code{expr} окажется объект Clojure: символ, строка, число или их коллекция.

\begin{english}
  \begin{clojure}
=> (read-string "(foo [1 false {:foo BAZ}])")
;; (foo [1 false {:foo BAZ}])
  \end{clojure}
\end{english}

**Вычисление (Eval)**

Функция \code{eval} принимает выражение и вычисляет его. В отличии от других языков, в Clojure \code{eval} ожидает не строку, а форму, то есть примитив (число, символ, кейворд) или коллекцию. Примитивы вычисляются сами в себя:

\begin{english}
  \begin{clojure}
=> (eval 1)
1

=> (eval :foo)
:foo
  \end{clojure}
\end{english}
Символы вычисляются в переменные текущего пространства. Например, символ \code{+}
связан с функцией \code{clojure.core/+}, и его вычисление вернет объект функции:

\begin{english}
  \begin{clojure}
=> (eval '+)
#function[clojure.core/+]
  \end{clojure}
\end{english}

В вычислении можно сослаться на любую переменную, в том числе созданную вами:

\begin{english}
  \begin{clojure}
(def some-text "Hello")
(eval '(str some-text " World!"))
"Hello World!"
  \end{clojure}
\end{english}

Вариант посложнее со словарем и \code{update-in}:

\begin{english}
  \begin{clojure}
(def data {:a {:b 0}})
(eval '(update-in data [:a :b] inc))
{:a {:b 1}}
  \end{clojure}
\end{english}

Если переменной, на которую ссылается символ, нет, получим исключение:

\begin{english}
  \begin{clojure}
(eval 'dunno)
Syntax error compiling at ...
Unable to resolve symbol: dunno in this context
  \end{clojure}
\end{english}

**Печать (Print)**

Следующий шаг~--- печать. Результат \code{eval} выводится на экран обычной функцией \code{println}:

\begin{english}
  \begin{clojure}
(println result)
  \end{clojure}
\end{english}

**Повтор (Loop)**

Оператор \code{loop} переносит нас к первому шагу~--- чтению с клавиатуры~--- и все повторяется.

Хоть это и крайне сырая версия REPL, она работает. Скомпилируйте проект командой \code{lein uberjar} и запустите jar-файл:

\begin{english}
  \begin{clojure}
java -jar target/uberjar/repl-chapter-0.1.0-SNAPSHOT-standalone.jar
  \end{clojure}
\end{english}

Введите несколько выражений на Clojure, отделяя клавишей Enter. После каждого появится результат вычисления. Приведем фрагмент сеанса:

\begin{english}
  \begin{clojure}
=> (+ 1 2)
3

=> (assoc {:one 1} :two 2)
{:one 1, :two 2}

=> (defn add [a b] (+ a b))
#'clojure.core/add

=> (add 4 5)
9

=> (require '[clojure.string :as str])
nil

=> (str/split "1 2 3" #"\s")
[1 2 3]
  \end{clojure}
\end{english}

Мы поработали со словарями, определили функцию и вызвали ее, затем подключили модуль. Даже в таком примитивном REPL доступны все возможности языка.

\subsubsection{Улучшения}

Предлагаем читателю доработать наш самописный REPL~--- это будет отличная практика.

\paragraph{Выход из цикла}

На текущий момент нельзя завершить REPL без нажатия \code{Ctrl+C}, что неудобно. Сделайте так, чтобы какое-то выражение означало остановку. Например, если пользователь ввел кейворд \code{:repl/exit}, REPL завершается. Проверка может выглядеть так:

\begin{english}
  \begin{clojure}
(let [input (read-line)
      expr (read-string input)]
  (when-not (= expr :repl/exit)
    ...))
  \end{clojure}
\end{english}

При вводе \code{:repl/exit} оператор \code{loop} не сработает, и REPL выйдет из цикла.

\paragraph{Перехват исключений}

Сейчас, если выражение содержит ошибку, программа завершится аварийно. Исключение~--- не повод завершать эксперимент: просто напечатаем его и продолжим. Оберните каждый шаг цикла в \code{try/catch} с классом \code{Throwable}, чтобы поймать любое исключение:

\begin{english}
  \begin{clojure}
(defn repl []
  (loop []
    (let [[result e]
          (try
            [(-> (read-line)
                 (read-string)
                 (eval))
             nil]
            (catch Throwable e
              [nil e]))]
      (if e
        (binding [*out* *err*]
          (println (ex-message e)))
        (println result))
      (recur))))
  \end{clojure}
\end{english}

Скомпилируйте проект заново и запустите. На этот раз программа не "вывалится", а покажет сообщение и пригласит к дальнейшему вводу:

\begin{english}
  \begin{clojure}
=> 1
1

=> (/ 0 0)
Divide by zero
  \end{clojure}
\end{english}

Обратите внимание: форма \code{recur} не может быть внутри \code{try/catch}, поэтому идем на уловку. Выражение \code{try} возвращает пару, где первый элемент~--- результат, если не было ошибок, а второй~--- \code{nil} или ошибка, если таковая случилась. Прием с парой мы рассмотрели в первой книге в главе об исключениях.

В зависимости от того, что мы получили~--- результат или ошибку,~--- выводим результат в \code{stdout} или \code{stderr} при помощи связывания \code{binding}. В данном примере мы только печатаем текст исключения. Больше деталей можно получить функцией \code{print-stack-trace} из модуля \code{clojure.stacktrace}.

Еще одно замечание касается строки \code{(if e ...)}. Мы проверяем именно исключение, а не результат, потому что результат вполне может быть \code{nil}.

\paragraph{Обработчик исключения}

Чтобы сделать REPL более гибким, поместим обработку исключений в отдельную функцию:

\begin{english}
  \begin{clojure}
(defn exception-handler [e]
  (binding [*out* *err*]
    (println (ex-message e))))
  \end{clojure}
\end{english}

С ней логика \code{loop/recur} станет чище:

\begin{english}
  \begin{clojure}
(loop []
  (...
   (if e
     (exception-handler e))))
  \end{clojure}
\end{english}

Пусть функция \code{repl} принимает параметр, чтобы задать свой обработчик исключения. Если он не задан, сработает функция по умолчанию, которую объявили выше. Для ясности переименуем ее в \code{default-exception-handler}. Далее перепишем \code{repl}:

\begin{english}
  \begin{clojure}
(defn repl [& [{:keys [exception-handler]}]]
  (let [ex-handler
        (or exception-handler
            default-exception-handler)]
    (loop []
      (...
        (if e
          (ex-handler e))))))
  \end{clojure}
\end{english}

До того как мы вступим в цикл, переменной \code{ex-handler} назначен обработчик~--- переданный или заданный по умолчанию. Эта оптимизация нужна , чтобы не вычислять обработчик на каждом шаге.

Запустите \code{repl} с обработчиком, который печатает тип исключения:

\begin{english}
  \begin{clojure}
(defn -main [& args]
  (repl {:exception-handler
         (fn [e] (println (type e)))}))
  \end{clojure}
\end{english}

Результат:

\begin{english}
  \begin{clojure}
=> (/ 0 0)
java.lang.ArithmeticException
  \end{clojure}
\end{english}

\paragraph{Красивая печать}

Функция \code{println} выводит данные в одну строку, что не подходит для вложенных коллекций. Чтобы вывод был удобен, нужны переносы строк и отступы. Воспользуйтесь функцией \code{pprint} из модуля \code{clojure.pprint}:

\begin{english}
  \begin{clojure}
(ns my-repl
  (:require
   [clojure.pprint :as pprint]))

(defn repl [...]
  (loop []
    (let [...]
      (pprint/pprint result)
      (recur))))
  \end{clojure}
\end{english}

Опробуем красивую печать в действии. Понадобится большая коллекция, например словарь переменных среды:

\begin{english}
  \begin{clojure}
(pprint/pprint
  (into {} (System/getenv)))

{"LEIN_VERSION" "2.9.5",
 "HOME" "/Users/ivan",
 "LC_TERMINAL_VERSION" "3.3.12",
 "USER" "ivan"
 ...
 }
  \end{clojure}
\end{english}

Данные будут напечатаны построчно, что гораздо удобней для чтения. Обратите внимание, что красивая печать работает только для типов Clojure, поэтому мы приводим результат \code{(System/getenv)} к словарю функцией \code{into}. Без этого получим экземпляр класса \code{UnmodifiableMap}, на который красивая печать не действует.

В первой книге мы упоминали, что на \code{pprint} влияют глобальные динамические переменные \code{*print-length*} и \code{*print-level*}~--- максимальные длина и глубина коллекции. Пусть наш REPL позволит изменить эти значения. Если они заданы, цикл запускается в форме \code{binding} с переопределением длины и глубины. Минимальные правки:

\begin{english}
  \begin{clojure}
(defn repl [& [{:keys [print-level
                       print-length]}]]
  (binding [*print-level*
            (or print-level *print-level*)
            *print-length*
            (or print-length *print-length*)]
    ...))

(defn -main [& args]
  (repl {:print-length 3}))
  \end{clojure}
\end{english}

Запустив новый REPL, введите коллекцию длиннее трех элементов. При печати вы увидите ее усеченную версию:

\begin{english}
  \begin{clojure}
=> [1 2 3 4 5]
[1 2 3 ...]
  \end{clojure}
\end{english}

\paragraph{Приглашение}

Стандартный REPL показывает приглашение вида \code{user=>}. Это удобно по двум причинам. Во-первых, ясно, в каком пространстве мы находимся сейчас~--- в процессе работы его часто переключают. Во-вторых, стрелка подсказывает, что от нас ожидают ввод.

Добавьте приглашение перед вводом с клавиатуры (вызовом \code{read-line}). Для начала ограничимся статичной строкой:

\begin{english}
  \begin{clojure}
(loop []
  (print "repl=> ")
  (flush)
  (let [...]
    ...))
  \end{clojure}
\end{english}

Вызов \code{(flush)} необходим, чтобы отправить текст в терминал, не дожидаясь наполнения буфера. С приглашением REPL выглядит живее:

\begin{english}
  \begin{clojure}
repl=> :hello/repl
:hello/repl

repl=> {:foo "test"}
{:foo test}
  \end{clojure}
\end{english}

Логично, чтобы за приглашение отвечала функция \code{get-prompt}, которая принимает текущее пространство:

\begin{english}
  \begin{clojure}
(defn get-prompt [this-ns]
  (format "%s=> " (ns-name this-ns)))

(defn repl []
  (binding [*ns* *ns*]
    (loop []
      (print (get-prompt *ns*))
      ...)))
  \end{clojure}
\end{english}

При смене пространства в REPL меняется и приглашение:

\begin{english}
  \begin{clojure}
clojure.core=> (in-ns 'repl-test)

repl-test=> (clojure.core/refer-clojure)
nil

repl-test=> (+ 1 2)
3
  \end{clojure}
\end{english}

Обратите внимание на форму \code{(binding [*ns* *ns*] ...)} перед \code{loop}. Без нее не получится сменить пространство: функция \code{in-ns} меняет переменную \code{*ns*} формой \code{(set! *ns* ...)}, что невозможно вне макроса \code{binding}.

Доработайте REPL так, чтобы можно было задать свой обработчик приглашения. Напишите обработчик, который выводит текущее время или длительность сеанса:

\begin{english}
  \begin{clojure}
18:12=> ...
18:14=> ...

00:00:05=> ...
00:03:34=> ...
  \end{clojure}
\end{english}

\paragraph{Переменная результата}

Еще одна полезная доработка~--- хранить последний результат в переменной, чтобы позже ссылаться на него. Назовем переменную \code{-r} (result).

Исправим REPL: поместим цикл в форму \code{with-local-vars}. Макрос задает локальные переменные, которые напоминают атомы. Чтобы изменить переменную, вызывают \code{var-set}. Значение получают функцией \code{var-get} или оператором \code{@} \code{(deref)}. Новая версия REPL:

\begin{english}
  \begin{clojure}
(defn repl []
  (with-local-vars [-r nil]
    (loop []
      (let [input (read-line)
            expr (read-string input)
            result
            (case expr
              -r (var-get -r)
              (eval
               \code{(let [~'-r ~(var-get -r)]
                  ~expr)))]
        (var-set -r result)
        (println result)
        (recur)))))
  \end{clojure}
\end{english}

Обратите внимание на то, как вычисляется форма \code{expr}. С помощью оператора \code{case} мы проверяем: если поступил символ \code{-r}, вернем значение переменной \code{-r}. Ввод \code{-r} считается особенным, потому что вычисляется без \code{eval}.

Чтобы сослаться на \code{-r} в выражении, например \code{(+ -r 3)}, идут на трюк. Форма \code{expr} погружается в макрос \code{let}, где символ \code{-r} связан со значением \code{-r}. Причина этих махинаций в том, что \code{eval} не учитывает локальные переменные, и без \code{let} мы получим ошибку, что символ \code{-r} неизвестен. Эту проблему мы подробно изучим в разделе про отладку, а пока что ограничимся минимально рабочим вариантом.

Запустите REPL и проверьте, что в \code{-r} остается результат, при этом на него можно сослаться в выражении:

\begin{english}
  \begin{clojure}
=> (+ 1 2 3)
6

=> -r
6

=> (* -r 3)
18

=> -r
18
  \end{clojure}
\end{english}

Доработайте REPL так, чтобы, кроме результата, он хранил последнее исключение в переменной \code{-e}. Например:

\begin{english}
  \begin{clojure}
(/ 1 0)
;; ... Stacktrace ...

-e
;; Execution error (ArithmeticException)...
;; Divide by zero
  \end{clojure}
\end{english}

Для этого добавьте в макрос \code{with-local-vars} привязку \code{[... -e nil]}. При помощи \code{try/catch} перехватывайте ошибку. Если что-то поймано, запишите исключение в \code{-e}:

\begin{english}
  \begin{clojure}
(with-local-vars [-r nil -e nil]
  ...
  (try
    ...
    (catch Throwable e
      (var-set -e e))))
  \end{clojure}
\end{english}

\paragraph{Многострочный ввод}

До сих пор мы вводили выражения под одной строке. Теперь мы хотим задать функцию с переносом после сигнатуры:

\begin{english}
  \begin{clojure}
=> (defn add [a b]
    (+ a b))
  \end{clojure}
\end{english}

Если нажать ввод после \code{b]}, произойдет следующее. Клавиша Enter завершит прием символов, и в переменной окажется строка \code{"(defn add [a b]"}. Функция \code{read-string} не сможет ее разобрать и бросит исключение:

\begin{english}
  \begin{clojure}
=> (read-string "(defn add [a b]")
Execution error at ...
EOF while reading
  \end{clojure}
\end{english}

Чтобы исправить эту неприятность, перед вызовом \code{read-line} следует убедиться, что форма завершена. Для этого проверим строку на баланс скобок: на каждую открывающую приходится закрывающая того же типа (круглая, квадратная, фигурная). Если в строке незакрытые скобки, мы запрашиваем еще одну строку и продолжаем учет скобок. Как только все скобки закрыты, накопленные строки вычисляются как одно выражение.

Чтобы выделить многострочный ввод визуально, каждая следующая строка предваряется отступом:

\begin{english}
  \begin{clojure}
(defn add [a b]
..(let [c (+ a b)]
....(* c 3)))
  \end{clojure}
\end{english}

Длина отступа (число точек) равна уровню формы~--- числу вложенных скобок, умноженному на два.

\def\urlstack{https://en.wikipedia.org/wiki/Stack\_(abstract\_data\_type)}

Для учета скобок подойдет \footurl{стек}{\urlstack}[Stack]~--- структура данных, которая работает по принципу FILO (First In Last Out, первым пришел~--- последним ушел). В стек добавляют и извлекают из него элементы. Ограничение в том, что извлечь их можно только в обратном порядке. Например, если добавить в стек числа 1, 2, 3, то при извлечении получим 3, 2, 1.

При анализе строки мы перебираем ее символы. Открывающие скобки попадают в стек. Как только мы встретили закрывающую скобку, происходит следующее:

- убираем с вершины стека последнюю скобку;
- убеждаемся, что она парная к найденной. Если это не так, бросаем исключение.

Например, если в стеке содержатся элементы \code{(}, \code{[}, \code{\{} и мы встретили закрывающую фигурную скобку, все в порядке: она относится к элементу на вершине \code{\{}. Если же попалась квадратная закрывающая, это говорит об ошибке в синтаксисе.

\begin{english}
  \begin{text}
;; ok
"(..[..{..}......"
          ^
;; error
"(..[..{..]......"
  \end{text}
\end{english}

Для начала опишем стек. Это функция, которая порождает функцию, замкнутую на атоме. Внутренняя функция принимает различные команды. Оператор \code{case} определяет их логику. У функции два тела: команды без аргументов и с одним аргументом.

Стек поддерживает команды:

- \code{:count}, узнать число элементов;
- \code{:empty?}, проверка на пустоту;
- \code{:pop}, извлечь элемент с вершины;
- \code{:push}, добавить элемент.

От других команд \code{:push} отличается тем, что принимает аргумент~--- значение, которое добавляют. Поэтому \code{:push} описан во втором теле.

\begin{english}
  \begin{clojure}
(defn make-stack []
  (let [-stack (atom nil)]
    (fn stack
      ([cmd]
       (case cmd
         :count (count @-stack)
         :empty? (zero? (count @-stack))
         :pop (let [item (first @-stack)]
                (swap! -stack rest)
                item)))
      ([cmd arg]
       (case cmd
         :push
         (swap! -stack conj arg))))))
  \end{clojure}
\end{english}

Изначально атом хранит \code{nil}, при добавлении элемента к которому получится список. Функция \code{conj} добавляет элемент в начало списка. Вот почему вершину стека получают функцией \code{first}, а усекают функцией \code{rest}.

Стек в действии:

\begin{english}
  \begin{clojure}
(def s (make-stack))

(s :count)  ;; 0
(s :empty?) ;; true
(s :push 1) ;; (1)
(s :push 2) ;; (2 1)
(s :push 3) ;; (3 2 1)
(s :count)  ;; 3
(s :pop)    ;; 3
(s :pop)    ;; 2
(s :pop)    ;; 1
(s :empty?) ;; true
  \end{clojure}
\end{english}

Наш стек является изменяемым объектом. Более "кложурный" способ был бы в том, чтобы сделать его неизменяемым: каждая операция возвращала бы его копию подобно функциям \code{assoc} или \code{update}. Но для разнообразия мы решили поработать с изменяемым стеком. Читатели, близко знакомые с Java, могут взять на вооружение класс \code{java.util.Stack} со схожими возможностями.

Анализ строки сводится к тому, чтобы сперва наполнить стек открывающими скобками, а затем опустошить закрывающими. Если в итоге стек пуст, строка сбалансирована.

Напишем функцию \code{multi-input}, которая читает ввод с клавиатуры до тех пор, пока выражение не сбалансировано. Считанные строки объединяются в одну пробелом. При вводе очередной строки покажем уровень вложенности отступами. Вот алгоритм функции:

\begin{english}
  \begin{clojure}
(defn multi-input []
  (let [stack (make-stack)]
    (loop [result ""]
      (print (make-indent stack))
      (flush)
      (let [line (read-line)
            result (str result " " line)]
        (consume-line stack line)
        (if (stack :empty?)
          result
          (recur result))))))
  \end{clojure}
\end{english}

Код довольно короткий и опирается на две служебные функции. Первая \code{make-indent} строит отступ из точек; его длина равна двойному числу элементов в стеке:

\begin{english}
  \begin{clojure}
(defn make-indent [stack]
  (str/join (repeat (* (stack :count) 2) ".")))
  \end{clojure}
\end{english}

Вторая функция \code{consume-line} сложнее. Она принимает стек и строку, проходит по символам и корректирует стек. Для корректировки нужен словарь парных скобок. Его ключи и значения~--- символы типа \code{Char}:

\begin{english}
  \begin{clojure}
(def brace-pairs
  {\( \)
   \[ \]
   \{ \}})
  \end{clojure}
\end{english}

Понадобится зеркальная копия этого словаря, чтобы по закрывающей скобке найти открывающую:

\begin{english}
  \begin{clojure}
(def brace-oppos
  (into {} (for [[k v] brace-pairs]
             [v k])))
  \end{clojure}
\end{english}

Код насыщения стека:

\begin{english}
  \begin{clojure}
(defn consume-line [stack line]
  (doseq [char line]
    (cond
      (contains? brace-pairs char)
      (stack :push char)

      (contains? brace-oppos char)
      (let [char-oppos
            (get brace-oppos char)
            char-lead
            (stack :pop)]
        (when-not (= char-lead char-oppos)
          (throw
           (new Exception
                (format "Unbalanced expression: %s...%s"
                        char-lead char))))))))
  \end{clojure}
\end{english}

Логика следующая: если символ~--- открывающая скобка (входит в \code{brace-pairs}), добавить ее в стек. Если закрывающая (входит в \code{brace-oppos}), найти по ней открывающую (переменная \code{char-oppos}). Далее получить элемент с вершины стека методом \code{:pop} (переменная \code{char-lead}). Если переменные не равны, бросить исключение.

Вернитесь в функцию \code{repl} и замените \code{(read-line)} на \code{(multi-input)}. Скомпилируйте проект и опробуйте REPL в действии. Вот что получилось у автора:

\begin{english}
  \begin{clojure}
=> (+ 1 2 3
=> ..3 4 5)
18

=> (defn add [a b]
=> ..(+ a b))
#'clojure.core/add

=> (assoc-in {:foo 1
=> ....:bar 2
=> ....:baz 3
=> ....}
=> ..[:test :hello]
=> ..3
=> ..)
{:bar 2 :baz 3 :foo 1 :test {:hello 3}}
  \end{clojure}
\end{english}

Очевидно, ввести длинное выражение гораздо легче. Проверьте код с неверными скобками. Исключение подскажет, какие именно скобки были причиной:

\begin{english}
  \begin{clojure}
=> (+ 1 2 3]
java.lang.Exception: Unbalanced expression: (...]
  \end{clojure}
\end{english}

Заметим, что попытка извлечь элемент из пустого стека тоже считается ошибкой. Это может случится при работе со строкой \code{"(+ 1 2 3))"}. Предпоследняя скобка очистит стек, но последняя обратится к пустому стеку, что говорит о нарушении. Без доработок мы получим сообщение с \code{null}, что понятно:

\begin{english}
  \begin{clojure}
Unbalanced expression: null...)
  \end{clojure}
\end{english}

Перепишем команду \code{:pop} так, чтобы учесть пустой стек:

\begin{english}
  \begin{clojure}
:pop (if (empty? @-stack)
       (throw (new Exception "Stack is empty!"))
       (let [item (first @-stack)]
         (swap! -stack rest)
         item))
  \end{clojure}
\end{english}

Если ввести код с лишними скобками на конце, получим исключение:

\begin{english}
  \begin{text}
java.lang.Exception: Stack is empty!
  \end{text}
\end{english}

Подсчет скобок может дать осечку для внутренних строк. Предположим, мы объявили строку со смайликом внутри:

\begin{english}
  \begin{clojure}
(def text "Hello Clojure :-)")
  \end{clojure}
\end{english}

Наш анализатор не знает, что нужно игнорировать скобки внутри строки. В результате получим ошибку о пустом стеке. Доработайте \code{(multi-input)} так, чтобы при переходе через двойную кавычку включался режим <<в строке>>", когда скобки не добавляются в стек. При выходе из строки флаг отключается.

\subsubsection{REPL в REPL}

Еще одна интересная задача: что случится, если вызвать в сеансе функцию \code{(repl)}? Другими словами, запустить REPL в REPL?

Ответ~--- вы запустите новый сеанс, а прежний повиснет в ожидании. В новом REPL доступны изменения, что вы сделали раньше. При завершении вы вернетесь в прежний REPL и продолжите работу. Покажем это на примере (напомним, что ввод \code{:repl/exit} завершает REPL:

\begin{english}
  \begin{clojure}
=> (def x (+ 1 2))
#'my-repl/x

=> (repl)

=> (* x x)
9

=> :repl/exit
nil

=> (println "still in the REPL")
;; still in the REPL
nil
  \end{clojure}
\end{english}

Видно, что переменная \code{x}, объявленная во внешнем сеансе, доступна во внутреннем. Ввод \code{:repl/exit} возвращает нас в прежний REPL, не завершая программу. Усложним сценарий, поместив \code{(repl)} в середину вычислений:

\begin{english}
  \begin{clojure}
=> (let [a 1 b 2] (repl) (+ a b))

=> (+ 3 4)
7

=> :repl/exit
3
  \end{clojure}
\end{english}

В этом примере форма \code{let} повиснет до тех пор, пока не завершится внутренний REPL. Пребывая в нем, мы ввели выражение \code{(+ 3 4)}. После выхода получим результат всей формы~--- тройку.

Вложенные сеансы встречаются редко, но они не должны вводить вас в ступор. С точки зрения программы это то же самое, что бесконечный цикл в бесконечном цикле: при завершении внутреннего вы вернетесь во внешний. Вложенность сеансов ограничена только ресурсами компьютера.

\subsubsection{Доступ к локальным переменным}

Должно быть, вы догадались: вложенный REPL удобен в качестве отладчика. Он прерывает код и поэтому работает как точка останова. С его помощью мы бы остановились на сложном участке кода, чтобы исследовать переменные.

Недостаток нашего REPL в том, у него нет доступа локальным переменным. Предопложим, мы запустили REPL внутри формы \code{let} или функции с аргументами:

\begin{english}
  \begin{clojure}
(let [a 1 b 2]
  (repl)
  (+ a b))

;; or

(defn add [a b]
  (repl)
  (+ a b))

(add 1 2)
  \end{clojure}
\end{english}

Логично ожидать, что при вводе \code{a} или \code{b} во вложенном REPL получим единицу и двойку. Однако это не так~--- сославшись на них, увидим исключение о том, что символ неизвестен:

\begin{english}
  \begin{clojure}
=> a
java.lang.RuntimeException: Unable to resolve symbol: a in this context
  \end{clojure}
\end{english}

Как мы упоминали выше, функция \code{eval} учитывает только глобальные переменные, то есть заданные при помощи \code{def}. Предупреждая ваше огорчение, скажем~--- все-таки можно сделать так, чтобы локальные переменные были доступны. В середине главы мы напишем свой отладчик, где эта проблема решена. Пока что предложим читателю подумать над этим вопросом.

На этом мы закончим работу над собственным REPL и двинемся дальше.

\subsection{Полезные функции REPL}

Модуль \code{clojure.repl} содержит функции и макросы для интерактивного сеанса. В основном они служат для информации о переменных и окружении. Подключите модуль командой \code{use}, чтобы пользоваться им без псевдонима:

\begin{english}
  \begin{clojure}
(use 'clojure.repl)
  \end{clojure}
\end{english}

Функция \code{apropos} ищет определение по строке или регулярному выражению. Для слова \code{"update"} найдутся следующие кандидаты:

\begin{english}
  \begin{clojure}
(apropos "update")

(clojure.core/update
 clojure.core/update-in
 clojure.core/update-keys
 clojure.core/update-proxy
 clojure.core/update-vals)
  \end{clojure}
\end{english}

Если объявить переменную со словом \code{"update"} в названии:

\begin{english}
  \begin{clojure}
(def updated-result 42)
  \end{clojure}
\end{english}

\noindent
и выполнить поиск еще раз, в выборке окажется символ \code{user/updated-result}.

Макрос \code{dir} выводит все публичные переменные пространства:

\begin{english}
  \begin{clojure}
(dir clojure.string)

blank?
capitalize
ends-with?
escape
...
  \end{clojure}
\end{english}

Знакомый макрос \code{(doc ...)} печатает справку определения. Если это функция или макрос, вы увидите возможные параметры вызова.

\begin{english}
  \begin{clojure}
(defn add
  "Add two numbers."
  [a b]
  (+ a b))
  \end{clojure}
\end{english}

\begin{english}
  \begin{text}
=> (doc add)
-------------------------
user/add
([a b])
  Add two numbers.
  \end{text}
\end{english}

Если возникло исключение, REPL напечатает только его класс и сообщение, чтобы не тратить место на стек-трейс. Функция \code{pst} (сокращение от **p**rint **s**tack **t**race) принудительно выводит полное исключение.

\begin{english}
  \begin{clojure}
=> (/ 1 0)
Execution error (ArithmeticException) at user/eval175 (REPL:1).
Divide by zero
  \end{clojure}
\end{english}


\begin{english}
  \begin{clojure}
=> (pst)
ArithmeticException Divide by zero
	clojure.lang.Numbers.divide (Numbers.java:190)
	clojure.lang.Numbers.divide (Numbers.java:3911)
	user/eval175 (NO_SOURCE_FILE:1)
    ...
	clojure.main/repl/fn--9215 (main.clj:458)
	clojure.main/repl (main.clj:458)
  \end{clojure}
\end{english}


\def\urlclojurerepl{https://clojuredocs.org/clojure.repl}

Эти и другие возможности пригодятся вам в долгих сеансах REPL. Ознакомьтесь с ними \footurl{в документации}{\urlclojurerepl}[clojure.repl] к модулю \code{clojure.repl}.

\subsection{REPL в редакторе}

До сих пор мы набирали код в терминале, что не совсем удобно. Терминал подходит для коротких команд, но плохо справляется с многострочным вводом. Будет правильно набрать код в редакторе, а затем скопировать в терминал. Код останется в файле, и не придется печатать его в следующий раз.

Со временем вы заметите, что переключение между редактором и терминалом отнимает время. Было бы здорово связать редактор с REPL напрямую. Вы набираете код и с помощью комбинации клавиш выполняете в REPL. В отдельной области редактор показывает результат. С таким подходом нам доступна мощь обеих сред: REPL и редактора.

\def\urlemacs{https://www.gnu.org/software/emacs/}

Описанный способ предлагает \footurl{Emacs}{\urlemacs}[Emacs]~--- текстовый редактор с историей более сорока лет. Emacs запускает любой Лисп, будь то Common Lisp, Scheme или Clojure, и управляет им из редактора. В терминах Emacs запущенный Лисп называется внешним (external) в противоположность встроенному диалекту ELisp. Режим, когда код вычисляется внешним Лиспом, назывыется inferior lisp mode (анг. inferior~--- низший). Название объясняется тем, что, поскольку режим нацелен на любой Лисп, он поддерживает только базовые операции.

Проведем короткий сеанс REPL из Emacs. Запустите редактор и выполните команду:

\begin{english}
  \begin{text}
M-x inferior-lisp
  \end{text}
\end{english}

Emacs запросит путь интерпретатору Лиспа. Введите \code{clojure} или \code{lein repl} в зависимости от того, какая утилита у вас установлена. Чтобы не указывать программу каждый раз, объявите в настройках переменную \code{inferior-lisp-program}. Того же эффекта можно добиться, выполнив одно из выражений в буфере \code{*scratch*}:

\begin{english}
  \begin{lisp}
(setq inferior-lisp-program "clojure") ;; C-j
(setq inferior-lisp-program "lein repl") ;; C-j
  \end{lisp}
\end{english}

Emacs запустит процесс и соединится с каналами ввода и вывода. В буфере \code{*inferior-lisp*} появится сеанс REPL. Он работает как в терминале: ожидает выражение, вычисляет, печатает и снова ожидает.

\begin{english}
  \begin{clojure}
Clojure 1.10.1
user=> (+ 1 2 3)
6
  \end{clojure}
\end{english}

Поскольку это буфер Emacs, нам доступно больше возможностей. Можно свободно перемещать по нему курсор, копировать и вставлять код, искать в прямом и обратном направлении, сохранить буфер в файл и многое другое.

Особые команды передают код из редактора в REPL без ручного копирования. Переключитесь в буфер с кодом на Clojure и включите режим Lisp командой:

\begin{english}
  \begin{text}
M-x lisp-mode
  \end{text}
\end{english}

Установите курсор после закрывающей скобки любого выражения, например \code{(+ 1 2)}. Выполните команду \code{M-x lisp-eval-last-sexp}, которая означает вычислить последнее S-выражение. В буфере \code{*inferior-lisp*} появится результат:

\begin{english}
  \begin{text}
user=> 3
  \end{text}
\end{english}

Эффект аналогичен тому, как если бы вы скопировали код, вставили в REPL и нажали Enter. Заметим, что выражение не обязательно вычислять целиком. Можно выполнить форму, которая находится внутри другой формы. Предположим, в вашем файле следующий код:

\begin{english}
  \begin{clojure}
(let [a 1 b 2]
  (println "inner form") |
  (+ a b))
  \end{clojure}
\end{english}

Подведите курсор на место вертикальной черты. Выполните \code{M-x lisp-eval-last-sexp}, и REPL вычислит \code{(println "inner form")}. Ошибки не будет, потому что \code{(println ...)} не зависит от переменных \code{a} и \code{b}. Если же вычислить \code{(+ a b)}, получим ошибку, что символы не известны.

Команды с приставкой \code{lisp-eval-...} отвечают за то, какую часть файла выполнить в REPL. Например, \code{lisp-eval-region} отправит только выделенную область, а \code{lisp-eval-defun}~--- функцию, на которой сейчас установлен курсор. Команды с окончанием \code{...-and-go} делают то же самое, но дополнительно переключат вас в REPL.

Проделайте упражнения из разделов выше. Подключите встроенные модули, объявите несколько функций, спровоцируйте исключение.

Обратите внимание, что команды \code{lisp-eval-...} вычисляют код без учета текущего пространства. Контроль за тем, какое пространство активно в данный момент, ложится на вас. Если вы работаете с двумя и более модулями, это станет проблемой. Легко объявить функцию в одном пространстве:

\begin{english}
  \begin{clojure}
(ns test1)

(defn add [a b]
  (+ a b))
  \end{clojure}
\end{english}

и вызвать в другом, что приведет к ошибке:

\begin{english}
  \begin{text}
(ns test2)

(add 1 2)

test2=> Syntax error compiling at (REPL:1:1).
Unable to resolve symbol: add in this context
  \end{text}
\end{english}

Эта проблема решена в более продвинутых системах, о которых мы поговорим уже скоро.

Запуск REPL из Emacs кажется примитивным подходом, но на самом деле это не так. Вам доступны все возможности Clojure и Emacs одновременно. Для эффективной работы требуется не так уж много команд: выполнить s-выражение, регион или \code{def}-определение.

\def\urlbatsov{https://batsov.com/articles/2014/12/04/introducing-inf-clojure-a-better-basic-clojure-repl-for-emacs/}

\footurl{По словам Рича Хикки}{\urlbatsov}[batsov.com], автора Clojure, он работал над языком, используя Emacs и режим \code{inferior-lisp}. Это подтверждает: можно достичь значимых результатов малыми средствами. И хотя сегодня для Clojure созданы более мощные инструменты, полезно знать этот спартанский метод.

\subsubsection{Недостатки}

Способ, когда Emacs запускает внешний Лисп, не лишен недостатков. Перечислим основные из них.

Обмен данными между средами происходит по стандартным каналам операционной системы (stdin, stdout и stderr). Скорость их передачи ниже, чем по сети, что заметно на больших файлах.

Интерпретатор Лиспа, библиотеки и окружение должны быть установлены локально. Без специальных ухищрений нельзя подключиться к Лиспу, запущенному на удаленной машине.

Emacs и REPL передают друг другу плоский текст, из-за чего Emacs показывает результат без каких-либо улучшений. Это сделано намеренно, поскольку режим \code{inferior-lisp} рассчитан на любой REPL, будь то Common Lisp, Racket или Clojure.

Заметим, что Clojure поддерживает сетевой режим в REPL. Чтобы его включить, передайте следующий аргумент:

\begin{english}
  \begin{bash}
clojure -J-Dclojure.server.repl="{:port 5555 :accept clojure.core.server/repl}"
  \end{bash}
\end{english}

С ним REPL принимает ввод не только с клавиатуры, но и с порта 5555. Чтобы это проверить, подключимся к серверу через \code{telnet} и введем код на Clojure:

\begin{english}
  \begin{text}
> telnet 127.0.0.1 5555

Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
user=> (defn add [a b]
         (+ a b))
#'user/add
  \end{text}
\end{english}

В результате \code{telnet} работает как обычный REPL; разница в том, что данные передаются по сети. Подключитесь по \code{telnet} с другой машины, на которой нет Clojure. Введите сумму чисел, переменную и другой код. Перейдите к машине, где запущен REPL и убедитесь, что изменения, проделанные удаленно, вступили в силу.

Хотя сетевой режим снимает одну из проблем, озвученных выше, особой популярности он не получил. Данные по-прежнему передаются плоским текстом, что мешает эффективному обмену. Со временем появился проект nREPL, который закрывает этот и другие недостатки.

\subsection{Знакомство с nREPL}

[nrepl]: https://nrepl.org

В названии [nREPL][nrepl] буква n означает network, то есть сетевой REPL. Проект нацелен на то, чтобы обеспечить работу REPL по сети. В отличие от терминала, nREPL обладает более сложной архитектурой; перечислим ее главные свойства.

Сервер nREPL принимает команды по протоколу TCP. С одним проектом могут работать несколько клиентов. Сервер может быть запущен на удаленной машине или в изолированном окружении (Docker, VirtualBox).

Сообщения nREPL обладают структурой. Каждое из них содержит номер сеанса, тип операции, ее аргументы и текущее пространство имен. Сообщение легко дополнить или изменить при помощи промежуточных слоев~--- middleware.

nREPL опирается на транспорт сообщений. Транспортом называют соглашение о том, как писать и читать сообщения. По умолчанию nREPL предлагает транспорты Bencode, EDN и TTY. Создать новый транспорт означает расширить протокол библиотеки.

Обычный REPL работает синхронно: получив команду с клавиатуры, он не принимает текст до тех пор, пока не вычислит и напечатает результат. nREPL устроен асинхронно, когда команда выполняется в отдельном потоке. В ответ на одну операцию сервер может прислать несколько сообщений. По специальному полю клиент определяет, последнее это сообщение или нет.

Технически nREPL~--- библиотека, доступная в Clojars. У нее нет зависимостей, что упрощает развитие и поддержку. Несмотря на свою роль в экосистеме, nREPL остается отдельным, а не встроенным модулем. С таким подходом он не зависит от цикла версий Clojure.

\subsubsection{Запуск nREPL}

Чтобы запустить nREPL вместо обычного REPL, добавьте библиотеку в проект. Если вы пользуетесь lein, откройте файл \code{project.clj} и расширьте зависимости:

\begin{english}
  \begin{clojure}
{...
 :dependencies
 [... [nrepl/nrepl "0.9.0"]]}
  \end{clojure}
\end{english}

Сохраните файл и выполните \code{lein repl}. Утилита \code{lein} устроена так, что если nREPL найден в зависимостях, предпочтение отдается ему. Убедиться, что вы запустили именно nREPL можно по фразе "nREPL server started", которая появится в терминале:

\begin{english}
  \begin{text}
> lein repl

nREPL server started on port 52002 on host 127.0.0.1 - nrepl://127.0.0.1:52002
REPL-y 0.4.4, nREPL 0.8.3
Clojure 1.10.1
OpenJDK 64-Bit Server VM 11.0.12+6-jvmci-21.2-b08
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=>
  \end{text}
\end{english}

В случае с \code{deps.edn} укажите профиль \code{:nrepl}:

\begin{english}
  \begin{clojure}
{:aliases
 {:nrepl
  {:extra-deps
   {nrepl/nrepl {:mvn/version "0.9.0"}}
   :main-opts ["-m" "nrepl.cmdline" "-i"]}}}
  \end{clojure}
\end{english}

Ключ \code{-i} в \code{:main-opts} означает интерактивный режим, то есть с вводом с клавиатуры. Без него nREPL работает в "безголовом" (headless) режиме, слушая только сетевой порт. Запустите утилиту \code{clj} с профилем \code{:nrepl}:

\begin{english}
  \begin{text}
> clj -M:nrepl

nREPL server started on port 55113 on host localhost - nrepl://localhost:55113
nREPL 0.9.0
Clojure 1.11.1
OpenJDK 64-Bit Server VM 11.0.12+6-jvmci-21.2-b08
Interrupt: Control+C
Exit:      Control+D or (exit) or (quit)
user=>
  \end{text}
\end{english}

На первый взгляд nREPL не отличается от обычного REPL. Он по-прежнему принимает ввод с клавиатуры, вычисляет и печатает результат. Истинная мощь nREPL проявляется в работе из редактора, и уже скоро мы дойдем до этого раздела.

После запуска nREPL вы обнаружите файл \code{.nrepl-port} в папке проекта. Если не указать порт явно, nREPL случайно выберет свободный порт для подключения. Дополнительно он запишет порт в файл, чтобы редактор прочитал его, не запрашивая у пользователя.

Выше мы указали nREPL в главных зависимостях проекта~--- векторе \code{:dependencies} формы \code{defproject}. Поскольку nREPL относится к разработке, поместим его в профиль \code{:dev}:

\begin{english}
  \begin{clojure}
:profiles
{:dev {:dependencies [[nrepl/nrepl "0.9.0"]]}
  \end{clojure}
\end{english}

В этом случае nREPL доступен при запуске \code{lein repl}, потому что профиль \code{:dev} активен по умолчанию. При сборке проекта его не окажется в зависимостях. Это легко проверить, вызвав команду \code{deps :tree} с профилем \code{uberjar}:

\begin{english}
  \begin{bash}
> lein with-profile uberjar deps :tree | grep nrepl
;; nothing
  \end{bash}
\end{english}

Быстро окажется, что nREPL нужен во всех проектах.Чтобы не добавлять его в каждый \code{project.clj}, прибегают к пользовательскому профилю. Создайте файл \code{~/.lein/profiles.clj} со словарем внутри. В поле \code{:user} укажите словарь с зависимостями. Утилита \code{lein} объединит его с полем \code{:profiles} при запуске.

\begin{english}
  \begin{clojure}
{:user {:dependencies [[nrepl/nrepl "0.9.0"]]}}
  \end{clojure}
\end{english}

Теперь по команде \code{lein repl} запусится nREPL, неважно указан ли он в \code{project.clj} или нет. Это полезно, когда в проекте несколько человек и их редакторы требуют разные версии nREPL (например, Cider и Calva). Каждый укажет свою версию в файле \code{~/.lein/profiles.clj}, избежав конфликта.

Если вы используете Clojure CLI, похожий файл называется \code{~/.clojure/deps.edn}. При запуске \code{clj} или \code{clojure} он дополняет текущий файл \code{deps.edn}. Поместите в него профиль \code{:nrepl}, созданный выше. Чтобы подчеркнуть, что это локальный профиль, добавьте ему пространство \code{local}:

\begin{english}
  \begin{clojure}
{:aliases
 {:local/nrepl
  {:extra-deps {nrepl/nrepl {:mvn/version "0.9.0"}}
   :main-opts ["-m" "nrepl.cmdline"]}}}
  \end{clojure}
\end{english}

Включите проект командой:

\begin{english}
  \begin{bash}
> clj -M:local/nrepl
  \end{bash}
\end{english}

Поведение nREPL меняют с помощью параметров. В \code{lein} для этого служит ключ \code{:repl-options}. Перечислим опции, которые понадобятся чаще других.

- \code{:port}~--- сетевой порт, по которому nREPL принимает сообщения от клиентов. Если не задан, будет выбран случайно. В редких случаях порт указывают явно, например когда nREPL запущен в Docker или на удаленной машине~--- эти случаи мы рассмотрим в конце главы.

- \code{:prompt}~--- функция приглашения. Принимает один аргумент~--- пространство имен~--- и по умолчанию выводит его имя.

- \code{:init-ns}~--- символ пространства, которое nREPL загрузит при запуске. В разработке используют \code{dev}, \code{user} или \code{sandbox}~--- своего рода песочницу с запуском системы, прогоном миграций другими служебными функциями.

Пример с нестандартными параметрами:

\begin{english}
  \begin{clojure}
{...
  :repl-options {:port 9911
                 :init-ns dev
                 :prompt (fn [current-ns]
                           (format "[%s] >> " current-ns))}}
  \end{clojure}
\end{english}

Вот что получим при запуске \code{lein repl}:

\begin{english}
  \begin{bash}
[dev] >> (+ 1 2 3)
6
  \end{bash}
\end{english}


\def\urlnrepl{https://github.com/technomancy/leiningen/blob/master/sample.project.clj\#L368}
\def\urlnreplopt{https://nrepl.org/nrepl/usage/server.html}

Остальные параметры вы найдете в документации \footurl{Leiningen}{\urlnrepl}[Sample project.clj] и \footurl{nREPL}{\urlnreplopt}[nREPL server].

\subsubsection{Внутреннее устройство}

\def\urlring{https://github.com/ring-clojure/ring}

Дизайн nREPL включает три важные части: обработчик запроса, middleware и транспорт. Коротко опишем каждую из них.

Обработчик (\code{handler})~--- это функция одного аргумента, которая принимает словарь сообщения. В nREPL сообщения структурированы, то есть разбиты на поля. По полю \code{:op} (operation) функция понимает, что от нее требуется, и выполняет действие. Вот как выглядит команда вычислить код:

\begin{english}
  \begin{clojure}
{:op "eval" :code "(+ 1 2 3)"}
  \end{clojure}
\end{english}

и ответ на нее:

\begin{english}
  \begin{clojure}
{:id "..." :session "..." :value 6}
  \end{clojure}
\end{english}

Мы привели сообщения в виде EDN для читаемости; в транспорте они выглядят иначе. На месте многоточий должны быть длинные идентификаторы, которые мы сократили за ненадобностью.

Логично ожидать, что обработчик возвращает словарь сообщения подобно библиотеке \footurl{Ring}{\urlring}[Ring]. Это приводит к ограничению "один запрос~--- один ответ", что нарушает сказанное выше: на одно входящее сообщение может быть несколько исходящих.

Сообщение, переданное обработчику, содержит поле \code{:transport} с текущим объектом транспорта. Чтобы отправить ответ клиенту, обработчик вызывает метод \code{send} транспорта со словарем ответа:

\begin{english}
  \begin{clojure}
(defn handler [{:as message
                :keys [transport op code]}]
  (let [value (eval ...)]
    (t/send transport {:value value})))
  \end{clojure}
\end{english}

Простейший случай, когда ответов несколько~--- вычисление двух форм за раз. Выделим в редакторе две формы и выполним \code{M-x cider-eval-region}:

\begin{english}
  \begin{clojure}
(+ 1 2 3)
(+ 1 2 3 4)
  \end{clojure}
\end{english}

На сервер уйдет сообщение:

\begin{english}
  \begin{clojure}
{:id "..." :op "eval" :code "(+ 1 2 3)(+ 1 2 3 4)"}
  \end{clojure}
\end{english}

В ответ получим три сообщения: по одному на каждую форму плюс завершающее, которое означает, что задача окончена. У всех трех сообщений одинаковый ID, чтобы понять, к какому запросу они относятся.

\begin{english}
  \begin{clojure}
{:id "..." :session "..." :value "6"}
{:id "..." :session "..." :value "10"}
{:id "..." :session "..." :status ["done"]}
  \end{clojure}
\end{english}

Если бы обработчик был чистой функцией, он должен был вернуть список ответов. Но список нельзя отправить клиенту, пока не вычислен последний элемент. В этом случае мы вынудим клиента ждать до тех пор, пока не будут готовы все ответы. Это неоптимально: гораздо лучше отправлять сообщения по мере готовности.

\subsubsection{Транспорт}

В терминах nREPL транспорт~--- это соглашение о том, какой канал связи использовать и как кодировать и декодировать сообщения. Чтобы клиент и сервер понимали друг друга, они должны использовать одинаковый транспорт. На уровне кода это объект, реализующий протокол \code{nrepl.transport.Transport}. В него входят методы \code{recv} и \code{send}, которые отвечают за прием и отправку сообщений.

nREPL предлагает три транспорта: Bencode, EDN и TTY. Мы перечислили их по убыванию важности. Большинство клиентов используют Bencode, поэтому он задан по умолчанию. Bencode опирается на одноименный формат данных, который мы рассмотрим чуть позже.

Транспорт EDN передает данные в формате, принятом в Clojure. Его используют в ClojureScript, поскольку там возможностей Bencode не хватает, чтобы покрыть все типы данных. Транспорт TTY предназначен для подключения из терминала. Это наиболее скудный формат, которым пользуются в крайних случаях.

\subsubsection{Middleware}

По аналогии с Ring, middleware~--- это прослойка между запросом и обработчиком. Задача middleware в том, чтобы расширить логику сервера, не меняя обработчик.

[classpath]: https://docs.oracle.com/javase/tutorial/essential/environment/paths.html

Предположим, мы бы хотели, чтобы команда "classpath" вернула текущий список [путей JVM][classpath]. Для этого напишем middleware с логикой: если поле \code{:op} сообщения равно "classpath", отправить сообщение со списком строк. В противном случае вызвать обработчик по умолчанию:

\begin{english}
  \begin{clojure}
(defn wrap-classpath [handler]
  (fn [{:as msg :keys [op transport]}]
    (if (= "classpath" op)
      (let [paths (get-classpath ...)]
        (t/send transport {... :classpath paths}))
      (handler msg))))
  \end{clojure}
\end{english}

Как и в Ring, цепочка middleware образует стек. В примере выше переменная \code{handler} не обязательно конечный обработчик nREPL. Скорей всего, он многократно обернут другими middleware выше по стеку.

[cider-middleware]: https://github.com/clojure-emacs/cider-nrepl/tree/master/src/cider/nrepl/middleware

Проект Cider, который мы скоро рассмотрим, предлагает [множество подобных middleware][cider-middleware]. Вместе они радикально расширяют возможности nREPL.

\subsection{Подключение из Clojure}

Опробуем nREPL на практике: подключимся к серверу и выполним несколько выражений. Пока что мы не знаем, как подключиться из редактора, поэтому воспользуемся клиентом на Clojure. У нас будет два сеанса nREPL: первый в роли сервера, второй в качестве клиента.

Запустите оба сеанса командой \code{lein repl} или \code{clj -M:nrepl}. Напомним, библиотека \code{nrepl/nrepl} должна быть указана в профиле по умолчанию (файлы \code{~/.lein/profiles.clj} и \code{~/.clojure/deps.edn}). Запомните порт первого сеанса (в случае автора это 50411). Его можно увидеть в терминале при nREPL или в файле \code{.nrepl-port} той директории, где запущен сеанс.

Во втором сеансе выполните:

\begin{english}
  \begin{clojure}
(require '[nrepl.core :as nrepl])

(def conn (nrepl/connect :port 50411))
(def client (nrepl/client conn 1000))
  \end{clojure}
\end{english}

Функция \code{connect} открывает соединение с сервером, на базе которого работает клиент (в рамках одного соединения их может быть несколько). Клиент отвечает за отправку и получение сообщений. Код выше подключит вас к удаленному nREPL. Для начала сложим несколько чисел. Отправьте сообщение с операцией \code{eval}:

\begin{english}
  \begin{clojure}
(nrepl/message client {:op "eval" :code "(+ 1 2 3)"})
  \end{clojure}
\end{english}

Получим два ответа: первый с результатом, второй с признаком окончания:

\begin{english}
  \begin{clojure}
({:id "1ac6cbc4-74d4-4b3a-bf3f-97dcf7ca07c2"
  :ns "my-repl"
  :session "fec9d5a3-3c22-4640-b089-c1cecc041068"
  :value "6"}
 {:id "1ac6cbc4-74d4-4b3a-bf3f-97dcf7ca07c2"
  :session "fec9d5a3-3c22-4640-b089-c1cecc041068"
  :status ["done"]})
  \end{clojure}
\end{english}

Проверим, что случится, если возникнет исключение. Поделим число на ноль:

\begin{english}
  \begin{clojure}
=> (nrepl/message client {:op "eval" :code "(/ 0 0)"})
  \end{clojure}
\end{english}

Ответ:

\begin{english}
  \begin{clojure}
({:err "Execution error (ArithmeticException) at my-repl/eval5984 (form-init9833672407535844907.clj:1).\nDivide by zero\n"
  :id "a8444b3c-7b54-4e04-9b48-04b8bda170f4"
  :session "17d02cb6-45ff-464c-a01c-c87da89cdfa7"}
 {:ex "class java.lang.ArithmeticException"
  :id "a8444b3c-7b54-4e04-9b48-04b8bda170f4"
  :root-ex "class java.lang.ArithmeticException"
  :session "17d02cb6-45ff-464c-a01c-c87da89cdfa7"
  :status ["eval-error"]}
 {:id "a8444b3c-7b54-4e04-9b48-04b8bda170f4"
  :session "17d02cb6-45ff-464c-a01c-c87da89cdfa7" :status ["done"]})
  \end{clojure}
\end{english}

Получили краткие сведения об исключении: класс, текст и последний элемент стектрейса. Сбором этих данных занимается функция, которую можно задать параметром \code{:nrepl.middleware.caught/caught}. Функция должна быть объявлена на сервере, и в сообщении передают путь к ней:

\begin{english}
  \begin{clojure}
{:nrepl.middleware.caught/caught 'project.util/caught-func}
  \end{clojure}
\end{english}

Убедимся, что изменения, переданные клиентом, вступили в силу. Объявите функцию \code{add}:

\begin{english}
  \begin{clojure}
=> (nrepl/message client {:op "eval" :code "
(defn add [a b]
  (+ a b))
"})
  \end{clojure}
\end{english}

Перейдите в первый терминал с сервером. Выполните \code{(add 1 2)}~--- функция сработает без ошибок.

Другая полезная команда называется \code{lookup}. Она принимает символ и возвращает данные о переменной, связанной с ним. Данные содержат путь к исходному файлу, позицию в нем, документацию и сигнатуру. На \code{lookup} завязана поддержка редактора: переход к определению, вывод документации, всплывающее окно с сигнатурой вызова по мере набора. Запросим информацию о символе \code{+}:

\begin{english}
  \begin{clojure}
=> (nrepl/message client {:op "lookup" :sym "+"})
  \end{clojure}
\end{english}

Символ может быть как с пространством, так и без него. Во втором случае поиск происходит в текущем пространстве имен. В ответ получим все необходимое для перехода к определению (файл, строка), вызова (список аргументов) и документации (поле \code{:doc}):

\begin{english}
  \begin{clojure}
({:id "e66092b8-c6aa-49a9-9cff-cc3557e421c6",
  :info {:protocol "",
         :added "1.2",
         :ns "clojure.core",
         :name "+",
         :file "jar:file:/Users/ivan/.m2/repository/org/clojure/clojure/1.10.0/clojure-1.10.0.jar!/clojure/core.clj",
         :arglists-str "([] [x] [x y] [x y & more])",
         :column 1,
         :line 984,
         :arglists "([] [x] [x y] [x y & more])",
         :doc "Returns the sum of nums. (+) returns 0. Does not auto-promote\n  longs, will throw on overflow. See also: +'"},
  :session "63a4ba3f-6a19-4597-919d-3136ebbfa1cb",
  :status ["done"]})
  \end{clojure}
\end{english}

Команда \code{completions} возвращает список определений по префиксу. Это полезно, когда пользователь ввел часть текста и ожидает выпадающее окно с вариантами. Например, функции семейства \code{ex-...} служат для работы с исключениями. Проверим, что найдет сервер по префиксу \code{ex-}:

\begin{english}
  \begin{clojure}
(nrepl/message client {:op "completions" :prefix "ex-"})
  \end{clojure}
\end{english}

Получили четыре функции для работы с исключениями:

\begin{english}
  \begin{clojure}
({:completions
  [{:candidate "ex-cause", :type "function"}
   {:candidate "ex-data", :type "function"}
   {:candidate "ex-info", :type "function"}
   {:candidate "ex-message", :type "function"}],
  :id "e6f3b77b-5689-484e-8743-76f9682caaa7",
  :session "f15bb73c-e3f9-49c8-8aa5-0ebc592d038d",
  :status ["done"]})
  \end{clojure}
\end{english}

nREPL поддерживает другие полезные команды, например \code{:load-file} для загрузки кода из файла. Сообщение передает не путь к файлу на сервере, а его содержимое и метаданные. Создайте файл \code{src/sample.clj} с кодом:

\begin{english}
  \begin{clojure}
(ns sample)

(defn multiply [a b]
  (* a b))
  \end{clojure}
\end{english}

После чего отправьте его на сервер (функция \code{slurp} читает файл в строку):

\begin{english}
  \begin{clojure}
(nrepl/message client {:op "load-file"
                       :file (slurp "src/sample.clj")})
  \end{clojure}
\end{english}

Сервер скомпилирует код из файла, и в результате появится пространство имен \code{sample}. Перейдите в терминал с сервером и опробуйте новую функцию:

\begin{english}
  \begin{clojure}
=> (sample/multiply 3 4)
12
  \end{clojure}
\end{english}

[nrepl-ops]: https://nrepl.org/nrepl/ops.html

Мы не будем перечислять все команды nREPL. Любопытный читатель найдет их в [документации][nrepl-ops] проекта. Завершим раздел командой \code{close}. Она принимает строго один параметр~--- номер сессии~--- и освобождает ресурсы, связанные с ней:

\begin{english}
  \begin{clojure}
(nrepl/message client
               {:op "close"
                :session "97ec6c4b-28ee-4402-87e3-43f3275a7430"})
  \end{clojure}
\end{english}

\subsubsection{Коротко о Bencode}

Исследуем трафик, которым обмениваются клиент и сервер nREPL. Пока открыты оба сеанса, запустите команду \code{tcpdump} для записи трафика в файл. В системах Linux и MacOS утилита доступна по умолчанию. \code{Tcpdump} требует прав суперпользователя, поэтому запускается с \code{sudo}:

\begin{english}
  \begin{clojure}
sudo tcpdump port 50411 -i lo0 -w nrepl.log
  \end{clojure}
\end{english}

[wireshark]: https://www.wireshark.org

Число 50411~--- это порт сервера nREPL, а \code{nrepl.log}~--- выходной файл с TCP-пакетами. После запуска \code{tcpdump} перейдите в REPL и выполните несколько действий. Завершите \code{tcpdump} нажатием \code{Ctrl+C} и откройте файл в программе [Wireshark][wireshark]. Это бесплатное приложение для анализа сетевого трафика. Содержимое файла в нем выглядит примерно так (переносы строк отделяют запрос и ответ):

\begin{english}
  \begin{text}
d4:code9:(+ 1 2 3)2:id36:c88f2dcb-d502-4c90-9529-2dd843bc56d02:op4:evale
d2:id36:c88f2dcb-d502-4c90-9529-2dd843bc56d02:ns7:my-repl7:session36:1fdd9575-881e-4be1-80ca-dd8e64bdff185:value1:6e
  \end{text}
\end{english}

[bencode]: https://en.wikipedia.org/wiki/Bencode

Каждая строка~--- структура данных в формате [Bencode][bencode]. Форма создали как часть протокола BitTorrent, и позже его переняли другие системы, в том числе nREPL. Bencode передает числа, строки, словари и списки. Несмотря на меньший по сравнению с JSON набор типов, он обладает решительным преимуществом~--- простотой.

Описание формата занимает меньше страницы. Числа записываются в виде \code{i<число>e}, например \code{i2020e} означает \code{2020}. Цепочка байтов~--- в виде \code{<длина>:<содержимое>}; строка \code{"hello"} становится \code{"5:hello"}. Выражение \code{l<...>e} означает список. Значения, найденные между \code{l} и \code{e}, станут его содержимым. В строке \code{"l5:helloi42ee"} записан список с элементами \code{"hello"} и \code{42}. Форма \code{d<...>e} служит для словаря. От списка он отличается тем, что перед каждым значением идет строка с именем ключа. Сообщение:

\begin{english}
  \begin{text}
"d5:title4:19844:yeari1948ee"
  \end{text}
\end{english}

означает словарь

\begin{english}
  \begin{clojure}
{:title "1984" :year 1948}
  \end{clojure}
\end{english}

Формат допускает вложенность одних коллекций в другие, например список словарей или словарь, значения которого списки. Упакуем в Bencode следующие данные:

\begin{english}
  \begin{clojure}
{:title "1984"
 :year 1948
 :tags ["novel" "fiction" "dystopia"]
 :author {:fname "George" :lname "Orwell"}}
  \end{clojure}
\end{english}

Результат:

\begin{english}
  \begin{clojure}
"d6:authord5:fname6:George5:lname6:Orwelle4:tagsl5:novel7:fiction8:dystopiae5:title4:19844:yeari1948ee"
  \end{clojure}
\end{english}

Всё, вы знаете Bencode!

Этих правил достаточно для передачи сообщений в nREPL. Конечно, при кодировании теряется часть семантики: тип \code{Keyword} становится строкой, но обратной операции не предусмотрено~--- получив строку, нельзя определить, была ли она раньше кейвордом. По аналогии вектор, список и множество становятся в Bencode списком, и узнать исходный тип коллекции невозможно. Однако чаще всего этого и не требуется.

Почему бы не использовать более продвинутый формат, например JSON? Причина в том, что, в отличие от него, Bencode экстремально прост: код упаковки и чтения данных занимает около ста строк. Это важно для встроенных в редактор языков, которые не всегда поддерживают JSON. Написание для них JSON-парсера потребует усилилий.

Транспорт Bencode назначен в nREPL по умолчанию. Когда nREPL работает с ClojureScript, используется EDN. Сообщения в ClojureScript требуют больше типов данных, и возможностей Bencode уже недостаточно.

Ради эксперимента укажите серверу и клиенту транспорт EDN. Для сервера это делается ключом \code{:repl-options}:

\begin{english}
  \begin{clojure}
:repl-options {...
               :transport nrepl.transport/edn}
  \end{clojure}
\end{english}

Если выполнить \code{lein repl}, вы увидите в консоли фразу \code{nrepl+edn://127.0.0.1:<port>}, при этом ввод с клавиатуры будет недоступен. Чтобы подключиться к серверу, измените параметры клиента:

\begin{english}
  \begin{clojure}
(require '[nrepl.transport :as transport])

(def conn (nrepl/connect
           :port 61093
           :transport-fn transport/edn))
  \end{clojure}
\end{english}

Запишите трафик в файл и исследуйте в Wireshark. Вы увидите привычные данные в формате Clojure:

\begin{english}
  \begin{clojure}
{:op "eval"
 :code "(+ 1 2 3)"
 :id "f4fcb617-74a7-4be8-978a-6f788787d360"}

{:id "f4fcb617-74a7-4be8-978a-6f788787d360"
 :session "29e04d1a-06b2-463b-8b5b-878424958780"
 :ns "my-repl"
 :value "6"}
  \end{clojure}
\end{english}

[nrepl-bencode]: https://github.com/nrepl/bencode

Bencode для Clojure доступен в двух вариантах: как часть nREPL и в виде отдельной библиотеки [nrepl/bencode][nrepl-bencode]. Последняя является копией модуля из nREPL и обновляется параллельно с ним.

\subsection{Клиенты nREPL для редакторов}

Мы провели достаточно опытов, чтобы понять, как устроен клиент для nREPL. Это код, который отправляет сообщения по особому протоколу. Клиенты пишут на разных языках, в том числе встроенных в редактор. Так получаются плагины~--- программные модули, которые служат прослойкой между пользователем и nREPL. По нажатию клавиш плагин посылает сообщение и выводит результат в отдельной области или рядом с кодом.

На GitHub вы найдете клиенты nREPL, написанные на Clojure, Emacs Lisp, Java, Python, Lua, JavaScript, TypeScript, VimScript и других языках. Это многообразие объясняется тем, каждый редактор использует свой язык для внутренних нужд. Например, плагины Emacs пишут на старом диалекте Elisp; редактор VS Code поддерживает JavaScript и TypeScript; модули к продуктам JetBrains создают на Java и так далее.

В этом разделе мы не будем перебирать все клиенты. Наоборот, остановим выбор на модуле Cider для редактора Emacs. В его пользу говорят следующие факты.

[cider-010]: https://github.com/clojure-emacs/cider/tree/v0.1.0

**Долгая история.** Первый коммит в репозиторий Cider [сделан в 2012 году][cider-010]. На момент написания книги проекту полных десять лет. Cider давно вышел из стадии любительского решения: у него обширное сообщество и документация.

[survey]: https://clojure.org/news/2022/06/02/state-of-clojure-2022

**Популярность.** Согласно ежегодному опросу [Clojure Survey][survey], связка Cider/Emacs держит первое место по популярности у разработчиков. Доля голосов в пользу Cider превышает 40%, хоть и плавно снижается из-за развития других проектов.

**Компетенция в сообществе.** Исторически сложилось, что Emacs в большей степени подходит для разработки на Лиспе, чем другие редакторы. За долгие годы его адаптировали под разные диалекты~--- Common Lisp, Racket, Scheme и другие. Cider опирается на этот опыт: большая часть его функций~--- повтор удачных решений для других Лиспов.

Если вы пользуетесь другим редактором, не спешите пропускать раздел. Возможно, вы откроете подходы, о которых не знали раньше. Также вы заочно познакомитесь с Emacs: это сложный редактор, но он стоит потраченных сил.

\subsection{Emacs и Cider}

[cider]: https://github.com/clojure-emacs/cider
[cider-nrepl]: https://github.com/clojure-emacs/cider-nrepl

Проект Cider состоит из двух частей. Первая~--- одноименный [модуль для Emacs][cider], чтобы подключаться к nREPL из редактора. Вторая часть~--- библиотека на Clojure под названием [cider-nrepl][cider-nrepl]. Это набор middleware, которые дополняют nREPL: добавляют запуск тестов, отладку, переходы по коду, профилирование и многое другое.

Взаимодействие Emacs и сервера выглядит так:

%% chart
%% ┌────────────────────────────────────────────────────────────────┐
%% │                                                                │
%% │  ┌─────────────────┐   ┌────────────────────────────────────┐  │
%% │  │Client           │   │Server                              │  │
%% │  │                 │   │                                    │  │
%% │  │  ┌───────────┐  │   │  ┌───────────┐     ┌───────────┐   │  │
%% │  │  │           │  │   │  │   nREPL   │     │           │   │  │
%% │  │  │   Emacs   │  │   │  │  server   │◀═══▶│  Clojure  │   │  │
%% │  │  │           │  │   │  │           │     │           │   │  │
%% │  │  └───────────┘  │   │  └───────────┘     └───────────┘   │  │
%% │  │        ▲        │   │        ▲                 ▲         │  │
%% │  │        ║        │   │        ║                 ║         │  │
%% │  │        ║        │   │        ║                 ║         │  │
%% │  │        ▼        │   │        ▼                 ▼         │  │
%% │  │  ┌───────────┐  │   │  ┌───────────┐     ┌───────────┐   │  │
%% │  │  │           │  │   │  │Cider/nrepl│     │           │   │  │
%% │  │  │   CIDER   │◀═╬═══╬═▶│middleware │     │    JVM    │   │  │
%% │  │  │           │  │   │  │           │     │           │   │  │
%% │  │  └───────────┘  │   │  └───────────┘     └───────────┘   │  │
%% │  │                 │   │                                    │  │
%% │  │                 │   │                                    │  │
%% │  │                 │   │                                    │  │
%% │  └─────────────────┘   └────────────────────────────────────┘  │
%% │                                                                │
%% └────────────────────────────────────────────────────────────────┘

Cider-nrepl работает на сервере и не зависит от языка, на котором написан клиент. На него опирается не только Emacs, но и плагины для Vim и других редакторов.

Есть несколько способов начать работу над проектом в Emacs. **Первый**~--- поручить все шаги Cider. Откройте любой файл проекта и выполните:

\begin{english}
  \begin{text}
M-x cider-jack-in
  \end{text}
\end{english}

Произойдет следующее: Emacs начнет искать файл \code{project.clj} в текущей папке, а затем все выше и выше. Если он найден, Emacs запустит процесс \code{lein repl}. В параметрах окажутся библиотека \code{nrepl} и служебные плагины. Приведем итоговую команду в сокращении:

\begin{english}
  \begin{bash}
> /usr/local/bin/lein
  update-in :dependencies conj [nrepl/nrepl "0.9.0"] \
  update-in :plugins conj [cider/cider-nrepl "0.28.3"] \
  update-in :plugins conj [mx.cider/enrich-classpath "1.9.0"] \
  update-in :middleware conj cider.enrich-classpath/middleware \
  repl :headless :host localhost
  \end{bash}
\end{english}

Cider различает системы управления проектом: lein, Clojure CLI и Boot. Для каждой из них он выполнит разные команды. Если найдены файлы нескольких утилит, Emacs спросит, что именно запустить.

После запуска nREPL редактор подключится к нему. Откроется буфер \code{*cider-repl <project>*} для ввода выражений. Еще один буфер \code{*nrepl-server <project>*} служит для вывода процесса \code{lein repl}.

Возможно, первый запуск \code{cider-jack-in} займет время. Его бóльшая часть уйдет на загрузку зависимостей.

При **втором способе** подключения шаги проделывают вручную: запускают nREPL в терминале и подключаются из редактора. Откройте глобальный профиль lein в файле \code{~/.lein/profiles.clj}. В вектор \code{:user} \arr \code{:plugins} добавьте плагин \code{cider/cider-nrepl}. Плагин зависит от модуля \code{nrepl/nrepl}, поэтому последний указывать не нужно~--- он загрузится как транзитивная зависимость.

\begin{english}
  \begin{clojure}
{:user
 {:plugins
  [[cider/cider-nrepl "0.28.3"]]}}
  \end{clojure}
\end{english}

Запустите в терминале процесс \code{lein repl}. Перейдите в Emacs и выполните \code{M-x cider-connect}. Редактор запросит у вас хост и порт сервера. В нашем случае хост будет \code{localhost} или \code{127.0.0.1}. Вводить порт вручную необязательно: Cider найдет его в файле \code{.nrep-port}. Для этого нажмите в минибуфере TAB~--- появится список с вариантами. Emacs покажет не только номера портов, но и названия проектов, с которыми они связаны.

\begin{english}
  \begin{text}
Click on a completion to select it.
In this buffer, type RET to select the completion near point.

Possible completions are:
- etaoin:54446
- pact:64187
  \end{text}
\end{english}

После соединения вы окажетесь в буфере \code{*cider-repl <project>*} с приглашением. Буфера \code{*nrepl-server <project>*} не будет, поскольку сервер запущен вне Emacs и между ними нет связи по каналам stdin/out.

Для Clojure CLI проект выглядит как в примере ниже. Запустите его командой \code{clojure -M:cider}. По аналогии с \code{lein}, поместите профиль \code{:cider} в файл \code{~/.clojure/deps.edn}, чтобы применить его к любому проекту.

\begin{english}
  \begin{clojure}
{:aliases
 {:cider
  {:extra-deps
   {cider/cider-nrepl {:mvn/version "0.25.9"}}
   :main-opts
   ["-m" "nrepl.cmdline"
    "--bind" "localhost"
    "--middleware" "[cider.nrepl/cider-middleware]"]}}}
  \end{clojure}
\end{english}

Возможно, у читателя возникнет вопрос: зачем нужно ручное подключение, если доступно автоматическое? Пока мы не ушли дальше, объясним разницу между подходами.

В автоматическом режиме (\code{cider-jack-in}) процесс \code{lein repl} запускается силами Emacs. Если редактор "упадет", завершатся открытые им процессы. Те, кто работает с Clojure постоянно, держат несколько запущенных проектов одновременно. Восстанавливать их после перезапуска редактора утомительно.

Когда сеансы запущены вручную вне Emacs, сбой в редакторе не скажется на них. Более того~--- они сохранят изменения, которые вы внесли до этого. Достаточно включить редактор и подключится к запущенным проектам.

В редких случаях к проекту можно подключиться только в удаленном режиме. Например, если сервер nREPL запущен на другой машине или в виртуальном окружении (Docker, VirtualBox). Эти сценарии мы рассмотрим ближе к концу главы.

\subsubsection{Первые шаги}

Итак, если подключение состоялось, откроется буфер \code{*cider-repl*} приглашением. Введите что-нибудь вроде \code{(+ 1 2)}, чтобы убедиться в его работе. Наверху буфера находится краткая справка. Если вы только знакомитесь с Cider, прочитайте ее. Опытные разработчики отключают справку, назначив \code{nil} специальной переменной Emacs:

\begin{english}
  \begin{lisp}
(setq cider-repl-display-help-banner nil)
  \end{lisp}
\end{english}

Дальнейшие шаги зависят от конфигурации проекта. Если не задано пространство по умолчанию (параметры \code{:main} или \code{:repl-options} \arr \code{:init-ns}), ничего не будет загружено, и вы окажетесь в пространстве \code{user}. Загрузить код в nREPL можно двумя способами: вручную и автоматически.

В первом случае откройте файл с главным модулем. Как правило, это пространства \code{<project>.core} или \code{<project>.main}. Выполните команду \code{M-x cider-load-buffer}. Ей пользуются часто, поэтому команде назначено сочетание клавиш \code{C-c C-k}. Пространство имен, включая его зависимости, будут загружены на сервере.

В боевых проектах создают модуль \code{dev} (он же \code{local}, \code{sandbox}), доступный только в разработке (профиль \code{uberjar} его игнорирует). Модуль указывают в опциях nREPL, чтобы загрузить его при запуске сервера. В свою очередь \code{dev} зависит от других модулей, и они загружаются транзитивно.

Кроме импортов, в \code{dev} размещают служебные функции, например:

- прогон миграций;
- запуск системы компонентов (веб-сервер, база, кэш и другие) и ее остановка;
- вызов различных API.

Вот как выглядят настройки REPL с модулем \code{dev} по умолчанию:

\begin{english}
  \begin{clojure}
{:profiles
 {:dev
  {:repl-options {:init-ns dev}}}}
  \end{clojure}
\end{english}

При ручной загрузке может случиться так, что какие-то модули пропущены. Особенно досадно, когда не загружен модуль, расширяющий протокол или мультиметод. Код скомпилируется, но при запуске получим исключение, что нет нужной реализации.

Чтобы этого избежать, Cider предлагает автоматическую загрузку командой \code{M-x cider-ns-refresh}. Она перебирает пути classpath и принудительно загружает все файлы Clojure. Как только вы подключились к nREPL, выполните эту команду, и проект готов к работе.

\subsubsection{Выполнение кода}

После загрузки кода его можно выполнить. Перейдите в буфер \code{*cider-repl*} и введите вызов любой функции:

\begin{english}
  \begin{clojure}
(my.project.util/some-func {:message "hello"})
  \end{clojure}
\end{english}

Нажмите Enter. На сервер уйдет сообщение с этим кодом. Там он выполнится, и ниже появится результат.

Чтобы быстро перейти в буфер REPL, связанный с текущим проектом, наберите команду \code{M-x cider-switch-to-repl-buffer} и задайте ей комбинацию клавиш.

Частый переход в буфер \code{*cider-repl*} и набор кода в нем неудобен. Гораздо лучше выполнить код из файла, где вы его набираете. Команда \code{M-x cider-eval-last-sexp}, назначенная на \code{C-x C-e}, выполнит последнее перед курсором S-выражение. Предположим, вы написали следующий код:

\begin{english}
  \begin{clojure}
(let [name "John"
      email "test@test.com"]
  (format "%s <%s>" name email))
  \end{clojure}
\end{english}

Поместите курсор за последнюю скобку и выполните \code{C-x C-e}. Справа от формы появится результат:

\begin{english}
  \begin{clojure}
(let [name "John"
      email "test@test.com"]
  (format "%s <%s>" name email)) => "John <test@test.com>"
  \end{clojure}
\end{english}

По аналогии с \code{inferior-mode}, S-выражение может быть где угодно: не только на верхнем уровне модуля, но и внутри другой формы. В выражении:

\begin{english}
  \begin{clojure}
(let [id (java.util.UUID/randomUUID) |
      name "John"]
  {:id id
   :name name})
  \end{clojure}
\end{english}

подведите курсор на место вертикальной черты и выполните форму \code{(java.util...)}. Вы получите случайный идентификатор, экземпляр класса \code{UUID}.

Команды \code{cider-eval-region}, \code{cider-eval-buffer} и другие выполняют код из разных областей. Как следует из названий, \code{-region} выполняет выделенный код, в котором может быть несколько форм. Команда \code{-buffer} охватывает буфер цели.

Команда \code{cider-eval-defun-at-point} выполняет определение~--- формы \code{def}, \code{defn}, \code{defmacro} и другие. Особенность в том, курсор может быть в любом месте формы, а не обязательно на конце. В примере ниже установите курсор на место черты и выполните команду. TODO % Результатом станет переменная \code{#'user-description} (объект \code{Var}).

\begin{english}
  \begin{clojure}
(def user-description
  (let [name "John" |
        email "test@test.com"]
    (format "%s <%s>" name email)))

=> #'user-description
  \end{clojure}
\end{english}

Этот прием крайне полезен в работе. Бóльшую часть времени мы проводим, редактируя функции, и перемещать курсор в конец формы неудобно. С помощью \code{cider-eval-defun-at-point} функцию обновляют, находясь в любом месте ее кода.

Если результат вычислений велик (например, выборка из базы данных), Cider покажет усеченную версию. Чтобы исследовать данные, выполните \code{cider-inspect-last-result}. Откроется буфер \code{*cider-inspect*}, где данные напечатаны постранично с учетом вложенности. Для примера исследуем большой словарь:

\begin{english}
  \begin{text}
(ns-map 'clojure.core)

Class: clojure.lang.PersistentHashMap
Contents:
  sort-by = #'clojure.core/sort-by
  contains? = #'clojure.core/contains?
  every? = #'clojure.core/every?
  proxy-mappings = #'clojure.core/proxy-mappings
  keep-indexed = #'clojure.core/keep-indexed
  ...
  Page size: 32, showing page: 1 of 29
  \end{text}
\end{english}

За навигацию по данным отвечают особые клавиши; приведем некоторые из них:

- \code{SPC} (пробел)~--- перейти на следующую страницу результата;
- \code{M-SPC}~--- вернуться на предыдущую;
- \code{RET} (Enter)~--- открыть вложенную структуру данных;
- \code{l}~--- подняться на уровень ниже

Команда \code{cider-inspect-last-sexp} (или \code{C-x TAB}) совмещает два шага: выполнить форму и открыть инспектор с результатом. С ней не понадобиться вызывать их по отдельности.

[inspector]: https://docs.cider.mx/cider/debugging/inspector.html

Полное описание инспектора, его команд и клавиш вы найдете на сайте Cider в [одноименном разделе][inspector].

\subsubsection{Dev-секции}

Опытные программисты оставляют в файлах так называемые dev sections~--- области разработки. Это код, который легко выполняют в REPL, чтобы проверить некоторые вычисления. Dev-секция помещается в макрос \code{comment}, чтобы не участвовать в компиляции.

Предположим, вы написали функцию \code{->fahr} для перевода температуры между шкалой Цельсия и Фаренгейта:

\begin{english}
  \begin{clojure}
(defn ->fahr [cel]
  (+ (* cel 1.8) 32))
  \end{clojure}
\end{english}

Чтобы ее проверить, добавьте в конец файла отладочный код:

\begin{english}
  \begin{clojure}
(comment
  (->fahr 36.6)
  (->fahr 0)
  (->fahr nil)
  )
  \end{clojure}
\end{english}

Поставьте курсор после закрывающей скобки в первой форме и выполните ее~--- получится 97.88, что совпадает с ожиданиями. Выполните и другие выражения, в том числе с \code{nil}, чтобы спровоцировать исключение. Если логика функции изменится, вы легко проверите ее работу.

Обратите внимание на следующие моменты. Отладочный код находятся в макросе \code{comment}, который игнорирует содержимое: при компиляции он вырождается в пустоту. Не путайте макрос \code{comment} и комментирование точкой с запятой. Во втором случае форму нельзя выполнить: команда \code{cider-eval-last-sexp} не сработает.

\begin{english}
  \begin{clojure}
;; cannot be evaluated
;; (->fahr 36.6) |
  \end{clojure}
\end{english}

Закрывающая скобка \code{comment} стоит отдельно, чтобы по ошибке не выполнить его вместо последней формы. Покажем это на примере. Предположим, скобка стоит по правилам Lisp-синтаксиса на той же строке:

\begin{english}
  \begin{clojure}
(comment
  ...
  (->fahr nil))
  \end{clojure}
\end{english}

Чтобы выполнить \code{(->fahr nil)}, курсор ставят между двумя последними скобками:

\begin{english}
  \begin{clojure}
(comment
  ...
  (->fahr nil)|)
  \end{clojure}
\end{english}

На практике легко промахнуться и поставить курсор в конце:

\begin{english}
  \begin{clojure}
(comment
  ...
  (->fahr nil)) |
  \end{clojure}
\end{english}

В этом случае команда \code{cider-eval} выполнит форму \code{comment}, которая вернет \code{nil} вне зависимости от содержимого. Сложится ощущение, что \code{(->fahr nil)} возвращает \code{nil}, что на самом деле не так. Чтобы этого не случилось, скобку \code{comment} переносят на новую строку.

Некоторые редакторы выделяют форму \code{comment} цветом, чтобы подчеркнуть~--- это не боевой код, а пример или справка. Если подсветка не работает, попробуйте список с тегом игнорирования \code{\#\_}:

\begin{english}
  \begin{clojure}
#_
((->fahr 36.6)
  (->fahr 0)
  (->fahr nil)
)
  \end{clojure}
\end{english}

В результате dev-секция будет окрашена в особый цвет, и вы легко отделите ее от кода.

Код dev-секции может быть с побочным эффектом, например когда вы тестируете HTTP-запросы или базу данных. Проследите, чтобы в коде не было паролей или ключей доступа. Если они необходимы, считайте их из файла или переменной среды:

\begin{english}
  \begin{clojure}
(comment
  (def -api-key
    (slurp "API_KEY"))
  (def -response
    (make-http-request ... -api-key)))
  \end{clojure}
\end{english}

[zip-dev]: https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj\#L281
[zippers]: https://grishaev.me/clj-zippers-1/

Dev-секции встречаются во многих библиотеках, в том числе Clojure. Например, модуль clojure.zip [содержит блок][zip-dev] \code{comment} с набором шагов, где проверяется логика [зипперов][zippers].

\subsubsection{Сниппеты}

Чем дольше вы работаете в проекте, тем больше у вас будет сниппетов. Так называют фрагменты кода, которые делают что-то полезное: меняют логирование, посылают HTTP-запросы, выводят служебные данные. У сниппетов особое положение: с одной стороны, им не место в боевом коде. С другой стороны, они полезны в разработке, поэтому их нужно где-то хранить.

Снипеттом может быть запрос к базе, например очистка таблиц или сложная выборка. В разработке сброс таблиц нужен часто, поэтому логично держать сниппет под рукой.

\begin{english}
  \begin{clojure}
(clojure.java.jdbc/execute!
 {:dbtype "postgresql"
  :dbname "test"
  :host "127.0.0.1"
  ...}
 ["truncate users, orders, ... cascade"])
  \end{clojure}
\end{english}

Другой пример~--- обращение ко внешнему REST API. Это вызов функции \code{post} из библиотеки clj-http с параметрами и заголовками:

\begin{english}
  \begin{clojure}
(clj-http.client/post
 "https://internal.api.com/api/v1"
 {:as :json
  :content-type :json
  :headers {"Authorization" "Bearer ..."}
  :form-params {:event "user_created"
                :user_id 10099}})
  \end{clojure}
\end{english}

Обратите внимание, что в сниппетах используют полные пространства имен. Это нужно для того, чтобы код сработал в любом пространстве, в том числе там, где нет импортов \code{clj-http.client} или \code{cheshire.core}. Сниппеты удобно хранить в отдельном .clj-файле, чтобы выполнять оттуда, не копируя в REPL. Так получается персональная среда разработки.

Cider предлагает особый буфер, чтобы выполнить код на Clojure. Когда вы подключены к nREPL, наберите команду \code{M-x cider-scratch}. Откроется буфер \code{*cider-scratch*}, связанный с текущим проектом. Скопируйте в него любой код. Поместите курсор за нужной формой и нажмите \code{C-j}~--- на следующей строке появится результат:

\begin{english}
  \begin{clojure}
(+ 1 2) | ;; press C-j

(+ 1 2)
3
  \end{clojure}
\end{english}

Особенность \code{*cider-scratch*} в том, что результат не пропадает, а остается в файле для дальнейшей работы. Выполните более сложный пример, нажимая \code{C-j} после каждой формы:

\begin{english}
  \begin{clojure}
(require '[clojure.walk :as walk])
nil

(walk/stringify-keys {:hello {:test 33}})
{"hello" {"test" 33}}
  \end{clojure}
\end{english}

Комбинация \code{C-u C-j} печатает результат при помощи \code{clojure.pprint}, то есть с отступами и переносами строк. Опробуйте ее на больших данных, например словаре переменных среды:

\begin{english}
  \begin{clojure}
(into {} (System/getenv)) | ;; C-j
  \end{clojure}
\end{english}

[emacs-scratch]: https://www.gnu.org/software/emacs/manual/html\_node/emacs/Lisp-Interaction.html

Пользователи Emacs догадались, что буфер \code{*cider-scratch*}~--- это аналог обычного \code{*scratch*}. Так называется [встроенный буфер][emacs-scratch] Emacs, который выполняет код на ELisp. Разница в том, что \code{*cider-scratch*} ожидает код на Clojure и выполняет его в том проекте, в папке с которым находится.

Если сохранить \code{*cider-scratch*}, Emacs запросит путь на диске, потому что по умолчанию буфер не связан с файлом. Введите любое имя, например \code{scratch.clj}. Если открыть его в следующий раз, он будет вести себя как обычный текст: нажатие \code{C-j} перенесет каретку без выполнения кода. Так происходит потому, что при открытии буфер получит базовый режим (fundamental mode). Смените его командой \code{M-x cider-clojure-interaction-mode}, и выполнение кода заработает.

Чтобы не вводить команду каждый раз, воспользуйтесь одним из двух способов. Первый~--- поместите в начале файла строку:

\begin{english}
  \begin{text}
; -*- mode: cider-clojure-interaction -*-
  \end{text}
\end{english}

[emacs-file-vars]: https://www.gnu.org/software/emacs/manual/html\_node/efaq/Associating-modes-with-files.html

При открытии файлов Emacs [учитывает выражения][emacs-file-vars], заключенные в символы \code{-*-}, и выполняет их. Метка \code{mode} означает сменить главный режим буфера.

Второй, более универсальный способ~--- связать регулярное выражение файла с режимом. Выражение охватывает только имя файла и расширение (путь отбрасывается). В нашем случае правило выглядит так:

\begin{english}
  \begin{lisp}
(add-to-list 'auto-mode-alist '("scratch\.clj" . cider-clojure-interaction-mode))
  \end{lisp}
\end{english}

Выполните это выражение в буфере \code{*scratch*}, и изменения вступят в силу немедленно (не забудьте добавить его в конфигурацию Emacs). Закройте и откройте файл \code{scratch.clj}~--- он перейдет в интерактивный режим.

Чтобы сниппеты не попали в историю git, добавьте имя файла в \code{.gitignore} проекта или глобальные настройки git (файл \code{~/.gitignore} в домашней директории).

Пользу сниппетов трудно переоценить: намного легче найти код по ключевым словам, чем набирать по памяти. Не ленитесь сохранять полезные выражения в файл~--- в будущем они пригодятся вам и коллегам.

\subsection{Пространства имен}

При работе с REPL мы всегда находимся в каком-то пространстве. По умолчанию оно написано в приглашении:

\begin{english}
  \begin{clojure}
user=> (+ 1 2)
  \end{clojure}
\end{english}

Если перейти в другое пространство, изменится и приглашение:

\begin{english}
  \begin{clojure}
user=> (in-ns 'foobar)
foobar=>
  \end{clojure}
\end{english}

Код, что мы вводим в REPL, вычисляется в текущем пространстве. Если объявить в модуле \code{user} переменную:

\begin{english}
  \begin{clojure}
(in-ns 'user)
(def number 1)
  \end{clojure}
\end{english}

, а затем сослаться на нее в пространстве \code{foobar}, получим ошибку, что символ \code{number} не найден в текущем контексте:

\begin{english}
  \begin{clojure}
(in-ns 'foobar)
(+ 1 number)

Syntax error compiling at (repl-chapter:localhost:53495(clj)*:1:8440).
Unable to resolve symbol: number in this context
  \end{clojure}
\end{english}

Другой пример: объявим в модулях \code{user} и \code{foobar} переменные \code{number} со значениями 1 и 2. Теперь одна и та же форма \code{(inc number)} даст разный результат в зависимости от того, какое пространство текущее. Поэтому перед вычислением мы должны убедиться, что находимся в нужном пространстве имен.

Чтобы уберечь нас от подобных ошибок, nREPL учитывает параметр \code{ns} в сообщениях. Когда мы выполняем код при помощи \code{cider-eval-...}, в сообщении, помимо полей \code{op} и \code{code}, передается \code{ns}. Его значение Cider находит из формы \code{(ns...)} в начале файла. Вычисляя форму, сервер временно меняет пространство, и результат совпадает с тем, что ожидают.

<!-- more~--->

Все же ручного контроля за текущим пространством не избежать. Переключить его понадобится, например, для того, чтобы вызывать приватную функцию, объявленную с помощью \code{(defn- ...)} или \code{(def \^:private ...)}. Обратиться к ней извне можно только формой \code{resolve} или оператором \code{\#'}, что неудобно:

\begin{english}
  \begin{clojure}
((resolve 'some-ns/private-func) 1 2)
;; or
(#'some-ns/private-func 1 2)
  \end{clojure}
\end{english}

Проще выполнить код в пространстве \code{some-ns}~--- внутри него приватное определение не отличается от обычного.

\begin{english}
  \begin{clojure}
(in-ns 'some-ns)
(private-func 1 2)
  \end{clojure}
\end{english}

Смена пространства важна при отладке кода, как своего, так и чужого. Мы подробно рассмотрим отладку чуть позже.

Перечислим возможности Cider для контроля за пространствами имен. Команда \code{cider-find-ns} вернет список загруженных модулей. В него входят модули проекта, Clojure и сторонние библиотеки. Имена следуют в алфавитном порядке; диалог поддерживает автодополнение.

\begin{english}
  \begin{text}
M-x cider-find-ns

Click on a completion to select it.
In this buffer, type RET to select the completion near point.

Possible completions are:
- aleph.http
- aleph.http.client
- bogus.core
- borkdude.dynaload
- buddy.core.bytes
...
  \end{text}
\end{english}

При выборе элемента откроется исходный код модуля. Cider поддерживает в том числе модули из jar-архивов. Например, при выборе \code{clojure.core} на ноутбуке автора открывается файл:

\begin{english}
  \begin{text}
/Users/ivan/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1-sources.jar
  \end{text}
\end{english}

Буферы из архивов доступны в режиме чтения. Без особых ухищрений нельзя изменить файл в архиве и сохранить его. В особых случаях это необходимо; в секции про отладку мы рассмотрим, как это сделать.

Команда \code{cider-browse-ns} покажет переменные модуля. Приведем фрагмент для модуля \code{clojure.core.async}:

\begin{english}
  \begin{clojure}
clojure.core.async
- <! takes a val from port.
- <!! takes a val from port.
- >! puts a val into port.
- >!! puts a val into port.
  \end{clojure}
\end{english}

Каждый элемент открывает буфер с подробностями: документацией, спекой, ссылкой на файл. Работают ссылки на другие определения: из буфера с макросом \code{>!!} можно перейти к \code{>!}, \code{put!} и другим, указанным в секции "Also see". С помощью \code{cider-browse-ns} иногда отпадает нужда в документации.

Cider предлагает многие другие команды для работы с пространствами. Ознакомьтесь с ними на [странице документации][cider-docs].

[cider-docs]: https://docs.cider.mx/cider/index.html

\subsection{Переход к определению}

Программный код~--- не просто текст; он обладает структурой. Классы, функции и другие элементы строят его скелет. Продвинутый редактор понимает структуру кода и поддерживает переходы по элементам. Например, по нажатию клавиши открыть файл с определением функции под курсором. По нажатию другой клавиши вернуться назад.

Emacs и Cider предлагают разные способы навигации по коду. В этом разделе мы рассмотрим некоторые из них.

Команда \code{M-x cider-find-var} запрашивает данные о символе под курсором. Предположим, вы написали код:

\begin{english}
  \begin{clojure}
(let [name "John"
      email "test@test.com"]
  (format "%s <%s>" name email))
  \end{clojure}
\end{english}

Поместите курсор на слово \code{format} и выполните команду. Откроется буфер \code{core.clj} из jar-архива на строке 5738, где объявлена функция \code{format}.

Информацию о символе находит сервер. Пространство, в котором мы ищем символ, должно быть предварительно загружено. В зависимости от технических деталей клиент посылает команду \code{info} или \code{lookup}. С сервера приходят данные об имени файла и позиции в нем.

Чтобы вернуться прежний буфер, выполните \code{M-x cider-pop}-back. Обратный переход нужен столь же часто, что и прямой. Опытным путем автор пришел к комбинации клавиш  \code{C-x .}. Добавьте в настройки Emacs выражение:

\begin{english}
  \begin{lisp}
(global-set-key (kbd "C-x .") 'cider-pop-back)
  \end{lisp}
\end{english}

Переход к определению работает не только с функциями, но и переменными, объектами \code{defmulti}, \code{defprotocol} и другими. В случае с \code{defmulti} вы перейдете к объявлению мультиметода, но не его методов. Убедитесь в этом на примере \code{print-method} из \code{clojure.core}.

Команда \code{cider-find-var} учитывает пространства имен и их псевдонимы. Предположим, в файле следующий заголовок \code{ns}:

\begin{english}
  \begin{clojure}
(ns some-ns
  (:require
   [clojure.walk :as walk]))
  \end{clojure}
\end{english}

Чтобы открыть пространство \code{clojure.walk}, поместите курсор на \code{walk} и выполните \code{cider-find-var}.

[emacs-xref]: https://www.gnu.org/software/emacs/manual/html\_node/emacs/Xref.html

В последних версиях Cider произошли изменения: вместо \code{cider-find-var} используется более абстрактная команда \code{xref-find-definitions}. Она принадлежит встроенному в Emacs [пакету Xref][emacs-xref] для поиска определений и перекрестных ссылок. Особенность Xref в том, что его легко расширить под нужный язык или платформу. Об нем мы расскажем чуть ниже.

Команда \code{cider-javadoc} открывает документацию к классу Java. Предположим, мы работаем с сертификатами, и в заголовке \code{ns} находятся импорты:

\begin{english}
  \begin{clojure}
(ns ...
  ...
  (:import
   java.security.cert.CertificateFactory
   java.security.cert.X509Certificate
   java.security.PublicKey))
  \end{clojure}
\end{english}

Наведите курсор на любой класс и выполните \code{M-x cider-javadoc}~--- откроется браузер с документацией к классу и текущей версии JVM. В случае автора страница для \code{X509Certificate} оказалась следующей:

\begin{english}
  \begin{text}
https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/security/cert/X509Certificate.html
  \end{text}
\end{english}

Команда \code{cider-find-keyword} служит для поиска кейвордов. Если навести курсор на ключ \code{:some.ns/name} и выполнить ее, Cider попытается:

- перейти в пространство \code{some.ns}
- сместиться до первого упоминания \code{::name}.

Мы написали "попытается", потому что способ работает только для ключей, пространство которых совпадает с одноименным модулем. Если у кейворда произвольное пространство, например \code{:book/name}, поиск не сработает: пространства \code{book} не существует, а перебор всех модулей будет слишком долгим.

Переход к кейворду работает в том числе с псевдонимами (алиасами). Например, если в шапке \code{ns} указать пространству псевдоним \code{user} и сослаться на кейворд по нему:

\begin{english}
  \begin{clojure}
(ns some-ns
  (:require
   [company.api.user :as user]))

(get user ::user/email) ;; M-x cider-find-keyword
  \end{clojure}
\end{english}

, то поиск пройдет успешно. До двойному двоеточию nREPL определит, что пространство~--- псевдоним и раскроет его.

Переход по кейвордам полезен в работе с \code{clojure.spec}. Спеки объявляют макросом \code{s/def}, который принимает кейворд. Макрос не создает переменную в модуле, а помещает спеку в глобальный реестр с указанными ключом. Найти ее командой \code{cider-find-var} будет невозможно. Здесь и выручит вас команда \code{cider-find-keyword}, которая работает как навигатор по спекам.

Предположим, вы пишете конфигурацию приложения. Поле \code{:db} базы данных использует спеку из модуля \code{clojure.java.jdbc.spec}:

\begin{english}
  \begin{clojure}
(ns some-ns
  (:require
   [clojure.spec.alpha :as s]
   [clojure.java.jdbc.spec :as jdbc]))

(s/def ::db ::jdbc/db-spec)

(s/def ::config
  (s/keys :req-in [::db]))
  \end{clojure}
\end{english}

Чтобы перейти к определению \code{::jdbc/db-spec}, наведите на него курсор и выполните \code{cider-find-keyword}. Вы окажетесь в файле \code{spec.clj} на строке 78 с макросом \code{s/def}:

\begin{english}
  \begin{clojure}
;; clojure/clojure/java/jdbc/spec.clj
(s/def ::db-spec ...)
  \end{clojure}
\end{english}

Примеры выше подсказывают: используйте ключи, связанные с текущим пространством имен (с двойным двоеточием):

\begin{english}
  \begin{clojure}
::name
::description
::not-found
  \end{clojure}
\end{english}

В этом случае между ключом и пространством возникает связь, и по одному легко узнать другое. Наоборот, ключ с произвольным пространством словно оторван от кода, и это снижает его возможности:

\begin{english}
  \begin{clojure}
:user/id
:error/not-found
:api/limit
  \end{clojure}
\end{english}

Представьте, что встретили в коде названную так спеку или событие re-frame. Ни один ключ не дает информации о том, где искать его определение. К сожалению, Cider тоже будет не в силах вам помочь.

\subsubsection{Xref}

С версии 26 в Emacs появился новый способ навигации по коду. Он называется Xref~--- от английского cross-reference, перекрестная ссылка. Особенность Xref в дизайне: модуль поддерживает разные источники (бэкенды), откуда приходят данные об определениях. Источником может быть файл тегов, созданный [командой ctags][ctags] для индексирования кода. Также источником может быть функция, если известен иной алгоритм поиска. Например, если это проект на Python, специальный плагин перехватывает вызов Xref и возвращает данные, полученные библиотекой [fast-autocomplete][fast-autocomplete] или похожей.

[fast-autocomplete]: https://pypi.org/project/fast-autocomplete/
[ctags]: https://en.wikipedia.org/wiki/Ctags

Тип бэкенда не влияет на работу пользователя. Поиск и переход по коду сводятся к нескольким командам семейства \code{xref-find-...}

Чтобы Cider перехватывал вызовы Xref, установите переменную \code{cider-use-xref} в истину. По умолчанию это так, но на всякий случай выполните в \code{*scratch*} выражение:

\begin{english}
  \begin{clojure}
(setq cider-use-xref t)
  \end{clojure}
\end{english}

Откройте любой модуль, загруженный в nREPL. Поместите курсор на символ функции и выполните \code{M-x xref-find-definitions}. По аналогии с \code{cider-find-var} откроется файл на той строке, где объявлена функция. Способ работает с макросами, протоколами, пространствами имен.

Команде \code{xref-find-definitions} назначена комбинация \code{M-.} (альт с точкой). Она работает и в других режимах Emacs, например \code{lisp-mode} или \code{python-mode} (с модулем Anaconda и аналогами).

Чтобы участвовать в поиске, пространство должно быть загружено в REPL. Cider не ищет в локальных файлах, а посылает сообщение серверу. Код на сервере обходит загруженные пространства. Определения получают функцией [\code{ns-map}][ns-map], которая возвращает словарь вида символ => определение. Поиск сводится к доступу по словарю, что довольно быстро.

[ns-map]: https://clojuredocs.org/clojure.core/ns-map

Команда \code{xref-find-references} находит места, где встречается указанный символ. С ее помощью легко проверить, нуждается ли проект в определенной функции или нет. Если ссылок на нее не найдено, удалите функцию без опасений. Другое применение команды~--- рефакторинг, когда вы изменили сигнатуру функции и теперь исправляете ее вызовы.

[emacs-xref2]: https://www.gnu.org/software/emacs/manual/html\_node/emacs/Xref.html

Другие возможности Xref вы найдете на сайте проекта GNU [в разделе Emacs][emacs-xref2].

\subsubsection{Imenu}

[clojure-mode]: https://github.com/clojure-emacs/clojure-mode

Плагин [Clojure mode][clojure-mode] расширяет Imenu в Emacs. Imenu (сокращение от Interactive menu)~--- это встроенный модуль для показа определений в файле. По команде \code{M-x imenu} откроется буфер с оглавлением~--- именами функций, макросов, типов~--- и приглашением ввода. Приведем краткую версию буфера для модуля \code{clojure.core}:

\begin{english}
  \begin{text}
- Function / any?
- Function / str
- Function / symbol?
- Function / keyword?
  \end{text}
\end{english}

Для каждого языка Imenu хранит набор правил, по которым ищутся определения. В случае с Clojure это шаблоны \code{(def ...)}, \code{(defn ...)} и другие. Правила можно расширить, чтобы учесть кейворды или особые формы. В этом редко бывает нужда, потому что по умолчанию в Clojure mode заданы обширные правила, в том числе для пакетов \code{clojure.spec} и \code{clojure.test} (формы \code{s/def}, \code{deftest} и другие).

Чтобы Imenu работало в файлах Clojure, добавьте в настройки выражение:

\begin{english}
  \begin{lisp}
(add-hook 'clojure-mode-hook #'imenu-add-menubar-index)
  \end{lisp}
\end{english}

Задайте команде \code{imenu} комбинацию клавиш. Автор предпочитает \code{C-i}:

\begin{english}
  \begin{lisp}
(global-set-key (kbd "<C-i>") 'imenu)
  \end{lisp}
\end{english}

Если вы пользуетесь графической версией Emacs, меню удивит вас. Появится системное окно со списком определений. Предполагается, что пользователь переложит руку на мышь и выберет нужный пункт.

Странность решения в том, что всплывающее окно полностью оторвано от Emacs. В нем не работают клавиши перехода по строкам; на больших файлах меню не влазит в экран. Перенос руки с клавиатуры на мышь и обратно нарушает идеи редактора. Поэтому назначьте следующей переменной \code{nil}:

\begin{english}
  \begin{lisp}
(setq imenu-use-popup-menu nil)
  \end{lisp}
\end{english}

Теперь вместо всплывающего окна появится буфер Emacs. В нем работает привычная навигация по элементам.

[helm]: https://github.com/emacs-helm/helm

Интерактивное меню станет еще удобней с пакетом [Helm][helm]. Установите его командой:

\begin{english}
  \begin{text}
M-x package-install <RET> helm <RET>
  \end{text}
\end{english}

Задайте клавишам \code{C-i} команду \code{helm-imenu}:

\begin{english}
  \begin{lisp}
(global-set-key (kbd "<C-i>") 'helm-imenu)
  \end{lisp}
\end{english}

Helm предлагает более удобные диалоги. При вводе текста он покажет элементы, которые включают его. Для ввода \code{user} получим \code{get-user}, \code{delete-user} и другие имена. Обычный \code{imenu} ищет элементы, которые начинаются с текста, что неудобно, если вы не помните точное имя функции.

\subsection{Тесты в Cider}

Работая над программой, мы постоянно запускаем код в REPL. По-другому подход называют REPL-driven development. У людей, не знакомых с Lisp и Clojure, складывается ошибочное мнение, что тесты не нужны: зачем их писать, если все проверено в REPL?

Это не так: запуск кода в REPL не отменяет тестов. Когда программа закончена, проверки оформляют в тест, чтобы их зафиксировать. Далее код улучшают, постоянно сверяясь с тем, что тест проходит.

Перед тем как начать работу над кодом, убедитесь, что он покрыт тестом. В идеале вы запускаете тест до изменений, чтобы знать предпосылки. Если тест проходит, это гарантирует, что вы отталкиваетесь от штатной ситуации. Если после изменений тест "падает", ищите причину в ваших действиях.

Случается, что тесты "сломаны" уже до работы над кодом. Например, кто-то измененил код в обход регламента (CI, review). Предварительный прогон тестов покажет, что дело не в ваших изменениях.

В прошлой книге мы подробно разобрали тесты в Clojure. Если коротко, макрос \code{deftest} объявляет функцию, чье тело находится в поле метаданных \code{:test}. Тесты запускают в особом режиме, когда включены фикстуры и сборщик данных (reporter).

Cider предлагает ряд функций для запуска тестов. Чтобы опробовать их, загрузите модуль с тестами в nREPL. Для этого выполните либо \code{cider-load-buffer} (\code{C-c C-k}), либо \code{cider-ns-refresh} (\code{C-C M-n r}). Во втором случае путь к тестам должен быть в classpath. В lein это легко задать полем \code{resource-paths} в профиле \code{dev}:

\begin{english}
  \begin{clojure}
{:profiles
 {:dev
  {:resource-paths ["test"]}}}
  \end{clojure}
\end{english}

Приведем минимальный модуль с тестами:

\begin{english}
  \begin{clojure}
(ns sample-test
  (:require
   [clojure.test :refer [deftest is]]))

(deftest test-orwell
  (is (= 5 (* 2 2))))
  \end{clojure}
\end{english}

Установите курсор в любое место \code{deftest} и выполните \code{M-x cider-test-run-test}. Команда запустит одиночный тест, при этом на сервер уйдут два сообщения. В первом клиент запросит данные о символе \code{sample/test-orwell}. Это необходимо, чтобы убедиться, что \code{sample/test-orwell}~--- действительно тест:

\begin{english}
  \begin{text}
  op   "info"
  sym  "sample/test-orwell"
  \end{text}
\end{english}
В
о втором сообщении клиент отправит команду \code{test} со списком из одного теста:

\begin{english}
  \begin{text}
  op     "test"
  tests  ("test-orwell")
  \end{text}
\end{english}

Middleware из пакета \code{cider-nrepl} перестроит эту команду в выражение ниже, и тест будет выполнен.

\begin{english}
  \begin{clojure}
(clojure.test/test-var #'test-orwell)
  \end{clojure}
\end{english}

Также middleware перехватит вывод теста и вернет его в структурированном виде. Вот что получит клиент в положительном случае:

\begin{english}
  \begin{text}
  id      "317"
  column  1
  file    "file:/Users/ivan/work/book-sessions/repl-chapter/src/sample.clj"
  line    6
  name    "test-orwell"
  ns      "sample"
  status  ("done")
  \end{text}
\end{english}

и при ошибке:

\begin{english}
  \begin{text}
  id         "320"
  session    "65cc0cad-5a9f-4faa-ba3f-6b2e276b5ba0"
  time-stamp "2022-05-21 20:02:51.069229000"
  gen-input  nil
  results    (dict
               sample (dict
                        test-orwell ((dict "actual" "4\n" "context" nil "diffs"
       (("4\n"
         ("5\n" "4\n")))
       "expected" "5\n" "file" "sample.clj" "index" 0 "line" 7 "message" "" "ns" "sample" "type" "fail" "var" "test-orwell"))))
  summary    (dict
               error 0
               fail  1
               ns    1
               pass  0
               test  1
               var   1)
  testing-ns "sample"
  \end{text}
\end{english}

Во втором случае откроется буфер \code{*cider-test-report*} с отчетом. Красным цветом показаны места, где оператор \code{(is ...)} вернул ложь. Желтым отмечены формы, где возникло исключение. Ниже~--- отчет о том, что вычисление \code{(* 2 2)} не сошлось с ожидаемым результатом (5):

\begin{english}
  \begin{text}
Test Summary
sample

Tested 1 namespaces
Ran 1 assertions, in 1 test functions
1 failures

Results

sample
1 non-passing tests:

Fail in test-orwell

expected: 5
  actual: 4
    diff: - 5
          + 4
  \end{text}
\end{english}

Исправьте тест, заменив 5 на 4. Чтобы изменения вступили в силу, выполните \code{deftest} при помощи \code{cider-eval-defun-at-point}. По аналогии с функциями и переменными, тесты нужно переопределять после изменений. Если запустить тест без этого шага, сработает прошлая версия с ошибкой.

Cider предлагает многие другие удобства для тестов. Команда \code{cider-test-rerun-test} повторно выполнит последний запущенный тест. С ней отпадает нужна переключаться между кодом, который вы редактируете, и его тестом. Достаточно выполнить тест и продолжить работу над кодом, время от времени вызывая \code{cider-test-rerun-test}.

Команда \code{cider-test-run-ns-tests} выполняет тесты определенного пространства. Если вызвать ее в модуле \code{project.sample}, Cider запустит тесты в пространстве \code{project.sample-test} (при условии, что оно найдено). Следовать этому правилу не обязательно: можно именовать тесты иначе, например с частичкой \code{test} в начале:

\begin{english}
  \begin{clojure}
(ns test.project.sample)
  \end{clojure}
\end{english}

Однако в первом случае их легче выполнить в Cider.

Команда \code{cider-test-rerun-failed-tests} выполнит только те тесты из прошлого прогона, что окончились неудачей.

Этих команд достаточно для работы с тестами в Clojure. Полный список вы найдете в документации Cider в разделе [Running Tests][cider-tests].

[cider-tests]: https://docs.cider.mx/cider/testing/running\_tests.html

\subsection{Отладка сообщений nREPL}

В редких случаях понадобится перехват сообщений между сервером nREPL и Emacs. Например, вы пишете клиент для другого редактора и хотели бы знать, какие сообщения шлет и принимает Emacs, чтобы сделать так же у себя.

Утилиты \code{tcpdump} и Wireshark, что мы рассмотрели выше, в данном случае избыточны. Воспользуйтесь командой \code{nrepl-toggle-message-logging}. Она откроет буфер \code{*nrepl-messages*} с сообщениями текущей сессии. Приведем пару из них в сокращении:

\begin{english}
  \begin{text}
(-->
  id        "27"
  op        "eval"
  session   "444ea459-4165-4f82-afbc-b9cfbae4d2c5"
  code      "(+ 1 2)"
  column    6
  line      28
  ns        "foo"
)
(<--
  id         "27"
  session    "444ea459-4165-4f82-afbc-b9cfbae4d2c5"
  time-stamp "2022-06-18 17:15:30.451402000"
  value      "3"
)
  \end{text}
\end{english}

Направление стрелки означает характер сообщения: от клиента серверу~--- вправо и обратно~--- влево. Данные показаны независимо от транспорта (Bencode, EDN), что упрощает их анализ.

Перехват сообщений замедляет работу клиента и поэтому выключен. Повторный ввод команды отключит его.

\subsection{Отладка кода}

Перейдем к наиболее важной части главы: рассмотрим, как отлаживать код на Clojure.

Cider предлагает полноценный отладчик (дебаггер), но по некоторым причинам им пользуются редко. Так происходит потому, что концепции Clojure~--- неизменяемость, чистые функции, REPL~--- уже отсекают многие ошибки, свойственные другим языкам. Однако в сложных проектах вам не избежать отладки.

\subsubsection{Наивные способы}

Прежде чем перейти к отладчику Cider, рассмотрим простые, "народные" способы отладить код~--- иногда их бывает достаточно. Предположим, функция принимает словарь опций с точками в названии. В ответ она возвращает вложенный словарь кейвордов. Входные данные и результат:

\begin{english}
  \begin{clojure}
(remap-props {"db.host" "127.0.0.1"
              "db.port" 5432
              "db.settings.ssl" false})

{:db
 {:host "127.0.0.1"
  :port 5432
  :settings {:ssl false}}}
  \end{clojure}
\end{english}

Тело функции:

\begin{english}
  \begin{clojure}
(require '[clojure.string :as str])

(defn remap-props [props]
  (reduce-kv
   (fn [result k v]
     (let [path
           (mapv keyword (str/split k #"\."))]
       (assoc-in result path v)))
   {}
   props))
  \end{clojure}
\end{english}

Если в словаре окажется поле, отличное от строки, получим ошибку приведения типа:

\begin{english}
  \begin{text}
(remap-props {"db.host" "127.0.0.1" :db/port 5432})

1. Unhandled java.lang.ClassCastException
   class clojure.lang.Keyword cannot be cast to class java.lang.CharSequence
   (clojure.lang.Keyword is in unnamed module of loader 'app';
   java.lang.CharSequence is in module java.base of loader 'bootstrap')

                string.clj:  219  clojure.string/split
                string.clj:  219  clojure.string/split
                      REPL:   28  sample/remap-props/fn
   PersistentArrayMap.java:  377  clojure.lang.PersistentArrayMap/kvreduce
   ...
  \end{text}
\end{english}

В отчете нет ни слова о том, какой именно ключ породил исключение. Самый простой способ подглядеть его~--- вывести на экран на каждом шаге. Для этого добавим \code{println} во внутреннюю функцию \code{reduce}:

\begin{english}
  \begin{clojure}
(defn remap-props [props]
  (reduce-kv
   (fn [result k v]
     (println ">>> " k v) ;; debugging
     (let [path
           (mapv keyword (str/split k #"\."))]
       (assoc-in result path v)))
   {}
   props))
  \end{clojure}
\end{english}

Перезагрузите функцию командами \code{cider-eval-last-sexp} или \code{cider-eval-defun-at-point}, поместив на нее курсор. Вызовите \code{remap-props}, и кроме результата в консоли появятся промежуточные шаги \code{reduce}:

\begin{english}
  \begin{text}
>>>  db.host 127.0.0.1
>>>  db.port 5432
>>>  db.settings.ssl false
  \end{text}
\end{english}

В случае с ошибочным словарем увидим, что дело в ключе \code{:db/port}, который не работает с функцией \code{split}:

\begin{english}
  \begin{text}
>>>  :db/port 5432
  \end{text}
\end{english}

Исправьте функцию так, чтобы она проверяла ключ функцией \code{string?}. Если это не так, бросьте исключение с именем ключа. С таким подходом отладка не нужна, потому что ошибка станет явной. Удалите \code{println} и перезагрузите функцию.

Печать на экран, при всей примитивности, позволяет быстро найти ошибку в коде. Ниже мы рассмотрим ее вариации.

Функция \code{println} выводит данные в одну строку, что неудобно для коллекций. Воспользуйтесь печатью с отступами из пакета \code{clojure.pprint}:

\begin{english}
  \begin{clojure}
(require 'clojure.pprint)

(fn [result k v]
  (clojure.pprint/pprint {:key k :value v})
  ...)
  \end{clojure}
\end{english}

С ней удобно исследовать запросы и ответы HTTP, потому что они описаны большими словарями.

Вернемся к функции \code{get-joke} для поиска шуток о программировании. Освежим в памяти ее код:

\begin{english}
  \begin{clojure}
(defn get-joke [lang]
  (let [request
        {:url "https://v2.jokeapi.dev/joke/Programming"
         :method :get
         :query-params {:contains lang}
         :as :json}

        response
        (client/request request)

        {:keys [body]}
        response

        {:keys [setup delivery]}
        body]

    (format "%s %s" setup delivery)))
  \end{clojure}
\end{english}

Чтобы исследовать ответ сервера, добавьте в \code{let} псевдопеременную \code{\_} (подчеркивание) и печать \code{response}. Это спорный прием, потому что переменная \code{\_} не используется: она только уравновешивает форму печати. С другой стороны, не придется разрывать цепочку \code{let}-вычислений.

\begin{english}
  \begin{clojure}
(defn get-joke [lang]
  (let [...
        response
        (client/request request)

        _
        (clojure.pprint/pprint response)

        {:keys [body]}
        response

        ...]))
  \end{clojure}
\end{english}

При поиске шутки вы увидите ответ сервера со статусом, заголовками и телом. Как только печать станет не нужна, мы легко удалим ее.

Вызов \code{pprint} влечет несколько неудобств. Во-первых, набирать выражение \code{(clojure.pprint/pprint ...)} долго. Во-вторых, нужно импортировать \code{clojure.pprint} в REPL, иначе получим ошибку, что модуль не загружен. Пойдем на хитрость: сделаем так, чтобы модуль загружался автоматически. Откройте локальные настройки lein (файл \code{~/.lein/profiles.clj}). В профиль \code{:user} добавьте ключ \code{:injections} с вектором:

\begin{english}
  \begin{clojure}
{:user
 :injections [(require 'clojure.pprint)]}
  \end{clojure}
\end{english}

Выражения \code{injections} будут выполнены при запуске nREPL. В них размещают код с побочными эффектами, в том числе загрузку модулей. Эта техника служит только для разработки.

Перезагрузите nREPL и выполните \code{(clojure.pprint/pprint ...)} в любом месте проекта. Печать сработает без ошибок, и не понадобится импорт \code{clojure.pprint} в объявлении пространства \code{(ns ...)}.

[wrap-region]: https://github.com/rejeep/wrap-region.el

Чтобы быстро вставить \code{pprint} в код, обратимся к плагину Emacs [wrap-region][wrap-region]. С его помощью выделенный текст оборачивают указанными строками. Установите плагин командой:

\begin{english}
  \begin{text}
M-x package-install <RET> wrap-region <RET>
  \end{text}
\end{english}

и добавьте в настройки код:

\begin{english}
  \begin{clojure}
(require 'wrap-region)
(wrap-region-mode t)

(wrap-region-add-wrapper "(clojure.pprint/pprint " ")" "p" 'clojure-mode)
  \end{clojure}
\end{english}

Если теперь выделить \code{response} и нажать \code{p}, появится выражение \code{(clojure.pprint/pprint response)}. Вместо \code{response} может быть любой текст, в том числе коллекция, макрос, вызов функции.

Иногда \code{pprint} выводит слишком много информации, и данные уходят за пределы видимости терминала. Модуль \code{clojure.inspector} решает это проблему. Он выводит графическое окно Swing с виджетом дерева. Коллекции обозначены папкой, а их элементы~--- файлом.

Окно не блокирует поток, который его вызвал. Код отработает без задержек, и вы без спешки изучите данные в инспекторе. Это особенно важно для задач, которые зависят от времени, например отправка HTTP-запросов, чтение и запись в каналы.

По аналогии с \code{clojure.pprint}, добавьте в секцию \code{injections} форму \code{(require 'clojure.inspector)}. Задайте клавишу для обертки символа в функцию \code{inspect-tree}:

\begin{english}
  \begin{clojure}
(wrap-region-add-wrapper "(clojure.inspector/inspect-tree " ")" "i" 'clojure-mode)
  \end{clojure}
\end{english}

\subsubsection{Внедрение в чужой код}

До сих пор мы отлаживали код в директории \code{src}. Этот код под вашим контролем: в него легко добавить печать и инспекцию, а затем откатить изменения.

Все меняется, когда нужно отладить стороннюю библиотеку. Код библиотек упакован в jar-файлы и находится в недрах директории \code{~/.m2}. Технически возможно распаковать архив jar, исправить код, упаковать обратно, а затем перезагрузить REPL. Однако это займет массу времени. Способ ниже описывает, как исправить код чужой библиотеки на лету.

Вернемся к функции \code{get-joke} для получения шуток. Функция обращается к сервису при помощи библиотеки \code{clj-http}. Давайте шагнем в недра \code{clj-http}, чтобы отследить, какие данные уходят в сеть.

Наведите курсор на символ \code{client/request} и нажмите \code{M-.} (или выполните \code{M-x cider-find-var}). Откроется модуль \code{clj-http.client} из jar-файла в директории \code{~/.m2/repository/clj-http/clj-http/3.12.0}. Вы окажетесь на строке 1134, где объявлена переменная \code{request}:

\begin{english}
  \begin{clojure}
(def ^:dynamic request
  "..."
  (wrap-request #'core/request))
  \end{clojure}
\end{english}

У функции длинная документация, которую мы заменили многоточием. Видно, что \code{request} на самом деле ссылается на функцию \code{core/request}, обернутую многими middleware. Установите курсор на \code{core/request} и снова выполните \code{M-.}~--- вы окажетесь в модуле \code{clj-http.core} из того же jar-файла на строке 546:

\begin{english}
  \begin{clojure}
(defn request
  ([req] (request req nil nil))
  ([{:keys [...]
     :as req} respond raise]
   (let [...]
     ...)))
  \end{clojure}
\end{english}

Буфер \code{clj-http.core} открыт в режиме чтения, потому что связан с архивом. Чтобы редактировать код, выполните \code{M-x toggle-read-only}. Теперь когда буфер доступен для изменений, добавьте инспекцию перед формой \code{let}:

\begin{english}
  \begin{clojure}
(defn request
  ([req] (request req nil nil))
  ([{:keys [...]
     :as req} respond raise]
   (clojure.inspector/inspect-tree req)
   (let [...]
     ...)))
  \end{clojure}
\end{english}

Обновите функцию на сервере командой \code{M-x cider-eval-defun-at-point}. Теперь вызов \code{client/request} покажет окно инспектора с полями запроса. Это справедливо не только для функции \code{get-joke}, но и для любого обращения к \code{clj-http}.

Как только инспекция станет не нужна, вернитесь в буфер \code{clj-http.core}. Откатите изменения командой \code{C-/} (undo) и обновите функцию на сервере. Буфер \code{clj-http.core} будет отмечен как измененный, и при закрытии Emacs предложит его сохранить. Откажитесь, потому что отладка не должна менять исходный код библиотек. В противном случае Emacs обновит jar-файл, и изменения коснуться каждого проекта с этой библиотекой.

Описанная техника работает со всеми модулями, в том числе встроенными в Clojure. Ради интереса перейдите в модули \code{clojure.walk}, \code{clojure.string} и другие. Добавьте в код побочные эффекты, проверьте изменения в REPL и откатите их.

\subsubsection{Подготовка к отладке}

Кроме печати и инспекции Cider предлагает полноценный отладчик. С ним можно выполнить код по шагам, проверить локальные переменные и стек вызовов, словом, делать все, что доступно в современных IDE. Чтобы читатель лучше понял отладку, поговорим об ее устройстве.

Вспомним, как работает отладка в IDE. Напротив строки ставят красную метку (точку останова) и запускают код. Когда исполнение достигает метки, программа останавливается и ждет команды пользователя. При выходе из отладки программа продолжит ход.

Можно сказать, отладка работает как REPL, запущенный в середине кода. Это бесконечный цикл, который читает команду, выполняет ее, выводит результат и ожидает новую команду. Разница в том, что отладчик не только выполняет код. Он хранит локальные переменные, стек вызовов, метрики и так далее.

Напишем простой отладчик для Clojure. Предположим, мы ничего не знаем о Cider и nREPL, поэтому используем только встроенные средства. Подготовим функцию \code{format-user}, которую подвергнем отладке:

\begin{english}
  \begin{clojure}
(ns debug
  (:require [clojure.main :as main]))

(defn format-user
  [{:keys [username email]}]
  (format "%s <%s>" username email))
  \end{clojure}
\end{english}

Проверим ее, подав на вход простой словарь:

\begin{english}
  \begin{clojure}
(format-user {:username "John"
              :email "john@test.com"})
;; "John <john@test.com>"
  \end{clojure}
\end{english}

Теперь добавим в функцию REPL:

\begin{english}
  \begin{clojure}
(defn format-user
  [{:keys [username email]}]
  (main/repl :prompt #(print "DEBUG>> "))
  (format "%s <%s>" username email))
  \end{clojure}
\end{english}

Функция \code{repl} из модуля \code{clojure.main} запустит сеанс REPL с вводом с клавиатуры. Если вставить ее в тело \code{format-user}, при запуске она прервется, и откроется приглашение:

\begin{english}
  \begin{text}
user=> (format-user {:username "John"
  #_=>               :email "john@test.com"})
DEBUG>> (+ 1 2)
3
  \end{text}
\end{english}

Обратите внимание на разницу в приглашении. Мы задали внутреннему REPL параметр \code{:prompt}, чтобы лучше понимать, в каком сеансе пребываем сейчас. Для выхода из отладки нажмите \code{Ctrl/Command+D}. Это сочетание подаст на вход символ \code{EOF}, что расценивается как сигнал завершения. Управление выйдет из внутреннего REPL, и вы получите результат \code{format-user}:

\begin{english}
  \begin{text}
DEBUG>> ;; Ctrl/Command+D
"John <john@test.com>"
user=>
  \end{text}
\end{english}

Во время отладки вам захочется узнать локальные переменные, например выяснить, чему равны \code{username} и \code{email}. Тут вас ждет неприятность: если ввести \code{username}, REPL выдаст исключение о том, что символ неизвестен. То же самое относится к переменным \code{let}: в примере ниже символы \code{a} и \code{b} окажутся недоступны.

\begin{english}
  \begin{text}
user=> (let [a 1
  #_=>       b 2]
  #_=>   (main/repl :prompt #(print "DEBUG>> ")))
DEBUG>> a
Syntax error compiling at (REPL:1:1).
Unable to resolve symbol: a in this context
DEBUG>>
  \end{text}
\end{english}

Причина в том, что функция \code{eval}, с помощью которой REPL выполняет код, не учитывает локальные переменные. Мы упоминали эту проблему в начале главы, и настало время решить ее.

\subsubsection{Продвинутый eval}

В этом разделе мы напишем функцию \code{eval+}~--- улучшенную версию обычной \code{eval}. Она принимает пространство имен, словарь локальных переменных и форму, которую нужно вычислить. Вот как выглядит ее сигнатура:

\begin{english}
  \begin{clojure}
(defn eval+ [ns locals form]
  ...)
  \end{clojure}
\end{english}

Представим вызов функции: вычислим форму \code{'(+ a b)} при \code{a} = 1 и \code{b} = 2 в пространстве \code{clojure.core}:

\begin{english}
  \begin{clojure}
(eval+ (the-ns 'clojure.core) {'a 1 'b 2} '(+ a b))
;; 3
  \end{clojure}
\end{english}

Прежде чем писать тело, выясним, где взять входные параметры. С аргументом \code{ns} нет сложностей, потому что текущее пространство имен доступно в переменной \code{*ns*}:

\begin{english}
  \begin{clojure}
> *ns*
;; #namespace[user]
  \end{clojure}
\end{english}

Если мы знаем имя пространства, его объект легко получить функцией \code{the-ns}:

\begin{english}
  \begin{clojure}
> (the-ns 'clojure.core)
;; #namespace[clojure.core]
  \end{clojure}
\end{english}

Локальные переменные (второй аргумент \code{locals})~--- это словарь, ключи которого символы. Он выполняет роль контекста при вычислении формы:

\begin{english}
  \begin{clojure}
(eval+ ... {'a 1 'b 2} '(+ a b)) ;; 3
(eval+ ... {'a 3 'b 4} '(+ a b)) ;; 7
  \end{clojure}
\end{english}

Как получить локальные переменные для текущего участка кода? Очевидно, их сбор должен быть автоматическим, а не ручным. Поможет макрос \code{get-locals}:

\begin{english}
  \begin{clojure}
(defmacro get-locals []
  (into {} (for [sym (keys &env)]
             [(list 'quote sym) sym])))
  \end{clojure}
\end{english}

Он опирается на скрытую переменную \code{\&env}, доступную только макросам. Это словарь, где ключи~--- символы, а значения~--- экземпляры класса \code{LocalBinding}. Класс \code{LocalBinding} содержит метаданные о локальных переменных. В метаданных нет значения переменной, но оно не понадобится. Форма \code{(get-locals)} возвращает словарь вида:

\begin{english}
  \begin{clojure}
{'a a, 'b b, ...}
  \end{clojure}
\end{english}

При вычислении он становится тем, что ожидали~--- словарем локальных переменных:

\begin{english}
  \begin{clojure}
{a 1, b 2, ...}
  \end{clojure}
\end{english}

Макрос в действии:

\begin{english}
  \begin{clojure}
(let [a 1
      b 2]
  (get-locals))

;; {a 1, b 2}
  \end{clojure}
\end{english}

Более сложный пример вызовом функции. Видно, что \code{get-locals} захватил аргументы \code{a} и \code{b} и переменную \code{c} из формы \code{let}:

\begin{english}
  \begin{clojure}
(defn add [a b]
  (let [c (+ a b)]
    (println (get-locals))
    (+ a b c)))

> (add 1 2)
;; {a 1, b 2, c 3}
6
  \end{clojure}
\end{english}

Теперь когда у нас есть все нужное, подумаем, как выполнить форму. Задача сводится к тому, чтобы связать локальные переменные с \code{eval}. Для этого есть несколько способов. Первый~--- временно сделать локальные переменные глобальными. Назовем этот трюк глобализацией. Чтобы "глобализировать" переменные, нужно:

- обойти словарь \code{locals} в цикле \code{doseq};
- внедрить переменные в пространство имен функцией \code{intern};
- вычислить форму при помощи \code{eval} и запомнить результат;
- удалить внедренные переменные при помощи \code{ns-unmap};
- вернуть результат.

Вот как выглядит черновик \code{eval+} с этим алгоритмом:

\begin{english}
  \begin{clojure}
(defn eval+ [ns locals form]
  (doseq [[sym value] locals]
    (intern ns sym value))
  (let [result
        (binding [*ns* ns]
          (eval form))]
    (doseq [[sym value] locals]
      (ns-unmap ns sym))
    result))
  \end{clojure}
\end{english}

Проверка показывает, что все верно:

\begin{english}
  \begin{clojure}
(eval+ *ns* {'a 1 'b 2} '(+ a b))
;; 3
  \end{clojure}
\end{english}

Убедимся, что мы не оставили за собой глобальных переменных: вне формы \code{eval+} символ a неизвестен:

\begin{english}
  \begin{text}
=> a
Syntax error compiling at (repl-chapter:localhost:62378(clj)*:1:8441).
Unable to resolve symbol: a in this context
  \end{text}
\end{english}

Обратите внимание, что \code{(eval form)} (строка 6) выполняется в рамках \code{binding} с привязкой пространства, которое передали в \code{eval+}. Без этого вычисление сработает в пространстве \code{clojure.core}, и переменные не подхватятся.

Недостаток глобализации в том, что она не учитывает некоторые обстоятельства. Например, если в словаре указана переменная \code{a} и такая же переменная задана в пространстве, после очистки мы потеряем ее:

\begin{english}
  \begin{clojure}
=> (def a 3)

=> (eval+ *ns* {'a 1 'b 2} '(+ a b))
3

=> a
Unable to resolve symbol: a in this context
  \end{clojure}
\end{english}

Доработайте код, чтобы перед вызовом \code{intern} и \code{ns-unmap} была проверка, существует ли переменная с таким именем. Если существует, переименуйте ее в \code{\_\_old\_<var>\_\_}. На обратном пути проверьте: если \code{\_\_old\_<var>\_\_} существует, верните \code{<var>} с прежним значением. Для проверки переменной на существование используйте \code{resolve}. Результат будет либо \code{nil}, либо \code{Var}. Значение переменной легко получить, <<дерефнув>> \code{Var} оператором \code{@} или функций \code{deref}, предварительно проверив на \code{nil} или с помощью оператора \code{some->}.

Второй и более правильный способ выполнить форму с локальными переменными~--- сдвинуть их внутрь \code{eval}. Для этого погрузим форму в оператор \code{let} по следующему принципу:

\begin{english}
  \begin{clojure}
;; locals
{'a 1 'b 2}

;; form
'(+ a b)

;; final form
'(let [a 1 b 2]
   (+ a b))
  \end{clojure}
\end{english}

Если выполнить итоговую форму в REPL, получим ожидаемый результат 3. В этом подходе нет махинаций с глобальными переменными, что делает его безопасней.

Рассмотрим, составить подобную форму \code{let}. На первый взгляд задача кажется легкой: это список, где первый элемент~--- символ \code{let}, второй~--- вектор связывания, а третий~--- форма, которую вычисляют. Составим функцию \code{make-eval-form}:

\begin{english}
  \begin{clojure}
(defn make-eval-form [locals form]
  (list 'let (vec (mapcat identity locals)) form))
  \end{clojure}
\end{english}

и убедимся в ее работе:

\begin{english}
  \begin{clojure}
=> (make-eval-form {'a 1 'b 2} '(+ a b))
;; (let [a 1 b 2] (+ a b))
  \end{clojure}
\end{english}

Если выполнить результат в \code{eval}, получим 3. Однако более сложные примеры не сработают. Предположим, одна из переменных содержит список~--- не вектор, а именно список чисел:

\begin{english}
  \begin{clojure}
(make-eval-form {'numbers (list 1 2 3)}
                '(count numbers))
  \end{clojure}
\end{english}

В результате получится форма:

\begin{english}
  \begin{clojure}
(let [numbers (1 2 3)]
  (count numbers))
  \end{clojure}
\end{english}

Компилятор не сможет вычислить \code{(1 2 3)}, потому что 1 не является функцией. Чтобы список остался списком, он должен предстать в виде \code{(list 1 2 3)}, что требует лишних усилий.

Еще одна ловушка кроется в представлении значений: не все из них могут быть прочитаны парсером Clojure. Например, если напечатать вектор \code{[1 2 3]}, получим строку, которую можно вставить в код. В широком смысле представление вектора совпадает с его синтаксисом. То же самое относится к словарю и простым типам: числам, строкам, кейвордам. Каждый из них выглядит так же, как в коде.

Однако другие классы представляют объект строкой, которая нарушает синтаксис Clojure. Примером служит класс \code{File}:

\begin{english}
  \begin{clojure}
(new java.io.File "test.txt")
;; #object[java.io.File 0x3c4b88d3 "test.txt"]
  \end{clojure}
\end{english}

Очевидно, строку \code{\#object[java.io.File ... "test.txt"]} нельзя вычислить в REPL. Выражение с переменной \code{file} как в примере ниже:

\begin{english}
  \begin{clojure}
(make-eval-form
 {'file (new java.io.File "test.txt")}
 '(.getAbsolutePath file))
  \end{clojure}
\end{english}

даст форму, несовместимую с eval:

\begin{english}
  \begin{clojure}
(let [file #object[java.io.File 0x4e293fac "test.txt"]]
  (.getAbsolutePath file))
  \end{clojure}
\end{english}

Чтобы избежать ошибки, идут на интересный трюк. В правой части вектора \code{let} помещают не значение, а код, который получает его из некоего источника. Теперь не нужно опасаться, что объект \code{File} вызовет ошибку синтаксиса:

\begin{english}
  \begin{clojure}
(eval '(let [file (get ... 'file)]
         (slurp file)))
  \end{clojure}
\end{english}

Осталось понять, чем является источник. Подойдет глобальная динамическая переменная \code{*locals*}, которую временно связывают с локальными переменными. Это еще одна тонкость функции \code{eval}: она игнорирует локальные переменные, но учитывает динамические. Проверим это на примере:

\begin{english}
  \begin{clojure}
(def ^:dynamic *num* 0)

(binding [*num* 3]
  (eval '(* *num* *num*)))
;; 9
  \end{clojure}
\end{english}

Объявим приватную динамическую переменную \code{*locals*}:

\begin{english}
  \begin{clojure}
(def ^:dynamic ^:private
  *locals* nil)
  \end{clojure}
\end{english}

С ней новая версия \code{eval+} выглядит так:

\begin{english}
  \begin{clojure}
(defn eval+ [ns locals form]
  (binding [*locals* locals
            *ns* ns]
    (eval `(let ~(reduce
                  (fn [result sym]
                    (conj result sym `(get *locals* '~sym)))
                  []
                  (keys locals))
             ~form))))
  \end{clojure}
\end{english}

Внутренняя форма \code{reduce} производит вектор связывания, который становится частью \code{let}. Обратите внимание, что значения переменных не участвуют в коде~--- нужны только их имена, чтобы составить пары вида \code{[x (get *locals* x)]}. Поэтому в \code{reduce} передаются ключи локальных переменных (форма \code{(keys locals)}). Вот что построит \code{reduce} для переменных \code{a} и \code{b}:

\begin{english}
  \begin{clojure}
[a (get *locals* 'a)
 b (get *locals* 'b)]
  \end{clojure}
\end{english}

Теперь когда функция \code{eval+} готова, перейдем к последнему шагу~--- напишем свой отладчик для Clojure.

\subsubsection{Отладчик своими руками}

Наш отладчик представлен макросом \code{break}, который работает как точка останова. Он принимает форму и запускает внутренний REPL. Выполнение формы откладывается, и пользователю доступны команды: справка, просмотр переменных, выполнение кода. При выходе из отладки управление переходит к форме. Вот как это выглядит в коде:

\begin{english}
  \begin{clojure}
(let [a 1
      b 2]
  (break (+ a b)))
;; 3
  \end{clojure}
\end{english}

Перед вычислением \code{(+ a b)} запустится REPL, в котором доступны переменные \code{a} и \code{b}. Когда отладка закончена, получим результат 3.

Отладчик предваряет форму функцией \code{break-inner}, которая принимает пространство и локальные переменные. Функция \code{break-inner} работает как внутренний REPL с той особенностью, что некоторый ввод считается командой. Пока что реализуем четыре команды: печать локальных переменных, выполнение кода, справку и выход.

\begin{english}
  \begin{clojure}
(defmacro break [form]
  `(do
     (break-inner *ns* (get-locals))
     ~form))
  \end{clojure}
\end{english}

Договоримся о синтаксисе: ввод \code{!locals} означает вывести локальные переменные; по команде \code{!exit} отладка завершается. Символ \code{!help} служит для справки. Все остальное отладчик воспринимает как код, который нужно выполнить. Вот как выглядит \code{break-inner}:

\begin{english}
  \begin{clojure}
(defn break-inner [ns locals]
  (loop []
    (let [input (read-line)
          form (read-string input)]
      (if (= form '!exit)
        (println "Bye")
        (let [result
              (case form
                !locals locals
                !help "Help message..."
                (eval+ ns locals form))]
          (println result)
          (recur))))))
  \end{clojure}
\end{english}

Добавьте макрос \code{break} в любом месте кода и запустите его. Он сработает как точка останова в IDЕ: код прервется, и вы окажетесь в отладке. Приведем сеанс отладчика с простой формой \code{let}:

\begin{english}
  \begin{clojure}
(let [a 1 b 2]
  (break (+ a b)))

=> a
1

=> b
2

=> (+ a a b b)
6

=> !locals
{a 1, b 2}

=> !help
Help message...

=> !exit
3
  \end{clojure}
\end{english}

Команда \code{!exit} завершит отладку, и вы получите результат \code{let}~--- число 3.

Примените к отладчику улучшения, что мы рассмотрели в начале главы: печать при помощи \code{pprint}, перехват исключений, переменные \code{*1}, \code{*2}, \code{*3} и \code{*e} и все остальное.

Недостаток брейкпоинта в том, что он принимает команды только с клавиатуры. Продвинутая версия должна использовать сетевой протокол или графический интерфейс. В случае с сетью отладчик можно совместить с nREPL. Понадобится middleware, которое расширит протокол новыми полями и их обработкой.

Для интерфейса можно использовать встроенный пакет Swing или веб-сервер с браузером. В момент отладки запускается локальный HTTP-сервер. Функция \code{browse-url} из модуля \code{clojure.java.browse} открывает браузер по адресу \code{http://127.0.0.1:<port>/debug}. Интерфейс строится на технологиях HTML, CSS и JavaScript. Браузер и сервер обмениваются данными через JSON API.

\subsubsection{Множественная отладка (теория)}

Выше мы покрыли отладкой только одну форму \code{(+ a b)}. На ней исполнение прервется, а затем продолжится. На практике сложный код исследуют по шагам: от одной формы переходят к другой, пока проблема не устранена. Так происходит потому, что порой трудно понять, где именно закралась ошибка. Точку останова ставят приблизительно и шагают по коду, сверяясь с состоянием программы.

Легко написать макрос \code{debug}, который принимает сложную форму и расставляет точки останова в ее содержимом, в том числе вложенным формам. Например, форма \code{let} со сложением двух чисел после обработки макросом выглядит так:

\begin{english}
  \begin{clojure}
(let [a (break 1)   ;; 1
      b (break 2)]  ;; 2
  (break (+ a b)))  ;; 3
  \end{clojure}
\end{english}

Если ее выполнить, процесс станет похож на настоящую отладку. Сперва вы окажетесь в первой точке \code{(break 1)}. В этот момент не доступна ни одна локальная переменная. В точке \code{(break 2)} появится доступ к переменной \code{a}. Выйдя из нее, вы окажетесь в третьей точке, где доступны \code{a} и \code{b}. Покинув третью точку, вы получите результат 3.

Обратите внимание, что в \code{let} нельзя оборачивать левую часть связывания. Если сделать как в примере ниже, получим ошибку синтаксиса:

\begin{english}
  \begin{clojure}
(let [(break a) (break 1)
      (break b) (break 2)]
  (break (+ a b)))
  \end{clojure}
\end{english}

\code{Let}, точнее ее внутренний вариант \code{let*}, относится к особым формам, синтаксис которых нельзя нарушать. Похоже устроены формы \code{def}, \code{defn}, \code{if} и другие. Некоторые их элементы опорные, потому что на них полагается парсер Clojure.

Мы не будем писать макрос \code{debug}, а только предположим, как он выглядит. Макрос принимает форму и обходит ее сверху вниз. Для обхода и изменения дерева понадобятся модули \code{clojure.walk} или \code{clojure.zip}. Напишем наивную версию макроса:

\begin{english}
  \begin{clojure}
(require '[clojure.walk :as walk])

(defmacro debug [form]
  (walk/postwalk
   (fn wrap [el]
     (list 'break el))
   form))
  \end{clojure}
\end{english}

Проверим, что получится, если передать в макрос форму \code{let}. Для развертки макроса служит функция \code{macroexpand}:

\begin{english}
  \begin{clojure}
(macroexpand
 '(debug
   (let [a 1 b 2]
     (+ a b))))
  \end{clojure}
\end{english}

Результат:

\begin{english}
  \begin{clojure}
(break
 ((break let)
  (break [(break a) (break 1)
          (break b) (break 2)])
  (break ((break +) (break a) (break b)))))
  \end{clojure}
\end{english}

На выходе форма \code{let}, где каждый элемент покрыт точкой останова. Очевидно, мы перестарались, потому что в таком виде результат нельзя скомпилировать. Функция \code{wrap} из \code{walk/postwalk} должна действовать более тонко. Например, определять формы \code{let}, \code{def}, \code{if} и обрабатывать их особо.

Измените \code{wrap} таким образом, чтобы она опиралась на функции \code{needs-debug?} и \code{wrap-debug}. Первая проверяет, нужно ли оборачивать форму, а вторая делает это с учетом синтаксиса.

\begin{english}
  \begin{clojure}
(fn wrap [el]
  (if (needs-debug? el)
    (wrap-debug el))
  el)
  \end{clojure}
\end{english}

Это нетривиальное задание: с учетом всех тонкостей оно займет несколько экранов. Сделайте так, чтобы код был расширяемым при помощи мультиметода. Начните с форм \code{let} и \code{def}, потому что они встречаются чаще других.

Некоторые формы допускают разную запись. Например, у формы \code{defn} может быть несколько тел, в \code{def} может быть строка документации, pre- и post-проверки и многое другое. Приведите их к единому виду, чтобы не усложнять код проверками if/else. Один из способов это сделать~--- разобрать форму на части функцией \code{conform} из Clojure.spec. Для разбора понадобятся определения; взять их можно из пакета [\code{clojure.core.specs.alpha}][core.specs.alpha], где собраны спеки основных конструкций: \code{ns}, \code{let}, \code{def} и других.

[core.specs.alpha]: https://github.com/clojure/core.specs.alpha

\subsubsection{Отладочный тег}

Макросом \code{(break ...)} будет проще пользоваться, если назначать ему тег \code{\#my/break} или похожий. Вот как это выглядит в коде:

\begin{english}
  \begin{clojure}
(let [a 1 b 2]
  #my/break (+ a b))
  \end{clojure}
\end{english}

Мы добавили пространство \code{my}, потому что тег \code{\#break} уже занят пакетом Cider. Чтобы связать тег с функцией, создайте в директории \code{src} файл \code{data\_readers.clj} с содержимым:

\begin{english}
  \begin{clojure}
{my/break my.namespace/break-reader}
  \end{clojure}
\end{english}

Ключ этого словаря~--- имя тега, а значение~--- полный путь к функции, которая его раскрывает. Функция принимает форму, которая стоит перед тегом и возвращает новую форму. В нашем случае \code{break-reader} обернет форму в \code{break}:

\begin{english}
  \begin{clojure}
(defn break-reader [form]
  `(break ~form))
  \end{clojure}
\end{english}

Проведите эксперименты с тегом \code{\#my/break}. Расставьте их в коде и убедитесь, что отладка запускается. Добавьте в редактор сочетание клавиш, которое ставит тег на текущее место курсора.

\subsection{Отладка в Cider}

Мы исследовали отладку так долго, чтобы читатель убедился: в ней нет никакой магии. Отладчик~--- это код, который внедряется в исходный код и заставляет его работать с паузами. Во время паузы отладчик ждет команду пользователя и исполняет ее.

Теперь когда вы знакомы с самодельным отладчиком, рассмотрим, что предлагает Cider. В нашем распоряжении два тега: \code{\#break} и \code{\#dbg}. Первый тег означает точку останова (брейкпоинт) в месте, где он расположен. Поставьте \code{\#break} в середину произвольного кода. Перед тем как запустить код, выполните его командой \code{cider-eval-...}, иначе эффект не вступит в силу.

Тег \code{\#break} ссылается на функцию \code{breakpoint-reader} из модуля \code{cider.nrepl.middleware.debug}. Она принимает форму и добавляет в ее метаданные особое поле~--- признак отладки. Далее сработает оснащение (или инструментирование)~--- алгоритм, который ищет отмеченные формы и оборачивает их кодом, который запускает отладку.

Когда оснащенный код запущен, в нужных местах он прерывается, и от клиента ожидают команду. Можно узнать локальные переменные, выполнить выражение или перейти к следующей точке. Так продолжается до тех пор, пока код не выполнен целиком.

В Emacs нет графических средств отладки. Информация выводится либо рядом с кодом, либо в отдельных буферах. В режиме отладки файл нельзя редактировать; клавиши не вводят текст, а вызывают команды. Ошибка новичков в том, что, попав в отладку, они нажимают все подряд, и процесс протекает с ошибками. Ниже мы рассмотрим процедуру так, чтобы с вами этого не случилось.

Вернемся к функции \code{get-joke} для поиска шуток. Освежим в памяти ее код:

\begin{english}
  \begin{clojure}
(defn get-joke [lang]
  (let [request
        {:url "https://v2.jokeapi.dev/joke/Programming"
         :method :get
         :query-params {:contains lang}
         :as :json}

        response
        (client/request request)

        {:keys [body]}
        response

        {:keys [setup delivery]}
        body]
    #break
    (format "%s %s" setup delivery)))
  \end{clojure}
\end{english}

Добавьте тег \code{\#break} перед \code{(format ...)} и выполните \code{cider-eval-defun-at-point}. Обратите внимание, что тег может стоять как на одной строке с формой:

\begin{english}
  \begin{clojure}
#break (format ...)
  \end{clojure}
\end{english}

, так или на предыдущей:

\begin{english}
  \begin{clojure}
#break
(format ...)
  \end{clojure}
\end{english}

Плюс второго способа в том, что тег легко удалить командами \code{kill-line} или \code{kill-whole-line}, не затрагивая код.

Запустите функцию с любым аргументом, например \code{(get-joke "python")}. Буфер перейдет в режим отладки. Над функцией появится меню действий. Это команды \code{continue}, \code{next}, \code{locals} и другие, которые мы рассмотрим позже. После стрелки \code{=>} показан результат формы, на который вы остановились.

\begin{english}
  \begin{text}
continue next in out here eval inspect locals inject stacktrace trace quit
(defn get-joke [lang]
  (let [request
        {:url "https://v2.jokeapi.dev/joke/Programming"
         :method :get
         :query-params {:contains lang}
         :as :json}

        response
        (client/request request)

        {:keys [body]}
        response

        {:keys [setup delivery]}
        body]
    #break
    (format "%s %s" setup delivery)))
 => "why do python programmers wear glasses? Because they can't C#."
  \end{text}
\end{english}

В режиме отладки Emacs прослушивает клавиши \code{c}, \code{n}, \code{l} и другие, связанные с отладкой. Например, \code{l} (locals) покажет локальные переменные. Нажмите ее, и появится буфер с содержимым:

\begin{english}
  \begin{text}
Class: clojure.lang.PersistentArrayMap
Contents:
  body = { :category "Programming", :delivery "Because they can't C#.", :type "twopart", :setup "why do python programmers wear glasses?", :lang "en", ... }
  response = { :cached nil, :request-time 285, :repeatable? false, :protocol-version { :name "HTTP", :major 1, :minor 1 }, :streaming? true, ... }
  request = { :url "https://v2.jokeapi.dev/joke/Programming", :method :get, :query-params { :contains "python" }, :as :json }
  delivery = "Because they can't C#."
  lang = "python"
  setup = "why do python programmers wear glasses?"
  \end{text}
\end{english}

Команда \code{p} (inspect) исследует значение под курсором. Если нажать \code{p}, откроется буфер:

\begin{english}
  \begin{text}
Class: java.lang.String
Value: "why do python programmers wear glasses? Because they can't C#."
  \end{text}
\end{english}

Клавиша \code{P} исследует произвольное значение. По ее нажатию Emacs запросит значение в минибуфере ввода. Введите \code{response}, чтобы исследовать ответ сервера:

\begin{english}
  \begin{text}
Class: clojure.lang.PersistentHashMap
Contents:
  :cached = nil
  :request-time = 285
  :repeatable? = false
  :protocol-version = { :name "HTTP", :major 1, :minor 1 }
  :streaming? = true
  :http-client = org.apache.http.impl.client.InternalHttpClient@284cd4fa
  :chunked? = false
  :reason-phrase = "OK"
  :headers = { "ratelimit-remaining" "118", "referrer-policy" "no-referrer, strict-origin-when-cross-origin", "access-control-allow-headers" "*", "Server" "cloudflare", "ratelimit-limit" "120", ... }
  :orig-content-encoding = nil
  :status = 200
  :length = 401
  :body = { :category "Programming", :delivery "Because they can't C#.", :type "twopart", :setup "why do python programmers wear glasses?", :lang "en", ... }
  :trace-redirects = []
  \end{text}
\end{english}

Поле \code{:body} не уместилось целиком. Подведите курсор к фигурным скобкам и нажмите Enter~--- оно откроется во вложенном буфере:

\begin{english}
  \begin{text}
Class: clojure.lang.PersistentHashMap
Contents:
  :category = "Programming"
  :delivery = "Because they can't C#."
  :type = "twopart"
  :setup = "why do python programmers wear glasses?"
  :lang = "en"
  :id = 294
  :error = false
  :safe = true
  :flags = { :nsfw false, :religious false, :political false, :racist false, :sexist false, ... }
  \end{text}
\end{english}

Команда eval (клавиша \code{e}) выполнит произвольный код. Cider запросит его в минибуфере:

\begin{english}
  \begin{text}
Expression to evaluate: (keys body)
=> (:category :delivery :type :setup ...)
  \end{text}
\end{english}

Недостаток минибуфера в том, что он принимает текст в одну строку и поэтому не подходит для сложных выражений.

Клавиша \code{s} (stacktrace) открывает стек вызовов. С его помощью мы узнаем, как пришли в текущее место. Вывод ниже, хоть и кажется шумным, верно показывает историю вызовов. Сократим его, оставив только значимую часть:

\begin{english}
  \begin{text}
    debug.clj:  294  cider.nrepl.middleware.debug/debug-stacktrace
    debug.clj:  368  cider.nrepl.middleware.debug/read-debug-command
    debug.clj:  519  cider.nrepl.middleware.debug/break
         REPL:  128  sample/get-joke
         REPL:   78  sample/eval9967
Compiler.java: 7131  clojure.lang.Compiler/eval
     core.clj: 3210  clojure.core/eval
  \end{text}
\end{english}

Мы вызвали в REPL форму \code{(get-joke "python")}, что соответствует \code{sample/eval9967}. Далее шагнули в функцию \code{sample/get-joke}. Функция оснащена отладкой, поэтому в ней был макрос, который вызывает \code{break}. В функции \code{break} случился вызов \code{read-debug-command}, которая отвечает за обработку команды отладчика. По нажатию \code{s} и поступила команда на вывод стектрейса. Этим занимается функция \code{debug-stacktrace}, которая оказалась последней (на вершине стека).

Клавиша \code{q} (quit) завершит отладку, и код выполнится до конца без остановок.

Кроме перечисленных команд, доступны навигация, изменение локальных переменных, трассировщик и многое другое. Кое-что из этого мы рассмотрим ниже.

Когда код отлажен, удалите тег \code{\#break} и выполните форму еще раз. При новом запуске отладки не будет.

Точка останова работает с любыми модулями. По аналогии с печатью (вставкой \code{println}), откройте пространство из jar-файла. Снимите режим "только для чтения", добавьте тег \code{\#break} в нужную функцию и выполните ее на сервере. Запустите код, который вызывает эту функцию, и вы окажетесь в отладке.

Кроме \code{\#break}, Cider предлагает \code{\#dbg}~--- более мощный тег, который поддерживает навигацию по коду. Под навигацией имеют в виду команды next (переход к следующей форме), step in (шаг внутрь), step out (выход из текущей формы), продолжение до курсора и другие. Подход напоминает отладку в современных IDE.

"Зарядите" функцию отладкой, поставив перед формой \code{(defn ...)} тег \code{\#dbg}. Чтобы не смещать код вправо, расположите его отдельной строке выше:

\begin{english}
  \begin{clojure}
#dbg
(defn get-joke [lang]
  ...)
  \end{clojure}
\end{english}

Того же эффекта можно добиться командой \code{cider-debug-defun-at-point}; курсор может быть в любом месте формы. Команда ведет себя так, словно перед функцией (макросом, переменной) указан тег \code{\#dbg}. Когда функция заряжена, запустите еще:

\begin{english}
  \begin{clojure}
(get-joke "C#")
  \end{clojure}
\end{english}

Вы окажетесь в отладке, но не в конце функции, где раньше стоял \code{\#break}, а на этапе вычисления \code{request}. Обозначим комментарием вашу позицию:

\begin{english}
  \begin{clojure}
(defn get-joke [lang]
  (let [request
        {:url "https://v2.jokeapi.dev/joke/Programming"
         :method :get
         :query-params {:contains lang} => "C#" ;; <
         :as :json}
  \end{clojure}
\end{english}

Из локальных переменных доступна только \code{lang}. Нажмите \code{n} (next), и управление перейдет к отправке запроса:

\begin{english}
  \begin{clojure}
response
(client/request request) => {:url "https:..." :method :get ...} ;; <
  \end{clojure}
\end{english}

Справа от стрелки показано значение текущей формы, в нашем случае \code{request}. Продолжайте отладку нажатием \code{n}, и постепенно вы обойдете всю функцию. В теле \code{(format ...)} будет две точки останова: на месте \code{setup} и \code{delivery}. Обозначим их вертикальной чертой:

\begin{english}
  \begin{clojure}
(format "%s %s" setup| delivery) => "Why do programmers wear glasses?"
(format "%s %s" setup delivery|) => "Because they need C#"
  \end{clojure}
\end{english}

Перечислим другие команды навигации. Наиболее важные из них это in (ступить на уровень ниже) и out (подняться выше). Запустите отладку еще раз и дождитесь, пока курсор не окажется на форме \code{(client/request ...)}. Нажмите \code{i}, чтобы управление перешло в функцию \code{request} из модуля \code{clj-http.client}. Вызвав \code{in} несколько раз, вы окажетесь на нижнем уровне HTTP-запроса~--- в функции \code{request} из \code{clj-http.core}. С помощью \code{l} (locals) исследуйте локальные переменные, доступные в этой области. Последующие команды o (out) постепенно вернут вас на уровень \code{get-joke}.

Отладку сложно передать словами, и мы советуем читателю закрепить ее практикой.

Заглянем в технические недра отладки. Тег \code{\#dbg} устроен как множество точек остановки. Если предварить тегом форму, он расставит в ней столько точек, сколько это возможно. Каждая точка знает свой уровень вложенности, что важно для навигации. За счет этого можно пропустить точки текущего уровня, ступить ниже или выше.

Отладка работает в несколько этапов. Теги \code{\#break} и \code{\#dbg} помечают метаданные формы особым ключом. Убедимся в этом функцией \code{meta}:

\begin{english}
  \begin{clojure}
(-> "#break (+ 1 2)"
    read-string
    meta)

#:cider.nrepl.middleware.util.instrument
{:breakfunction
 #'cider.nrepl.middleware.debug/breakpoint-with-initial-debug-bindings}
  \end{clojure}
\end{english}

Далее форма попадает в функцию \code{instrument-tagged-code}, которая оснащает ее~--- внедряет код для взаимодействия с пользователем.

\begin{english}
  \begin{clojure}
(cider.nrepl.middleware.util.instrument/instrument-tagged-code
 (read-string "#break (+ 1 2)"))
  \end{clojure}
\end{english}

Результат для помеченной формы:

\begin{english}
  \begin{clojure}
(#'cider.nrepl.middleware.debug/breakpoint-with-initial-debug-bindings
 (+ 1 2)
 {:coor []}
 (+ 1 2))
  \end{clojure}
\end{english}

Вместо \code{(+ 1 2)} получили вызов макроса \code{breakpoint-with-initial-debug-bindings} с тремя аргументами. Это форма вычисления, состояние отладчика и первичная форма. В нашем случае первый и третий параметры одинаковы, но на практике бывает обратное: из-за раскрытия макросов форма вычисляется не так, как мы ее видим.

Состояние отладчика изначально пустое. В поле \code{:coor} хранятся координаты формы, необходимые для переходов.

Проверим, что станет с функцией при оснащении ее отладкой. Для этого вызовем \code{instrument-tagged-code} с формой, покрытой тегом \code{\#dbg}:

\begin{english}
  \begin{clojure}
(require
 '[cider.nrepl.middleware.util.instrument :refer [instrument-tagged-code]])

(instrument-tagged-code
 (read-string "#dbg (defn add [a b] (+ a b))"))
  \end{clojure}
\end{english}

Результат получился объемный. Чтобы сократить его, заменим пространство \code{cider.nrepl.middleware.debug} на сочетание \code{c.n.m.d}:

\begin{english}
  \begin{clojure}
(#'c.n.m.d/breakpoint-with-initial-debug-bindings
 (def
  add
  (fn*
   ([a b]
    (#'c.n.m.d/breakpoint-if-interesting
     (+
      (#'c.n.m.d/breakpoint-if-interesting
       a
       {:coor [3 1]}
       a)
      (#'c.n.m.d/breakpoint-if-interesting
       b
       {:coor [3 2]}
       b))
     {:coor [3]}
     (+ a b)))))
 {:coor []}
 (defn add [a b] (+ a b)))
  \end{clojure}
\end{english}

Обратите внимание, что форма \code{(defn ...)} превратилась в комбинацию \code{(def ...)} и \code{(fn* ...)}. В общем плане это явление называют раскрытием макросов. Раскрытие необходимо, чтобы расставить как можно больше точек останова. Третьим аргументом указана исходная форма \code{(defn ...)}. Она нужна, чтобы сопоставить отладку с кодом как мы его видим в редакторе.

Расстановка точек останова учитывает формы, синтаксис которых нельзя нарушать. Например, в объявлении функции нетронуты ее название и вектор аргументов. В форме \code{let} предваряются только правые элементы (значения) и так далее.

Макрос \code{breakpoint-if-interesting} называется так потому, что не каждая форма нуждается в точке останова. В следующем разделе мы коротко рассмотрим, что именно не подлежит отладке.

Cider запоминает, какие функции оснащены отладкой. По команде \code{M-x cider-browse-instrumented-defs} вы увидите их список. Протоколы и типизированные записи тоже работают с отладкой, но в отличии от функций не видны в этом списке.

\subsubsection{Ограничения}

Чтобы пользоваться отладчиком эффективно, важно знать его особенности. Прежде всего, Cider не ставит точки останова перед литералами, которые выражаются в сами себя: числами, строками, кейвордами. Сравним отладку вектора с символами:

\begin{english}
  \begin{clojure}
(instrument-tagged-code
 (read-string "#dbg [a b c]"))

[(#'.../breakpoint-if-interesting a {:coor [0]} a)
 (#'.../breakpoint-if-interesting b {:coor [1]} b)
 (#'.../breakpoint-if-interesting c {:coor [2]} c)]
  \end{clojure}
\end{english}

и литералами:

\begin{english}
  \begin{clojure}
(instrument-tagged-code
 (read-string "#dbg [1 \"hello\" :foobar]"))

[1 "hello" :foobar]
  \end{clojure}
\end{english}

В первом случае точки оказались перед каждым элементом. Во втором вектор остался не тронут.

Множества не поддаются отладке. Аналогично ведут себя словари длиннее восьми элементов.

\begin{english}
  \begin{clojure}
(instrument-tagged-code
 (read-string "#dbg #{a b c d e}"))
#{a e c b d}
  \end{clojure}
\end{english}

Трудности могут возникнуть с рекурсией (формы \code{loop} и \code{recur}). Компилятор требует, чтобы \code{recur} была строго в конце \code{loop}, но при установке точек это правило нарушается. Например, вместо \code{(recur (inc x))} образуется код:

\begin{english}
  \begin{clojure}
(#'c.n.m.d/breakpoint-if-interesting
 (recur (inc x))
 {:coor [3 2]}
 (recur (inc x)))
  \end{clojure}
\end{english}

Чтобы не вызвать ошибку компиляции, отладчик не ставит точку перед \code{recur}. В примере ниже тег \code{\#break} не имеет эффекта:

\begin{english}
  \begin{clojure}
(loop [x 0]
  #break
  (when (< x 10)
    (println x)
    (recur (inc x))))
  \end{clojure}
\end{english}

\subsubsection{Итог}

Отладчик чрезвычайно полезен в работе. Тому, кто им овладел, легче понять запутанный код, проще решить сложную ситуацию. Однако отладчик требует времени и сил. Отложите его до лучших времен, если не полностью уверены в REPL и Emacs. На первых порах достаточно печати и инспекции.

[bogus]: https://github.com/igrishaev/bogus

Некоторые библиотеки предлагают свои отладчики. Коротко рассмотрим их.

Библиотека [Bogus][bogus] появилась по мере написания этой книги. Ее тег \code{\#bogus} открывает окно Swing, где доступны локальные переменные и выполнение кода. Bogus можно считать минимальным графическим отладчиком для Clojure.

[scope-capture]: https://github.com/vvvvalvalval/scope-capture
[scope-capture-nrepl]: https://github.com/vvvvalvalval/scope-capture-nrepl

Библиотека [scope-capture][scope-capture] служит для работы с локальными переменными. Кроме просмотра и отладки, можно сохранить их в файл и позже воссоздать для участка кода. Scope-capture сочетается с nREPL при помощи отдельной библиотеки [scope-capture-nrepl][scope-capture-nrepl].

[clj-debugger]: https://github.com/razum2um/clj-debugger

Еще один отладчик для Clojure называется [clj-debugger][clj-debugger]. Он устроен как REPL, в котором доступны локальные переменные, выполнение кода и другие возможности.

Даже уделив отладчику Cider столько времени, мы не покрыли его целиком. В числе прочего мы не коснулись профилировщика (profiler) и трассировщика (tracing). Первый служит для поиска медленного кода. Профилировщик оборачивает функции в макрос, который собирает метрики и выводит сводную таблицу. В ней указано, сколько времени занял код в целом и функции по отдельности.

Трассировщик анализирует стек вызовов. В нем указано, в каком порядке вызывались функции, их аргументы и промежуточные результаты. Трассировщик крайне полезен в цикле и рекурсии. Предоставим читателю самому разобраться с этими инструментами.

На этом мы закончим тему отладки и двинемся дальше: рассмотрим способы необычного подключения к nREPL.

\subsection{nREPL в Docker}

Чтобы запустить проект на Clojure, устанавливают Java SDK, утилиты lein, Clojure CLI, maven и другие. Они написаны на Java и работают на всех платформах, потому с окружением редко бывают проблемы. Если все-таки вы не можете что-то установить, остается запасной вариант~--- запустить проект в Docker.

Программу Docker мы упоминали в первой книге, поэтому не будем разбирать все сначала. Запуск проекта в контейнере сводится к шагам:

[docker-hub]: https://hub.docker.com/\_/clojure

1. Скачать образ с нужной версией Java, lein, deps.edn и прочими утилитами. [Репозиторий Clojure][docker-hub] на Docker Hub предлагает более сотни образов с различными SDK, утилитами и их версиями.

2. При запуске образа смонтировать в него папку проекта и указать ее как рабочую (work dir).

3. Сопоставить локальный порт nREPL с портом в Docker. В настройках nREPL явно указать порт.

4. Запустить образ и подключиться к локальному порту из Emacs.

Пройдя эти шаги, вы получите работающий nREPL, при этом в системе не останется следов установки Java и прочего.

Подготовим проект к запуску в Docker. Откройте файл \code{project.clj} и добавьте профиль \code{:docker} с настройками как в примере ниже. Профиль нужен, чтобы не нарушить запуск проекта в обычном режиме.

\begin{english}
  \begin{clojure}
:profiles
{:docker
 {:repl-options {:port 9911
                 :host "0.0.0.0"}
  :plugins [[cider/cider-nrepl "0.28.3"]]}}
  \end{clojure}
\end{english}

Обратите внимание, что мы указали хост и порт явным образом. Если бы хост был \code{127.0.0.1} или \code{localhost}, к нему нельзя было бы подключиться извне сети Docker. То же самое относится к порту: он должен быть известен заранее, чтобы объявить его в списке открытых (exposed) портов.

Команда для запуска образа:

\begin{english}
  \begin{bash}
docker run -it~---rm \
  -p 9911:9911 \
  -v `pwd`:/project \
  -w /project \
  clojure \
  lein with-profile +docker repl
  \end{bash}
\end{english}

Прокомментируем основные моменты:

(1) аргумент \code{-p} сопоставляет внутренний порт контейнера с портом операционной системы. Чтобы избежать путаницы, мы указали одинаковые значения. Позже мы рассмотрим случай, когда порты отличаются.

(2) Опция \code{-v} (volume) сопоставляет пути локальной машины и контейнера. Выше мы смонтировали папку с проектом на путь \code{/project} в контейнере. Docker требует абсолютный путь, поэтому нельзя указать его точкой (например, \code{-v .:/project}). Выражение \code{pwd} в обратных кавычках выполняет \code{pwd} в отдельном шелле и поставляет результат. В случае автора это следующий путь:

\begin{english}
  \begin{text}
/Users/ivan/work/book-sessions/repl-chapter
  \end{text}
\end{english}

Проект окажется в папке контейнера \code{/project}. Важно понимать разницу в монтировании и копировании файлов. В первом случае файлы остаются на локальной машине, а контейнер получает к ним доступ. Изменения с файлами, проделанные в контейнере, видны локальной системе и наоборот. Например, если код в контейнере создает файлы, вы увидите их локально. Если же скопировать файлы в контейнер, они будут жить отдельно от оригиналов, что помешает разработке.

(3) Параметр \code{clojure} означает имя образа. Он указан без тега, и по умолчанию будет использован тег \code{latest}. На момент написания книги \code{latest} включает в себя OpenJDK 17, Clojure 1.11.1 и lein 2.9.8. С выходом новых версий тег \code{latest} будет перезаписан. Изменится его отпечаток, что приведет к повторному скачиванию. Чтобы этого избежать, задайте образ явно, например \code{clojure:openjdk-17-lein-2.9.6}.

(4) Выражение \code{lein with-profile +docker repl} означает команду, которую выполнит контейнер после запуска. По умолчанию она равна \code{lein run}, но мы указали \code{lein repl} с профилем \code{docker}, в котором особые настройки nREPL.

Очевидно, набрать команду \code{docker run} в учетом всех аргументов трудно. Запишите ее в шелл-скрипт или добавьте цель в \code{Makefile}.

Когда контейнер запущен, перейдите в Emacs и откройте любой файл проекта. Подключитесь к nREPL следующим образом:

\begin{english}
  \begin{text}
M-x cider-connect RET 127.0.0.1 RET 9911 RET
  \end{text}
\end{english}

В папке проекта появится файл \code{.nrepl-port}. Он создан внутри контейнера, но из-за монтирования путей доступен снаружи. При подключении к nREPL сработает автодополнение: когда редактор запросит порт, нажмите TAB, и появится вариант с портом 9911.

Дальнейшие шаги аналогичны тем, что мы рассмотрели выше. Загрузите пространства командой \code{cider-ns-refresh}. Выполните несколько функций или тестов. Проверьте функцию \code{get-joke}~--- сработает HTTP-запрос к сервису \code{v2.jokeapi.dev}.

[cgroups]: https://en.wikipedia.org/wiki/Cgroups

Когда проект запущен в Docker, вы заметите легкую задержку на каждое действие. В системах, отличных от Linux, задержка будет ощутимой. Причина в том, что контейнер запускается не в [cgroups][cgroups] (встроенной возможности Linux), а в виртуальной машине, накладные расходы на которую выше. За абстракцию приходится платить ресурсами.

Запуск проекта в Docker~--- тот случай, когда команда \code{cider-connect} необходима. Вы как будто подключаетесь к удаленной машине, хоть она и запущена локально.

Docker особенно полезен для систем интеграции (Continuous Integration, CI). С его помощью прогоняют тесты и собирают проект. Если ставить на каждой машине Java и утилиты, это займет время. Иногда нужны разные версии SDK, чтобы проверить совместимость. Их совместная установка ведет к ошибкам путей и окружения, которые трудно расследовать. Docker сводит эти факторы на нет: достаточно сменить имя образа.

Теперь улучшим конфигурацию Docker по некоторым пунктам.

\textbf{Зависимости.} При запуске проекта \code{lein} скачает библиотеки из Clojars и Maven Central:

\begin{english}
  \begin{text}
Retrieving cider/cider-nrepl/0.28.3/cider-nrepl-0.28.3.pom from clojars
Retrieving nrepl/nrepl/0.9.0/nrepl-0.9.0.pom from clojars
Retrieving cider/cider-nrepl/0.28.3/cider-nrepl-0.28.3.jar from clojars
Retrieving nrepl/nrepl/0.9.0/nrepl-0.9.0.jar from clojars
Retrieving clj-http/clj-http/3.9.1/clj-http-3.9.1.pom from clojars
...
  \end{text}
\end{english}

Однако при следующем запуске загрузка начнется опять, что отнимает время и трафик. Хотелось бы, чтоб это был разовый шаг.

Причина в том, что по умолчанию зависимости оседают в папке контейнера \code{/root/.m2}. Поскольку контейнер не имеет состояния, при новом запуске папка окажется пуста, что вынудит lein скачать зависимости. Проблему решают двумя способами:

1. Сопоставьте локальный путь Maven с папкой контейнера. Для этого добавьте в команду \code{docker run...} параметр \code{-v ~/.m2:/root/.m2}. Теперь зависимости, загруженные локально, будут видны в Docker и наоборот.

2. Добавьте в профиль \code{:docker} опцию \code{:local-repo}, которая меняет стандартный путь Maven.

\begin{english}
  \begin{clojure}
{:profiles
 {:docker {:local-repo ".docker/m2"}}}
  \end{clojure}
\end{english}

При запуске \code{docker run} будет создана папка \code{.docker/m2}, куда Maven скачает jar-файлы. Во второй раз проект подхватит их без новой загрузки. Добавьте путь \code{.docker/m2} в \code{.gitignore}, чтобы случайно не добавить зависимости в историю репозитория.

\textbf{Локальный профиль.} Выше мы несколько раз упоминали файл \code{~/.lein/profiles.clj}, который хранит локальные профили. Мы поместили в него зависимость \code{cider/cider-nrepl} и другие служебные библиотеки. Хотелось бы, чтобы Docker подхватил этот файл. Добавьте сопоставление путей:

\begin{english}
  \begin{clojure}
docker run ... -p ~/.lein/profiles.clj:/etc/leiningen/profiles.clj
  \end{clojure}
\end{english}

Теперь плагин \code{cider/cider-nrepl} можно удалить из профиля \code{:docker}~--- он будет прочитан из файла \code{profiles.clj}. Утилита \code{lein} проверяет путь \code{/etc/leiningen/} на наличие профилей и загружает их.

Следующее улучшение~--- сделать так, чтобы \textbf{порт nREPL} можно было задать произвольно. На текущий момент порт "захардкожен", что не совсем удобно. Исправим это в несколько этапов. Во-первых, укажем, что порт приходит их переменной среды \code{NREPL\_PORT}:

\begin{english}
  \begin{clojure}
:repl-options
{:port ~(some-> "NREPL_PORT" System/getenv Integer/parseInt)
 :host "0.0.0.0"}
  \end{clojure}
\end{english}

Если переменная не задана, форма \code{(some-> ...)} вернет \code{nil}, и будет выбран случайный порт. Объявим в терминале переменную с желаемым портом:

\begin{english}
  \begin{bash}
export NREPL_PORT=9955
  \end{bash}
\end{english}

Доработаем команду \code{docker run}: в сопоставлении портов заменим значение на переменную. Доллар перед переменной означает вернуть ее значение. Кроме портов (параметр \code{-p}), переменную нужно передать параметром \code{-e}, чтобы сделать ее доступной контейнеру.

\begin{english}
  \begin{clojure}
docker run ... -p $NREPL_PORT:$NREPL_PORT -e NREPL_PORT=$NREPL_PORT ...
  \end{clojure}
\end{english}

Подключитесь из редактора к порту 9955, и вы окажетесь в рабочем сеансе. По аналогии запустите контейнер с другим портом.

[docker-compose]: https://docs.docker.com/compose/

Еще один способ упростить работу с Docker~--- \textbf{составить конфигурацию} для [Docker Compose][docker-compose]. Эта программа, которая запускает контейнеры по описанию на языке YAML. С ней не нужно запоминать все параметры \code{docker run}. Создайте файл \code{docker-compose.yaml}:

\begin{english}
  \begin{yaml}
version: '3.8'
services:
  nrepl:
    container_name: my_project
    image: clojure
    volumes:
      - .:/project
    ports:
      - $NREPL_PORT:$NREPL_PORT
    environment:
      NREPL_PORT: $NREPL_PORT
    working_dir: /project
    command: ["lein", "with-profile", "+docker", "repl", ":headless"]
  \end{yaml}
\end{english}

Выполните команду ниже, после чего подключитесь к сеансу nREPL в Docker.

\begin{english}
  \begin{bash}
> docker-compose up
  \end{bash}
\end{english}

Обратите внимание на аргумент \code{:headless} команды \code{lein repl}. С ним nREPL запускается в "безголовом" режиме, когда ввода с клавиатуры нет, а обмен происходит только по сети. Если не добавить \code{:headless}, nREPL завершится с ошибкой, потому что стандартный источник ввода (stdin) будет недоступен.

Docker крайне полезен для разработки, прогона тестов и сборки проекта. В проектах, где участвуют базы данных, очереди задач и другие сервисы, работа без него практически невозможна.

\subsection{nREPL в боевом режиме}

Необычный вопрос: как подключиться к проекту, который уже развернут и обслуживает пользователей? Тема противоречива: с одной стороны, прием опасен и считается плохой практикой. С другой стороны, об этом часто спрашивают новички, и уходить от вопроса неправильно.

Когда проект запущен локально при помощи \code{lein repl}, подключение работает как обычно. Однако если собрать и запустить jar-файл, в нем не будет сервера nREPL. Так происходит потому, что nREPL запускается силами \code{lein}. Считайте его вспомогательным средством, доступным только в разработке.

Когда на сервере случается ошибка, у новичка возникает шальная мысль: если бы можно было подключиться, я бы все исправил. И хотя это возможно технически, предостережем читателя от такого подхода.

Ошибки на сервере говорят о том, что код недостаточно покрыт тестами. Если код завершился аварийно, повторите ситуацию локально и добавьте тест. Чаще всего причина в том, что из источников приходят не те данные, что ожидали. Например, сервис \code{jokeapi.dev} изменил структуру ответа, и теперь нужные поля не подхватываются. Добавьте отладочный лог как в примере ниже:

\begin{english}
  \begin{clojure}
(defn get-joke [lang]
  (let [request
        {...}

        response
        (client/request request)

        {:keys [body]}
        response

        _ (log/debugf "Data from jokeapi.dev: %s" body)

        {:keys [setup delivery]}
        body]
    (format "%s %s" setup delivery)))
  \end{clojure}
\end{english}

Измените настройки так, чтобы логи с уровнем \code{debug} оседали в файле. Перезапустите проект. Спровоцируйте вызов \code{get-joke}, и вы узнаете, что пришло от сервиса. Исправьте код под новые данные, соберите uberjar и загрузите на сервер.

Если возникло исключение, соберите как можно больше данных о нем. Исключение~--- сложный объект: иногда одно исключение ссылается на второе, то~--- на третье и так далее. В каждом звене нас интересует его класс, сообщение и данные \code{ex-info}. В первой книге мы рассмотрели, как все это собрать куда передать.

Логирование, тесты и сбор ошибок полезней отладки на боевом сервере. За годы работы автор ни разу не подключался продакшену по nREPL~--- в этом не было нужды. Современные практики~--- тесты, логи, CI, деплой~--- в корне противоречат горячей перезагрузке кода~--- приему, когда приложение обновляют в обход стандартных процедур.

[nasa-lisp]: https://thenewstack.io/nasa-programmer-remembers-debugging-lisp-in-deep-space/

Возможно, читатель слышал романтические истории о программистах, которые устраняли катастрофы в другой части света. Например, инженеры NASA [исправили код][nasa-lisp] космического корабля, когда он пролетал мимо Юпитера. Это исключительный случай, и вряд ли в NASA были рады инциденту. Гораздо лучше отловить ошибку до запуска проекта.

Текст ниже предполагает, что автор либо не убедил читателя, либо не знает о случаях, когда nREPL на сервере необходим. Если это так, напишите автору письмо с описанием ситуации, и она займет место в книге.

Итак, чтобы nREPL стал частью приложения, выполните следующее. Сперва переместите пакет \code{nrepl/nrepl} из dev-зависимостей в основные:

\begin{english}
  \begin{clojure}
  :dependencies
  [[org.clojure/clojure "1.10.1"]
   [nrepl/nrepl "0.9.0"]]
  \end{clojure}
\end{english}

Добавьте модуль, который запускает сервер nREPL. В примере ниже функция \code{start-server} включает сервер и возвращает его объект; \code{stop-server} выключает его. Глобальная переменная \code{server} служит для хранения экземпляра.

\begin{english}
  \begin{clojure}
(ns nrepl-prod.core
  (:gen-class)
  (:require
   [nrepl.server :refer [start-server stop-server]]))

(defonce server nil)

(defn nrepl-start! []
  (alter-var-root
   #'server
   (constantly
    (start-server :bind "0.0.0.0" :port 9911))))

(defn nrepl-stop! []
  (alter-var-root #'server stop-server))

(defn -main
  [& _]
  (nrepl-start!)
  (println "The nREPL server has been started"))
  \end{clojure}
\end{english}

Скомпилируйте проект командой \code{lein uberjar}. Готовый jar-файл находится в папке \code{target/uberjar}, если не задано иное опцией \code{:target-path}.

Далее понадобится удаленная машина с доступом по SSH. Для краткости опустим настройку окружения: создание пользователя, sudo, SSH-ключи и прочее. Считаем, вы достигли этапа, когда команда \code{ssh <IP>} открывает сеанс bash на удаленной машине. При этом учетная запись отличается от \code{root}, \code{ubuntu} и прочих системных.

Установите виртуальную машину Java командами:

\begin{english}
  \begin{bash}
> sudo apt update
> sudo apt install default-jre
  \end{bash}
\end{english}

Проверьте установку:

\begin{english}
  \begin{bash}
> java -version
openjdk version "11.0.15" 2022-04-19
  \end{bash}
\end{english}

Загрузите jar-файл на сервер с локальной машины:

\begin{english}
  \begin{bash}
> scp target/uberjar/nrepl_prod-0.1.0-standalone.jar <IP>:/home/<user>/
  \end{bash}
\end{english}

Вернитесь к сеансу SSH. Перейдите в домашнюю папку пользователя и выполните:

\begin{english}
  \begin{bash}
> java -jar nrepl_prod-0.1.0-standalone.jar
  \end{bash}
\end{english}

Появится сообщение, что сервер nREPL запущен. Откройте Emacs и подключитесь к nREPL:

\begin{english}
  \begin{text}
M-x cider-connect <RET> <IP> <RET> 9911 <RET>
  \end{text}
\end{english}

Откроется сеанс nREPL на удаленной машине. Выполните выражение:

\begin{english}
  \begin{clojure}
(.println System/out "hello")
  \end{clojure}
\end{english}

Во вкладке терминала с SSH, где запущен jar-файл, появится "hello". Проверьте переменную \code{server}:

\begin{english}
  \begin{clojure}
(in-ns 'nrepl-prod.core)
server

;; #nrepl.server.Server{...addr=0.0.0.0, localport=9911...}
  \end{clojure}
\end{english}

При помощи функции \code{sh} выполните системную команду на удаленной машине. Это может быть чтение каталога, удаление файлов, сбор информации о системе и много другое.

\begin{english}
  \begin{clojure}
(require '[clojure.java.shell :refer [sh]])
  \end{clojure}
\end{english}

Для начала выполним \code{uname}~--- утилиту, которая выводит сведения об операционной системе:

\begin{english}
  \begin{clojure}
=> (:out (sh "uname" "-a"))

"Linux 5-63-153-107 5.4.0-117-generic #132-Ubuntu SMP Thu Jun 2 00:39:06 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux\n"
  \end{clojure}
\end{english}

Прочитаем корневой каталог командой \code{ls}:

\begin{english}
  \begin{text}
(println (:out (sh "ls" "-l" "/")))

total 60
lrwxrwxrwx   1 root root     7 Jun  9 01:11 bin -> usr/bin
drwxr-xr-x   3 root root  4096 Jun  9 01:18 boot
drwxr-xr-x  19 root root  3840 Jun  9 17:02 dev
drwxr-xr-x  84 root root  4096 Jun  9 17:13 etc
drwxr-xr-x   3 root root  4096 Jun  9 17:06 home
lrwxrwxrwx   1 root root     7 Jun  9 01:11 lib -> usr/lib
lrwxrwxrwx   1 root root     9 Jun  9 01:11 lib32 -> usr/lib32
lrwxrwxrwx   1 root root     9 Jun  9 01:11 lib64 -> usr/lib64
lrwxrwxrwx   1 root root    10 Jun  9 01:11 libx32 -> usr/libx32
drwx------   2 root root 16384 Jun  9 01:10 lost+found
drwxr-xr-x   3 root root  4096 Jun  9 01:10 media
drwxr-xr-x   2 root root  4096 Jun  9 01:12 mnt
drwxr-xr-x   2 root root  4096 Jun  9 01:12 opt
dr-xr-xr-x 140 root root     0 Jun  9 17:02 proc
drwx------   6 root root  4096 Jun  9 19:13 root
drwxr-xr-x  20 root root   600 Jun 11 11:14 run
lrwxrwxrwx   1 root root     8 Jun  9 01:11 sbin -> usr/sbin
drwxr-xr-x   2 root root  4096 Jun  9 01:12 srv
dr-xr-xr-x  13 root root     0 Jun  9 17:02 sys
drwxrwxrwt  13 root root  4096 Jun 11 10:56 tmp
drwxr-xr-x  13 root root  4096 Jun  9 01:12 usr
drwxr-xr-x  11 root root  4096 Jun  9 01:12 var
  \end{text}
\end{english}

После экспериментов с \code{sh} завершите Java-процесс. Выполните \code{(nrepl-stop!)} в пространстве \code{nrepl-prod.core}, и сервер остановится. При этом не останется потоков, которые ожидает главный поток JVM, и процесс завершится.

Итак, подключение к удаленному nREPL прошло успешно. Отложив вопросы безопасности до следующего раздела, рассмотрим, что можно улучшить с технической точки зрения.

На текущий момент наш nREPL "голый", то есть не оснащенный возможностями Cider. Должно быть, при подключении в Emacs вы видели строку:

\begin{english}
  \begin{text}
WARNING: CIDER requires cider-nrepl to be fully functional.
Some features will not be available without it!
  \end{text}
\end{english}

Из-за этого в Cider доступны только базовые команды вроде \code{eval} и \code{lookup}. Чтобы это исправить, добавьте в зависимости библиотеку \code{cider/cider-nrepl}:

\begin{english}
  \begin{clojure}
  :dependencies
  [[org.clojure/clojure "1.10.1"]
   [nrepl/nrepl "0.9.0"]
   [cider/cider-nrepl "0.28.3"]]
  \end{clojure}
\end{english}

Импортируйте ее в наш модуль:

\begin{english}
  \begin{clojure}
(ns nrepl-prod.core
  (:gen-class)
  (:require [cider.nrepl]
            ...))
  \end{clojure}
\end{english}

В функцию \code{start-server} передайте обработчик \code{cider-nrepl-handler}. Это обычный обработчик nREPL, "заряженный" многими middleware Cider:

\begin{english}
  \begin{clojure}
(start-server :bind "0.0.0.0" :port 9911
              :handler cider.nrepl/cider-nrepl-handler)
  \end{clojure}
\end{english}

При новом запуске вы получите доступ ко всем возможностям Cider, что мы рассмотрели: переходу к определениям, тестам, отладке и остальному. Почти все эти средства пригодны только для локальных нужд; на боевом сервере они принесут больше вреда, чем пользы.

\subsubsection{nREPL в системе}

Способ с \code{alter-var-root}, которым мы запускаем nREPL выше, оставляет желать лучшего. Это неуклюжее решение, пригодное только для демонстрации. В реальных проектах избегают глобального состояния. Объекты с семантикой "включить и выключить" оборачивают в компоненты, а управляет ими система.

[component]: https://github.com/stuartsierra/component

Мы подробно рассмотрели системы в первой книге, поэтому не будем начинать все с нуля. Покажем только, как представить сервер nREPL в виде компонента. В качестве системы выберем библиотеку [Component][component]. Добавьте ее в зависимости:

\begin{english}
  \begin{clojure}
[com.stuartsierra/component "0.4.0"]
  \end{clojure}
\end{english}

Код компонента:

\begin{english}
  \begin{clojure}
(defrecord nREPLServer
    [options
     server]

  component/Lifecycle

  (start [this]
    (let [options
          (update options :handler #(-> % resolve deref))

          arg-list
          (mapcat identity options)

          server
          (apply start-server arg-list)]

      (assoc this :server server)))

  (stop [this]
    (when server
      (stop-server server))
    (assoc this :server nil)))
  \end{clojure}
\end{english}

Его конструктор и пример вызова:

\begin{english}
  \begin{clojure}
(defn make-nrepl-server [options]
  (map->nREPLServer {:options options}))

(make-nrepl-server
 {:port 9911
  :handler 'cider.nrepl/cider-nrepl-handler})
  \end{clojure}
\end{english}

Комментария заслуживает вызов \code{(update ...)}, где поле \code{:handler} превращается в функцию комбинацией \code{resolve} и \code{deref}. Это нужно затем, что \code{:handler} содержит символ, указывающий на функцию:

\begin{english}
  \begin{clojure}
;; config.edn
{:handler cider.nrepl/cider-nrepl-handler}
  \end{clojure}
\end{english}

Почему бы не передать сразу функцию, а не символ? Дело в том, что конфигурацию часто хранят в *.edn-файле, в котором нельзя сослаться на объект Clojure. При чтении файла мы получим символ; далее компонент получит из него функцию.

В идеале компонент должен поддерживать как символ, так и функцию в поле \code{:handler}. Доработайте код, чтобы это требование выполнялось.

Выражение \code{(mapcat ...)} превращает словарь в плоский список ключей и значений:

\begin{english}
  \begin{clojure}
=> {k1 v1 k2 v2 ...}
(k1 v1 k2 v2 ...)
  \end{clojure}
\end{english}

Далее его передают в \code{start-server} при помощи \code{apply}. Это преобразование вызвано тем, что \code{start-server} принимает остаточные аргументы, а не словарь:

\begin{english}
  \begin{clojure}
(start-server :port 9911 :host "..." :handler ...)
  \end{clojure}
\end{english}

[map-arg]: https://clojure.org/news/2021/03/18/apis-serving-people-and-programs

Опытный читатель заметит, что в последних версиях Clojure [эта проблема решена][map-arg]: можно передать словарь в функцию \code{start-server}, и он преобразуется в список. Но чтобы код не зависел от версии Clojure, проделаем то же самое явно.

Приведем код запуска минимальной системы. Вынесем конфигурацию в файл \code{resources/config.edn}:

\begin{english}
  \begin{clojure}
;; config.edn
{:nrepl {:bind "0.0.0.0"
         :port 9911
         :handler cider.nrepl/cider-nrepl-handler}}
  \end{clojure}
\end{english}

Прочитаем его и построим систему:

\begin{english}
  \begin{clojure}
(def system-config
  (-> "config.edn"
      io/resource
      slurp
      edn/read-string))

(def system-init
  (component/system-map
   :nrepl (make-nrepl-server (:nrepl system-config))))
  \end{clojure}
\end{english}

Запустите систему в функции \code{-main} , и nREPL готов к подключению:

\begin{english}
  \begin{clojure}
(defn -main
  [& _]
  (let [system-started
        (component/start system-init)]
    (println "The nREPL server has been started")))
  \end{clojure}
\end{english}

В работе с компонентами проступает важное свойство: все задано конфигурацией. Если понадобится другой порт, измените настройки и перезагрузите приложение, не меняя кода. Тонкости конфигурации мы рассмотрели в первой книге.

Выше мы использовали библиотеку Component, однако это не ограничивает ваш выбор. Компонент nREPL легко изменить под Mount или Integrant. В качестве упражнения перепишите код из этого раздела под ту систему, что удобна вам.

\subsubsection{Безопасность}

До сих пор мы откладывали вопрос безопасности, и пора это исправить. Выше мы подключаемся к серверу так, словно он доступен всем желающим. Это настоящая катастрофа, поскольку злоумышленник может выполнить произвольный код: обратиться к базе, файлам и другим службам.

[port-scan]: https://en.wikipedia.org/wiki/Port\_scanner

Даже если вы никому не сказали, что на сервере запущен nREPL, это легко обнаружить. Существуют [сканеры портов][port-scan]~--- программы, которые перебирают порты веб-сервисов (8080, 8888), баз данных (5432, 3306) и других служб на удаленной машине. Продвинутые сканеры определяют программу за тем или иным портом, посылая различные сообщения.

nREPL не предлагает проверки доступа по логину и паролю. И хотя ее легко написать (это будет лишнее middleware в стеке), будет правильно защитить nREPL другим способом~--- сетевыми настройками. Ниже мы рассмотрим два подхода: iptables и SSH-туннель.

[iptables]: https://en.wikipedia.org/wiki/Iptables

Программа [iptables][iptables] задает правила обмена трафиком. Сделаем так, чтобы к nREPL можно было подключиться только с определенного IP (или диапазона), например из офиса. Пусть порт nREPL задан 9911, а внешний IP офиса~--- 178.210.54.129. Первое правило запрещает доступ к порту 9911 с любого IP:

\begin{english}
  \begin{bash}
sudo iptables -A INPUT -p tcp -s 0.0.0.0/0~---dport 9911 -j DROP
  \end{bash}
\end{english}

Второе правило в порядке исключения открывает доступ с адреса 178.210.54.129:

\begin{english}
  \begin{bash}
sudo iptables -A INPUT -p tcp -s 178.210.54.129~---dport 9911 -j ACCEPT
  \end{bash}
\end{english}

Введите эти правила на удаленной машине. После этого запустите проект на сервере командой \code{java -jar ...} и подключитесь с локальной машины. Если ваш IP совпадает с тем, что задан в правилах, подключение пройдет без ошибок. Сделайте то же самое с другим IP: включите VPN или раздайте интернет с телефона. В этом случае подключение не состоится.

Правила iptables действуют до перезагрузки операционной системы, и в следующий раз придется ввести их снова. Чтобы этого избежать, воспользуйтесь утилитой \code{iptables-persistent}. Установите ее командой:

\begin{english}
  \begin{bash}
sudo apt install iptables-persistent
  \end{bash}
\end{english}

После ввода правил выполните:

\begin{english}
  \begin{bash}
sudo netfilter-persistent save
  \end{bash}
\end{english}

, и после перезагрузки утилита восстановит их.

Подключение по SSH-туннелю безопасней и поэтому предпочтительней. На удаленной машине порт nREPL доступен только для локального подключения (с 127.0.0.1 или localhost). Утилита ssh устанавливает шифрованный туннель между локальной и удаленной машинами. Каждому концу туннеля назначается порт. Покажем это на схеме:

%% chart
%% ┌─────────────────────────────────────────────────────────┐
%% │ ┌───────────┐      ┌───────────────┐      ┌───────────┐ │
%% │ │  Laptop   │      │      SSH      │      │  Server   │ │
%% │ │           │◀────▶│               │◀────▶│           │ │
%% │ │port 19911 │      │    port 22    │      │ port 9911 │ │
%% │ └───────────┘      └───────────────┘      └───────────┘ │
%% └─────────────────────────────────────────────────────────┘
%%

Трафик локальной машины, переданный в порт 19911, поступит по туннелю на порт удаленной машины 9911 и обратно. С точки зрения обеих машин это будут локальные подключения. Все вопросы безопасности~--- авторизацию, шифрование, отзыв ключа~--- берет на себя SSH.

Откройте конфигурацию проекта. Укажите, что сервер nREPL прослушивает только локальный хост:

\begin{english}
  \begin{clojure}
;; config.edn
{:nrepl {:bind "127.0.0.1"
         :port 9911
         :handler cider.nrepl/cider-nrepl-handler}}
  \end{clojure}
\end{english}

Скомпилируйте jar-файл, перенесите на сервер и запустите командой \code{java -jar ...}. Откройте новую вкладку терминала и выполните:

\begin{english}
  \begin{bash}
ssh -N -L 19911:127.0.0.1:9911 <IP>
  \end{bash}
\end{english}

Разберем параметры этой команды:

- \code{-L}~--- установить туннель;
- 19911~--- локальный порт вашей машины;
- 9911~--- локальный порт удаленной машины;
- \code{-N}~--- не выполнять на сервере никаких действий, а просто ждать;
- \code{<IP>}~--- адрес удаленной машины.

Команда запустит процесс \code{ssh} без ввода с клавиатуры. Туннель работает до тех пор, пока вы не нажмете \code{Ctrl+C}. Перейдите в Emacs и подключитесь к порту 19911:

\begin{english}
  \begin{clojure}
M-x cider-connect <RET> 127.0.0.1 <RET> 19911 <RET>
  \end{clojure}
\end{english}

Поскольку система не знает о туннеле, в папке проекта не будет файла \code{.nrep-port}. Автодополнение не сработает, и порт придется ввести вручную. Это легко исправить, создав файл вручную:

\begin{english}
  \begin{bash}
echo 19911 > .nrepl-port
  \end{bash}
\end{english}

После легкой задержки вы подключитесь удаленному nREPL, словно он запущен локально. Этот способ лучше прямого подключения, потому что SSH берет на себя вопросы безопасности. Например, легко отозвать доступ к nREPL у пользователя, удалив его ключ на сервере.

Приемы, что мы рассмотрели выше~--- iptables и SSH-туннель~--- справедливы для запуска на чистом Линуксе (без виртуализации и контейнеров). Если вы пользуетесь решениями вроде Kubernetes или Elastic Container Service, настройки будут другими. Конфигурация этих программ выходит за рамки главы.

Перед тем как закончить раздел, напомним читателю о спорной природе nREPL на сервере. Идите на этот шаг только если понимаете все риски.

\subsection{REPL в других средах}

До сих пор мы изучали REPL, который выполняет код в виртуальной машине Java (JVM). Это популярный, но не единственный вариант. Теперь мы рассмотрим схему, где вычисления берет на себя платформа JavaScript. Этот способ сложнее и хрупче, он задействует больше технологий и протоколов. В то же время он открывает новые возможности.

Язык JavaScript недаром называют платформой. В широком плане это набор стандартов и реализаций под разные устройства. JavaScript выполняют браузеры, мобильные устройства, одноплатные компьютеры. Были попытки сделать на нем операционную систему для телефонов и ноутбуков. Популярность JavaScript не нужно доказывать~--- он повсюду.

[coffeescript]: https://coffeescript.org/

Со временем JavaScript стал платформой для программ, написанных на других языках. Пионером в этой области был [CoffeeScript][coffeescript]~--- легковесный язык, который сглаживал острые углы прародителя: сравнение, проверку на null/undefined, классы и так далее. Позже появились Elm и PureScript, вдохновленные строгостью Haskell. В последние годы набирает силу TypeScript~--- статически типизированный язык Microsoft.

[clojurescript]: https://clojurescript.org/

[gcc]: https://developers.google.com/closure/compiler

Экосистема Clojure предлагает [ClojureScript][clojurescript]~--- компилятор языка, близкого к Clojure, в JavaScript. Мы не случайно написали "близкого": хотя Clojure и ClojureScript похожи, между ними есть отличия, которые выступают в глубокой работе. ClojureScript опирается на компилятор Google, названный [Closure Compiler][gcc]. Обратите внимание разницу в написании: Clo\textbf{s}ure не имеет отношения к Clo\textbf{j}ure.

Особенность компилятора в том, что при должных настройках он эффективно сжимает код и удаляет его неиспользуемые части. В Closure Compiler принята система пространств имен, близкая к Clojure, что облегчает интеграцию двух проектов.

Важно помнить, что ClojureScript~--- только компилятор, но не интерпретатор. Это вводит новичков в заблуждение: загрузив ClojureScript, они ищут исполняемый файл, который бы выполнил скрипт на Clojure. Такого файла нет, и неясно, что делать.

На самом деле ClojureScript только перестраивает код на Clojure в JavaScript. Рассмотрим простой модуль \code{foo} с функцией \code{add}:

\begin{english}
  \begin{clojure}
(ns foo)

(defn add [a b]
  (+ a b))
  \end{clojure}
\end{english}

После обработки его силами ClojureScript получим код на JavaScript:

\begin{english}
  \begin{javascript}
// Compiled by ClojureScript 1.10.758 {}
goog.provide('foo');
goog.require('cljs.core');
foo.add = (function foo$add(a,b){
return (a + b);
});
  \end{javascript}
\end{english}

Как именно его выполнить~--- в какой среде и настройками~--- остается на ваше усмотрение.

Мы подводим читателя к понятию рантайма~--- среде исполнения JavaScript. Недостаточно написать код на этом языке: необходима среда, в которой он запуститься. Ниже мы рассмотрим две популярных среды: браузер и движок node.js. Мы увидим разницу между ними: проделаем в каждой то, что невозможно в другой.

Покажем отличие в вычислениях между Clojure и ClojureScript. В первом случае код выполняется в JVM:

%% chart
%% ┌───────────────────────────────────────────────────┐
%% │  ┌──────────┐     ┌──────────┐      ┌──────────┐  │
%% │  │          │────▶│          │─────▶│          │  │
%% │  │   REPL   │     │ Clojure  │      │   JVM    │  │
%% │  │          │◀────│          │◀─────│          │  │
%% │  └──────────┘     └──────────┘      └──────────┘  │
%% └───────────────────────────────────────────────────┘
%%

Для ClojureScript платформа JVM выступает в роли посредника. Ее задача~--- обеспечить связь между REPL и JavaScript. Связь работает поверх какого-то транспорта. Это может быть REST API, веб-сокеты, TCP-соединение или что-то другое.

%% chart
%% ┌────────────────────────────────────────────────────────────────────────────────┐
%% │  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐  │
%% │  │          │───▶│          │───▶│          │───▶│  REST    │───▶│          │  │
%% │  │   REPL   │    │ Clojure  │    │   JVM    │    │  ws      │    │JavaScript│  │
%% │  │          │◀───│          │◀───│          │◀───│  socket  │◀───│          │  │
%% │  └──────────┘    └──────────┘    └──────────┘    └──────────┘    └──────────┘  │
%% └────────────────────────────────────────────────────────────────────────────────┘
%%

Рассмотрим, как собрать эту схему на практике. Для начала понадобится ClojureScript. Это обычная библиотека на Clojure, поэтому добавим ее в зависимости. Также сделаем уточнение: до текущего момента мы в основном пользовались lein. Чтобы не формировать у читателя предвзятость, проведем эксперименты в Clojure CLI.

Создайте файл \code{deps.edn} следующего содержания:

\begin{english}
  \begin{clojure}
{:deps
 {org.clojure/clojurescript {:mvn/version "1.10.758"}}}
  \end{clojure}
\end{english}

Запустите REPL командой \code{clj} (или \code{clojure}). Когда появится приглашение, введите код:

\begin{english}
  \begin{clojure}
(require '[cljs.repl :as repl])
(require '[cljs.repl.node :as node])

(def env (node/repl-env))
(repl/repl env)
  \end{clojure}
\end{english}

Пока мы не ушли дальше, разберемся, что происходит. Пространства имен ClojureScript начинаются с \code{cljs}, чтобы не было путаницы с Clojure. Функция \code{repl} из последней формы запускает внутренний REPL для ClojureScript. Она принимает обязательный аргумент~--- окружение, которое мы создали вызовом \code{(node/repl-env)}.

Окружение отвечает за взаимодействие с платформой JavaScript. В техническом плане это объект, реализующий протокол \code{IJavaScriptEnv} с методами \code{-setup}, \code{-evaluate} и другими. Выше мы создали окружение для движка Node.js. Оно ищет программу \code{node}, установленную локально, и запускает ее. Процесс Node.js легко обнаружить командой:

\begin{english}
  \begin{bash}
ps aux | grep node
  \end{bash}
\end{english}

Как только процесс запущен, REPL готов принять команду. В терминале появится версия ClojureScript и приглашение:

\begin{english}
  \begin{text}
ClojureScript 1.10.758
cljs.user=>
  \end{text}
\end{english}

Введите \code{(+ 1 2)}, чтобы убедиться~--- схема работает.

Исследуйте объект \code{js/process}~--- центральный элемент движка node.js. Он содержит информацию о системе, переменных среды и многое другое. Если обратиться к полю \code{js/process.env}, получим загадочный вывод:

\begin{english}
  \begin{clojure}
=> js/process.env
#object[Object [object Object]]
  \end{clojure}
\end{english}

Напишем функцию \code{environment}, которая вернет словарь Clojure, где ключи~--- кейворды, а значения~--- переменные среды. Вот что получилось у автора:

\begin{english}
  \begin{clojure}
(defn environment []
  (persistent!
   (reduce
    (fn [result var-name]
      (assoc! result
              (keyword var-name)
              (aget js/process.env var-name)))
    (transient {})
    (js-keys js/process.env))))
  \end{clojure}
\end{english}

Наберите эту функцию в редакторе и скопируйте в REPL, после чего обратитесь к ней:

\begin{english}
  \begin{clojure}
(environment)
;; {:HOME "/Users/ivan", :USER "ivan", :TERM_PROGRAM_VERSION "3.3.12" ...}
  \end{clojure}
\end{english}

Обратите внимание на функцию \code{js-keys}, доступную только в ClojureScript. Функция получает свойства JavaScript-объекта; префикс \code{js-} означает, что аргумент~--- значение JavaScript, например объект или массив.

Когда эксперименты с node.js закончены, перейдем к браузеру. Запуск браузера отличается только окружением. Подключите модуль \code{cljs.repl.browser} и выполните код:

\begin{english}
  \begin{clojure}
(require '[cljs.repl.browser :as browser])
(def env (browser/repl-env))
(repl/repl env)
  \end{clojure}
\end{english}

Откроется браузер, назначенный в системе по умолчанию. Адрес страницы будет \code{http://localhost:9000} (порт и другие параметры можно задать в параметрах окружения). Вы увидите логотип ClojureScript и краткую справку. Вернитесь в терминал, где запущен REPL, и введите:

\begin{english}
  \begin{clojure}
(js/alert "Hello REPL!")
  \end{clojure}
\end{english}

Перейдите в браузер и проверьте, что появилось окно с приветствием. Исследуйте объект \code{localStorage}: установите значение по ключу и прочитайте его:

\begin{english}
  \begin{clojure}
(js/window.localStorage.setItem "key-1" "val-1")
(js/window.localStorage.getItem "key-1")
;; "val-1"
  \end{clojure}
\end{english}

Измените заголовок страницы. Для этого присвойте свойству \code{document.title} произвольную строку:

\begin{english}
  \begin{clojure}
(set! js/window.document.title "New Title")
  \end{clojure}
\end{english}

Убедитесь, что название вкладки в браузере поменялось.

Разберемся, как связаны между собой браузер и REPL. Откройте консоль разработчика и перейдите на закладку Network. Видно, что браузер посылает POST-запрос по адресу \code{http://localhost:9000/}. Эту технику называют long polling, (долгий опрос), потому что запрос длится до тех пор, пока вы не введете что-то в REPL и нажмете Enter.

Как только REPL получил выражение на Clojure, он компилирует его в ClojureScript и отправляет браузеру. Для ввода \code{(+ 1 2)} браузер получит следующий код:

\begin{english}
  \begin{json}
{"repl":"main", "form":"(function () {
  try {
    return cljs.core.pr_str.call(null, (function () {
      var ret__6698__auto__ = ((1) + (2));
      (cljs.core._STAR_3 = cljs.core._STAR_2);
      (cljs.core._STAR_2 = cljs.core._STAR_1);
      (cljs.core._STAR_1 = ret__6698__auto__);
      return ret__6698__auto__;
    })());
  } catch (e617) {
    var e__6699__auto__ = e617;
    (cljs.core._STAR_e = e__6699__auto__);
    throw e__6699__auto__;
  }
})()"}
  \end{json}
\end{english}

На первый взгляд он смотрится жутко: в коде лишние скобки и машинные имена, потому что его произвела программа. Разберемся, что здесь происходит.

Выражение \code{(+ 1 2)} стало \code{((1) + (2))}. Оно выполняется в анонимной функции без параметров. Форма \code{cljs.core.pr\_str.call} означает функцию \code{pr-str} в Clojure, которая приводит объект к строке.

Переменные \code{\_STAR\_} с номером на конце~--- это \code{*1}, \code{*2} и \code{*3} для хранения последних результатов. Код обернут в \code{try/catch}. В случае ошибки переменной \code{*e} (после компиляции~--- \code{\_STAR\_e}) назначается последнее исключение.

Полученный код выполняется в браузере обычным \code{eval}. На сервер уходит отчет о вычислении:

\begin{english}
  \begin{clojure}
{:repl "main",
 :type :result,
 :content "{:status :success, :value \"3\"}",
 :order 3}
  \end{clojure}
\end{english}

В зависимости от статуса терминал покажет результат или сведения об ошибке.

Запустить REPL в node.js или браузере можно и без кода. Для этого служат параметры командной строки:

\begin{english}
  \begin{bash}
clj -M -m cljs.main~---repl-env node
clj -M -m cljs.main~---repl-env browser
  \end{bash}
\end{english}

В обоих случаях вы получите готовый REPL в нужном окружении.

\subsubsection{Поддержка Cider}

[piggieback]: https://github.com/nrepl/piggieback

До сих пор мы вводили команды в терминале, что непривычно после Emacs и Cider. Наверняка читателю интересно, как связать  ClojureScript с редактором. Для этого служит библиотека с забавным названием [Piggieback][piggieback], что означает "нести на закорках".

Piggieback служит мостом между nREPL и JavaScript. В техническом плане это middleware, которое передает сообщения от клиента к JavaScript и обратно. С Piggieback схема усложняется еще больше и выглядит так:

%% chart
%% ┌────────────────────────────────────────────────────────────────────────────────┐
%% │ ┌─────────────────┐   ┌─────────────────────────┐   ┌────────────────────────┐ │
%% │ │Client           │   │Server                   │   │JS environment          │ │
%% │ │                 │   │                         │   │                        │ │
%% │ │  ┌───────────┐  │   │  ┌───────────┐     ┌────┴───┴────┐     ┌───────────┐ │ │
%% │ │  │           │  │   │  │           │     │ Piggieback  │     │           │ │ │
%% │ │  │   Emacs   │  │   │  │  Clojure  │◀═══▶│             │◀═══▶│  Browser  │ │ │
%% │ │  │           │  │   │  │           │     │   HTTP/ws   │     │           │ │ │
%% │ │  └───────────┘  │   │  └───────────┘     └────┬───┬────┘     └───────────┘ │ │
%% │ │        ▲        │   │        ▲                │ ▲ │                        │ │
%% │ │        ║        │   │        ║                │ ║ │          ┌───────────┐ │ │
%% │ │        ║        │   │        ║                │ ║ │          │           │ │ │
%% │ │        ▼        │   │        ▼                │ ╚═╬═════════▶│  Node.js  │ │ │
%% │ │  ┌───────────┐  │   │  ┌───────────┐          │   │          │           │ │ │
%% │ │  │   CIDER   │  │   │  │   nREPL   │          │   │          └───────────┘ │ │
%% │ │  │  plugin   │◀═╬═══╬═▶│  server   │          │   │                        │ │
%% │ │  │           │  │   │  │           │          │   │                        │ │
%% │ │  └───────────┘  │   │  └───────────┘          │   │                        │ │
%% │ │                 │   │                         │   │                        │ │
%% │ │                 │   │                         │   │                        │ │
%% │ │                 │   │                         │   │                        │ │
%% │ └─────────────────┘   └─────────────────────────┘   └────────────────────────┘ │
%% └────────────────────────────────────────────────────────────────────────────────┘
%%

Чтобы подключиться к ClojureScript из редактора, задайте в файле \code{deps.edn} профиль \code{:nrepl/piggieback}. Профиль добавляет в стек middleware звено \code{wrap-cljs-repl}:

\begin{english}
  \begin{clojure}
{:aliases
 {:nrepl/piggieback
  {:extra-deps
   {nrepl/nrepl {:mvn/version "0.8.3"}
    cider/piggieback {:mvn/version "0.5.3"}
    cider/cider-nrepl {:mvn/version "0.28.3"}}
   :main-opts
   ["-m" "nrepl.cmdline"
    "--bind" "localhost"
    "--middleware" "[cider.piggieback/wrap-cljs-repl,cider.nrepl/cider-middleware]"]}}
 :deps
 {org.clojure/clojurescript {:mvn/version "1.10.758"}}}
  \end{clojure}
\end{english}

Запустите проект командой:

\begin{english}
  \begin{bash}
clj -M:nrepl/piggieback
  \end{bash}
\end{english}

На первый взгляд не произойдет ничего особенного: запустится обычный сеанс nREPL. Перейдите в Emacs и подключитесь командой \code{cider-connect-cljs} (клавиши \code{C-c M-c}). Обратите внимание, что это новая команда, которой мы еще не пользовались. Если все настроено без ошибок, Emacs запросит тип REPL: браузер, node.js, shadow-clj и другие, которых мы не касались в этой главе.

Выберите пункт "node" или "browser". В зависимости от типа запустится процесс node.js или браузер. Выполните код командами \code{cider-eval-...} или в буфере \code{*cider-repl*}~--- он будет вычислен в окружении JavaScript, а не JVM. Проверьте объекты, доступные только в конкретной среде (\code{js/window} или \code{js/process}).

Вам по-прежнему доступен переход к определению (\code{cider-find-var}), загрузка буфера (\code{cider-load-buffer}), запуск тестов и многое то, что мы рассмотрели выше. Исключением станет отладка и профилирование: эти техники не работают в ClojureScript, поскольку полагаются на низкоуровневые детали.

\subsubsection{Прочие сведения}

REPL в ClojureScript слишком заманчив, чтобы так быстро расстаться с ним. Перечислим библиотеки из этой области, не погружаясь в них слишком глубоко. Раздел носит обзорный характер и направлен на то, чтобы разжечь в читателе интерес.

[re-natal]: https://github.com/drapanjanas/re-natal

Проект [Re-Natal][re-natal] служит для разработки приложений под iOS и Android на ClojureScript. Это обертка над фреймворком React Native фирмы Facebook. Сильно упрощая, React Native можно описать как процесс на Node.js, который управляет деревом компонентов. Мобильная платформа отображает это дерево нативными виджетами.

Re-Natal устанавливает сеанс REPL с процессом Node. Подключившись из редактора, вы получите полный контроль над устройством или эмулятором. Представьте, насколько удобно выполнять код на устройстве, не дожидаясь сборки приложения. Например, послать HTTP-запрос или получить снимок с камеры. Это упрощает разработку, позволяет проверить разные сценарии, в том числе негативные (проблемы связи, нет доступа к камере и другие).

[rn-yandex]: https://www.youtube.com/watch?v=WOMnm8mrWFE

Разработка на React Native противоречива: в ней есть как преимущества, так и недостатки. Предлагаем посмотреть доклад Андрея Мелихова ["Как я полюбил и возненавидел React Native"][rn-yandex]. Автор взвешенно объясняет, почему Яндекс инвестировал усилия в React Native, но в итоге отказался от него. Впрочем, вы не обязаны следовать IT-гигантам. Если нужно простое приложение под обе платформы и вы знаете Clojure, рассмотрите Re-Natal: возможно, он сэкономит время.

[krell]: https://github.com/vouch-opensource/krell

Еще одна адаптация React Native называется [Krell][krell]. Библиотека компилирует код на ClojureScript и загружает в устройство. Как и Re-Natal, Krell запускает REPL с полным доступом к среде исполнения.

[espruino]: https://www.espruino.com/Features

Если мы заговорили об устройствах, нельзя обойти стороной Espruino~--- микроконтроллер стоимостью около 20 долларов. От Arduino и аналогов он отличается тем, что код под него пишут не на C/C++, а на JavaScript. В силу ограничений Espruino покрывает не все возможности JavaScript, но основную их часть. Технические детали вы найдете на [странице проекта][espruino].

[yodo]: https://amperka.ru/product/yodo

Российская фирма Амперка выпускает [набор Йодо][yodo] для обучения детей программированию. В набор входят плата Espruino, датчики, провода и брошюра с проектами. В Амперке отлично адаптировали Espruino для детей. К каждому датчику прилагается модуль с удобными функциями и документация на русском языке. Модули загружаются с npm-сервера Амперки и оперативно обновляются. Работает форум и команда поддержки.

Запуск ClojureScript на устройстве со множеством датчиков~--- крайне интересное занятие. Можно сделать игрушку, будильник, телеграф или подобие умного дома. Более амбициозный проект~--- инкубатор яиц, где влажность и температура выводятся на дисплей, а при отклонении от нормы включаются звуковые сигналы.

Сказанное выше относится к устройствам, в сердце которых лежит Node.js. Еще больше разнообразия ждет вас в разработке под браузер.

[shadow-cljs]: https://github.com/thheller/shadow-cljs

Проект [Shadow CLJS][shadow-cljs] можно описать как улучшенный компилятор ClojureScript. Он предлагает ускоренную компиляцию, когда собирается не весь проект, а только измененные файлы. Shadow CLJS поддерживает кэш компиляции, живую перезагрузку кода в браузере, удобный REPL, сборку под разные платформы (браузер, node, расширение Chrome) и многое другое.

[figwheel]: https://figwheel.org/

Библиотека [Figwheel][figwheel] сокращает время между написанием кода и результатом в браузере. Figwheel запускает сервер, который следит за изменениями в файлах ClojureScript. Как только файл изменился, Figwheel отправляет в браузер его скомпилированную версию. Браузер обновляет содержимое без перезагрузки страницы, что удобно при разработке.

[weasel]: https://github.com/nrepl/weasel

[Weasel][weasel]~--- еще один REPL для браузера. Для транспорта он использует веб-сокеты, а не долгие POST-запросы, как это делает обычный браузерный REPL. Weasel работает в паре с Piggieback, и его настройка аналогична шагам, что мы рассмотрели.

[lumo]: https://github.com/anmonteiro/lumo

[Lumo][lumo]~--- мощный инструмент для разработки на ClojureScript. Одно из главных его преимуществ~--- REPL, скомпилированный под Node.js. Чтобы запустить его, не нужно устанавливать JVM и компилятор ClojureScript. Достаточно скачать пакет lumo-cljs из npm и вызвать одну функцию.

[closure-compiler-js]: https://github.com/google/closure-compiler-js

Другая эксклюзивная черта Lumo~--- компиляция силами JavaScript без участия Java. Это возможно при помощи клона Closure Compiler, переписанного [на JavaScript][closure-compiler-js]. К сожалению, оба репозитория сданы в архив и, скорее всего, не будут развиваться.

\subsubsection{REBL}

[rebl]: https://docs.datomic.com/cloud/other-tools/REBL.html

Наш обзор замыкает [проект REBL][rebl]~--- графический REPL фирмы Cognitect. Буква B в названии означает browse~--- обозревать, что указывает на богатые возможности REBL в работе с данными.

[datomic-console]: https://docs.datomic.com/on-prem/other-tools/console.html

REBL берет начало от базы данных Datomic, точнее ее [графической консоли][datomic-console]. Со временем консоль вынесли в отдельную библиотеку, а веб-интерфейс заменили на JavaFx~--- так и получился REBL. Он нацелен на общую работу с данными, а не только Datomic.

Особенность REBL в том, что его код закрыт. Это слегка непривычно в мире Clojure, где преобладает открытый код. По той же причине усложнена его установка: чтобы получить REBL, нужно заполнить форму на сайте Cognitect, после чего на почту придет ссылка на архив. Распакуйте его и запустите скрипт \code{install}. Он скопирует jar-файлы в локальную папку Maven (по умолчанию \code{~/.m2}).

Приведем минимальный \code{deps.edn} для запуска REBL. Основную его часть занимают зависимости JavaFx:

\begin{english}
  \begin{clojure}
{:aliases
 {:rebl
  {:extra-deps {com.cognitect/rebl          {:mvn/version "0.9.245"}
                org.openjfx/javafx-fxml     {:mvn/version "15-ea+6"}
                org.openjfx/javafx-controls {:mvn/version "15-ea+6"}
                org.openjfx/javafx-swing    {:mvn/version "15-ea+6"}
                org.openjfx/javafx-base     {:mvn/version "15-ea+6"}
                org.openjfx/javafx-web      {:mvn/version "15-ea+6"}}
   :main-opts ["-m" "cognitect.rebl"]}}}
  \end{clojure}
\end{english}

Выполните \code{clj -M:rebl} и дождитесь загрузки артефактов. Появится окно, разбитое на несколько частей: ввод кода, просмотр результата и другие. Область ввода напоминает простой редактор: в ней работает подсветка синтаксиса и балансировка скобок.

\def\urlreblvideo{https://www.youtube.com/watch?v=c52QhiXsmyI}

Кроме ввода с клавиатуры, REBL поддерживает интеграцию с nREPL и Cider, горячие клавиши, просмотр метаданных. Эти и другие возможности перечислены на странице Cognitect. \footurl{В одноименном видео}{\urlreblvideo}[REBL~--- Stuart Halloway] Стюарт Хэллоуэй (Stuart Halloway), основатель фирмы, вживую показывает, как пользоваться REBL.

На этом мы закончим обзор библиотек и подведем итоги главы.

\subsection{Заключение}

Аббревиатура REPL означает Read, Eval, Print, Loop~--- прочитать, выполнить, напечатать, повторить. В широком плане это режим программы, когда введенный код сразу выполняется. С помощью REPL программист проверяет код по мере его написания. Так он раньше поймет, какие данные приводят к ошибкам и куда двигаться дальше.

REPL~--- один из столпов в языках семейства Lisp. Первые Лисп-машины работали в режиме приглашения, и это правило сохранилось до наших дней. От любой Лисп-системы ожидают интерактивный режим. Современные языки тоже предлагают интерактивные сеансы (\code{python}, \code{irb}), но их возможности крайне скудны.

Первые машины читали ввод с клавиатуры, но со временем стало ясно: с REPL удобней работать по сети. Появились сетевые версии REPL со своими протоколами. В мире Common Lisp это проекты Slime и Swank, в Clojure~--- nREPL. В отличие от клавиатурного REPL, сетевая версия поддерживает несколько клиентов одновременно. Сервер отвечает на сообщения асинхронно; на один запрос клиент может получить несколько сообщений.

Чтобы подключиться к REPL из редактора, нужен специальный модуль (плагин, расширение). Наиболее продвинутый клиент для nREPL называется Cider~--- модуль для Emacs. В свою очередь Emacs~--- один из самых старых редакторов. Порог входа в него выше, чем у современных VS Code или Sublime Text, но и возможностей, накопленных за сорок лет развития, гораздо больше.

Сетевой REPL полезен в виртуальном окружении, например Docker. В редких случаях его оставляют в промышленном запуске, однако это небезопасно и требует особых настроек.

nREPL расширяют при помощи middleware~--- промежуточных обработчиков, похожих на аналоги из пакета Ring. Библиотека \code{cider-nrepl} добавляет в протокол поддержку тестов, навигацию по коду, отладку, трассировку, словом, все то, что предлагают современные IDE.

ClojureScript~--- это язык, похожий на Clojure, который компилируется в JavaScript. В работе с ним REPL важен в той же мере, что и с Clojure. Выражения выполняются в среде JavaScript, роль которой играет браузер, движок Node.js или устройство (телефон, одноплатный компьютер).

Из-за разнообразия платформ JavaScript создано множество REPL-ов к нему. Все они предлагают те или иные преимущества при работе с проектом. С помощью библиотеки Piggieback легко связать ClojureScript с редактором. С ней код на устройстве можно выполнить прямо из Emacs, что упрощает работу.

Опытные программисты знают, что REPL~--- не просто приятная возможность языка. Это иной процесс разработки: он кардинально отличается от привычной модели, когда код сперва пишут, а потом запускают. В REPL написание кода и запуск чередуются мелкими итерациями. Так мы исследуем код задолго до запуска в бою.

Если вы интересуетесь языками семейства Lisp, потратьте время на настройку редактора и окружения. Эти затраты окупаются: с REPL ваша производительность возрастет многократно. Когда вы овладели REPL, разработка на других языках без него покажется немыслимой.
