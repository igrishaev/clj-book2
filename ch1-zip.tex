\chapter{Зипперы}

\begin{teaser}
В этой главе мы рассмотрим зипперы в языке Clojure. Это необычный способ работы
с коллекциями. С помощью зиппера можно обойти произвольные данные, изменить их и
выполнить поиск. Зиппер~--- мощный инструмент, и вложения в него окупаются со
временем. Вместе с тем это довольно сложная абстракция, которая требует
подготовки.
\end{teaser}

\section{Азы навигации}

Объясним зиппер простыми словами. Это обёртка над данными с набором
действий. Вот некоторые из них:

\begin{itemize}

\item
  перемещение по вертикали: вниз к потомкам или вверх к родителю;

\item
  перемещение по горизонтали: влево или вправо среди потомков;

\item
обход всех элементов;

\item
добавление, редактирование и удаление узлов.

\end{itemize}

Это неполный список того, на что способны зипперы. Другие их свойства мы
рассмотрим по ходу главы. Важно, что указанные действия относятся к любым
данным, будь то комбинация векторов и словарей, дерево узлов или XML. Из-за
этого зипперы становятся мощным инструментом. Разобраться с ними означает
повысить свои навыки и открыть новые двери.

\def\huet{https://en.wikipedia.org/wiki/Gerard\_Huet}
\def\huetzipper{https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf}

Термин <<зиппер>> ввел ученый \footurl{Жерар Юэ}{\huet}[G\'{e}rard Huet]
(G\'{e}rard Huet) в 1996 году. Юэ занимался деревьями и искал универсальный
способ работы с ними. В знаменитой работе \footurl{<<Functional Pearl: The
  Zipper>>}{\huetzipper}[The Zipper] Юэ привел концепцию зиппера на языке
OCaml. Документ привлек внимание простотой и ясностью: описание зиппера, включая
код и комментарии, уместились на четырех страницах. Современные зипперы почти не
отличаются от того изложения 1996 года.

Хотя Юэ отмечает, что зиппер можно создать на любом языке, лучше всего они
прижились в функциональных: Haskell, OCaml, Clojure. Зипперы поощряют
неизменяемые данные и чистые преобразования. Для упомянутых языков написаны
библиотеки зипперов, и разработчики хотя бы поверхностно знакомы с
ними. Наоборот, в императивной среде зипперы почти неизвестны.

Зипперы доступны в Clojure с первой версии. Их легко добавить в проект, не
опасаясь проблем лицензии или новых зависимостей.

Зипперы в Clojure используют мощь неизменяемых коллекций. Технически зиппер~---
это коллекция, которая хранит данные и позицию в них. Всё вместе это называется
локацией (location). Шаг в любую сторону вернёт новую локацию подобно тому, как
функции \code{assoc} или \code{update} производят новые данные из прежних.

Из текущей локации можно получить \emph{узел} (ноду)~--- данные, на которые ссылается
указатель. На этом моменте путаются новички, поэтому уточним различие. Локация~---
это исходные данные и положение в них. Передвижение по локации порождает
локацию. Из локации можно извлечь узел~--- данные, которые встретились на этом
участке.

Приведём пример с вектором \code{[1 2 3]}. Чтобы переместиться на \textbf{двойку}, обернем
данные в зиппер и выполним команды \code{zip/down} и \code{zip/right}. С первым шагом мы
провалимся в вектор и окажемся на единице. Шаг вправо сдвинет нас на
двойку. Выразим это в коде: подключим модуль \code{clojure.zip} и переместимся по
вектору:

\begin{english}
  \begin{clojure}
(require '[clojure.zip :as zip])

(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/right
    zip/node)
;; 2
  \end{clojure}
\end{english}

Функция \code{zip/vector-zip} зиппер из вектора. Вызовы \code{zip/down} и
\code{zip/right} передвинут указатель на двойку, как и ожидалось. Последний шаг
\code{zip/node} вернет значение (узел) из текущей локации. Если убрать \code{zip/node},
получим локацию, которая соответствует двойке. Вот как она выглядит:

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/right)

;; [2 {:l [1], :pnodes [[1 2 3]], :ppath nil, :r (3)}]
  \end{clojure}
\end{english}

Наверняка у вас возникли вопросы: откуда мы знаем путь к двойке, ведь она могла
быть в другом месте вектора? Что произойдет, если выйти за пределы коллекции?
Мы ответим на эти вопросы ниже. Пока что, если вам что-то непонятно, не впадайте
в панику: мы не раз обсудим всё, что происходит.

Итак, зиппер предлагает перемещение по данным. Несмотря на всю мощь, он не
знает, как делать это для конкретной коллекции, и нуждается в вашей помощи. Вот
что нужно знать зипперу:

\begin{itemize}

\item
  Является ли текущий элемент веткой или нет? Веткой называют элемент, из
  которого можно извлечь другие элементы.

\item
  Если это ветка, как именно получить её элементы?

\end{itemize}

Как только мы знаем ответы на эти вопросы, зиппер готов. Заметим, что для
изменения зиппера нужен ответ на третий вопрос~--- как присоединить потомков к
ветке. Однако сейчас мы рассматриваем только навигацию, и третий вопрос
подождет.

В техническом плане ответы на эти вопросы~--- функции. Первая принимает узел и
возвращает истину или ложь. Если получили истину, зиппер вызовет вторую функцию
с тем же узлом. От нее ожидают коллекцию дочерних узлов или \code{nil}, если их
нет. В терминах зиппера функции называют \code{branch?} и \code{children}
соответственно.

Чтобы получить зиппер, сообщите ему данные и эти две функции. Посколько мы
только читаем зиппер, третья функция будет \code{nil}.

\def\urlclojurezip{https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj}

Зипперы находятся в модуле \code{clojure.zip}. В свободное время исследуйте его код:
он занимает всего \footurl{280 строк}{\urlclojurezip}[zip.clj]!

\begin{english}
  \begin{clojure}
(ns my.project
  (:require [clojure.zip :as zip]))
  \end{clojure}
\end{english}

Функция \code{zip/zipper} порождает зиппер из исходных данных и функций. Это
центральная точка модуля, его строительный материал. Для особых случаев модуль
содержит вспомогательные функции, которые ожидают только данные. Примером служит
функция \code{vector-zip}. Она работает с вектором, элементы которого могут быть
вложенным вектором и так далее. Приведём ее код в сокращении:

\begin{english}
  \begin{clojure}
(defn vector-zip
  [root]
  (zipper vector?
          seq
          ...
          root))
  \end{clojure}
\end{english}

Третий параметр мы заменили на многоточие. Это функция, которая присоединяет к
ветке дочерные узлы при изменении (пока что обходим вопрос стороной).

Если передать в \code{vector-zip} данные \code{[1 2 3]}, произойдёт
следующее. Зиппер обернёт вектор и выставит на него указатель. Из начального
положения можно следовать только вниз, потому что у вершины нет родителя (вверх)
и соседей (влево и вправо). При смещении \textbf{вниз} зиппер сначала проверит,
что текущий узел~--- ветка. Сработает выражение \code{(vector? [1 2 3])}, что
вернёт истину. В этом случае зиппер выполнит \code{(seq [1 2 3])}, чтобы
получить потомков. Ими станет последовательность \code{(1 2 3)}. Как только
потомки найдены, зиппер установит указатель на крайний левый потомок~---
единицу.

Покажем это на схеме. Начальная позиция, указатель на исходном векторе:

\begin{figure}[H]
  \centering
  \includesvg{charts/zip01.svg}
  \label{fig:chart-zip-01}
\end{figure}

Шаг вниз, указатель на единице:

\begin{figure}[H]
  \centering
  \includesvg{charts/zip02.svg}
  \label{fig:chart-zip-02}
\end{figure}

Шаг вправо, указатель на двойке:

\begin{figure}[H]
  \centering
  \includesvg{charts/zip03.svg}
  \label{fig:chart-zip-03}
\end{figure}

Итак, мы находимся на двойке и можем двигаться дальше по горизонтали. Шаг вправо
сдвинет нас на тройку, влево~--- на единицу. Вот как это выглядит в коде:

\begin{english}
  \begin{clojure}
(def loc2
  (-> [1 2 3]
      zip/vector-zip
      zip/down
      zip/right))

(-> loc2 zip/node)
;; 2

(-> loc2 zip/right zip/node)
;; 3

(-> loc2 zip/left zip/node)
;; 1
  \end{clojure}
\end{english}

При попытке сдвинуться вниз зиппер выполнит предикат \code{(vector? 2)}. Результат
будет ложью, что означает, что текущий элемент не ветка, и движение вниз
запрещено.

Во время движения каждый шаг порождает новую локацию, не изменяя старую. Если вы
сохранили очередную локацию в переменную, дальнейшие вызовы \code{zip/right} или
\code{zip/down} не изменят её. Выше мы объявили переменную \code{loc2}, которая
указывает на двойку. Проследуем от нее к исходному вектору:

\begin{english}
  \begin{clojure}
(-> loc2 zip/up zip/node)
;; [1 2 3]
  \end{clojure}
\end{english}

При ручном перемещении велики шансы выйти за пределы данных. Шаг в никуда вернёт
\code{nil} вместо локации:

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/left)
nil
  \end{clojure}
\end{english}

Это сигнал, что вы идёте по неверному пути. Из \code{nil} нельзя вернуться на
прежнее место, потому что у \code{nil} нет сведений о позиции. Для \code{nil}
функции \code{zip/up}, \code{zip/right} и другие тоже вернут \code{nil}. Если не
учесть это в цикле, вы будете топтаться на месте.

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/left
    zip/left
    ...)
;; nil
  \end{clojure}
\end{english}

К исключению относится функция \code{zip/down}: при попытке спуститься из \code{nil} вы
получите \code{NullPointerException}. Это недочёт, который, возможно, когда-нибудь
исправят.

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/left
    zip/down)

;; Execution error (NullPointerException)...
  \end{clojure}
\end{english}

Рассмотрим случай, когда у вектора вложенные элементы: \code{[1 [2 3] 4]}. Чтобы
переместиться на \textbf{тройку}, выполним шаги <<вниз>>, <<вправо>>, <<вниз>>,
<<вправо>>. Сохраним локацию в переменную \code{loc3}:

\begin{english}
  \begin{clojure}
(def loc3
  (-> [1 [2 3] 4]
      zip/vector-zip
      zip/down
      zip/right
      zip/down
      zip/right))

(zip/node loc3)
;; 3
  \end{clojure}
\end{english}

Рисунки ниже показывают, что происходит на каждом шаге. Исходная позиция:

\begin{figure}[H]
  \centering
  \includesvg{charts/zip04.svg}
  \label{fig:chart-zip-04}
\end{figure}

Шаг вниз:

\begin{figure}[H]
  \centering
  \includesvg{charts/zip05.svg}
  \label{fig:chart-zip-05}
\end{figure}

Вправо:

\begin{figure}[H]
  \centering
  \includesvg{charts/zip06.svg}
  \label{fig:chart-zip-06}
\end{figure}

Вниз:

\begin{figure}[H]
  \centering
  \includesvg{charts/zip07.svg}
  \label{fig:chart-zip-07}
\end{figure}

Вправо. Мы у цели:

\begin{figure}[H]
  \centering
  \includesvg{charts/zip08.svg}
  \label{fig:chart-zip-08}
\end{figure}

Чтобы перейти на \textbf{четвёрку} из текущей позиции, сначала поднимемся
вверх. Указатель сдвинется на вектор \code{[2 3]}. Мы находимся среди потомков
исходного вектора и можем перемещаться по горизонтали. Сделаем шаг вправо и
окажемся на цифре 4.

То же самое графически. Текущая локация (тройка):

\begin{figure}[H]
  \centering
  \includesvg{charts/zip09.svg}
  \label{fig:chart-zip-09}
\end{figure}

Шаг вверх:

\begin{figure}[H]
  \centering
  \includesvg{charts/zip10.svg}
  \label{fig:chart-zip-10}
\end{figure}

Шаг вправо:

\begin{figure}[H]
  \centering
  \includesvg{charts/zip11.svg}
  \label{fig:chart-zip-11}
\end{figure}

Исходный вектор может быть любой вложенности. Ради интереса замените тройку на
\code{[5 [6 [7 [8] 9]]]} и проследуйте до девятки.

Что случится, если передать в \code{vector-zip} что-то отличное от вектора?
Предположим, \code{nil}, строку или число. Перед тем, как двигаться, зиппер проверит,
подходит ли узел на роль ветки. Сработает функция \code{vector?}, которая вернет
\code{nil} для всех отличных от вектора значений. В результате получим локацию, из
которой нельзя никуда шагнуть: ни вниз, ни в стороны. Это тупиковый случай, и
его нужно избегать.

\begin{english}
  \begin{clojure}
(-> "test"
    zip/vector-zip
    zip/down)
nil
  \end{clojure}
\end{english}

Модуль \code{clojure.zip} предлагает и другие встроенные зипперы. Особенно интересен
\code{xml-zip} для навигации по XML-дереву. Мы обсудим его отдельно, когда читатель
познакомится с другими свойствами зипперов.

\section{Автонавигация}

Мы разобрались с тем, как перемещаться по коллекции. Однако у читателя возникнет
вопрос: как мы узнаем заранее, куда двигаться? Откуда приходит путь?

Ответ покажется странным, но все же: ручная навигация по данным лишена всякого
смысла. Если путь известен заранее, вам не нужен зиппер~--- это лишнее
усложнение.

Clojure предлагает более простую работу с данными, структура которых
известна. Например, если мы точно знаем, что на вход поступил вектор, второй
элемент которого вектор, и нужно взять его второй элемент, воспользуемся
\code{get-in}:

\begin{english}
  \begin{clojure}
(def data [1 [2 3] 4])

(get-in data [1 1])
;; 3
  \end{clojure}
\end{english}

То же самое касается других типов данных. Неважно, какую какую комбинацию
образуют списки и словари: если структура известна заранее, до элемента легко
добраться с помощью \code{get-in} или стрелочного оператора. В данном случае зипперы
только усложнят код.

\begin{english}
  \begin{clojure}
(def data {:users [{:name "Ivan"}]})

(-> data :users first :name)
;; "Ivan"
  \end{clojure}
\end{english}

В чем же тогда преимущество зипперов? Свои сильные стороны они проявляют там,
где \code{get-in} не работает. Речь о данных с \textbf{неизвестной} структурой. Представьте,
что на вход поступил произвольный вектор, и нужно найти в нём строку. Она может
быть как на поверхности вектора, так и вложена на три уровня. В этом случае
\code{get-in} не поможет, потому что мы не знаем путь. Другой пример~---
XML-документ. Нужный тег может располагаться где угодно, и нужно как-то его
найти. Таким образом, идеальный случай для зиппера~--- нечёткая структура данных,
о которой у нас только предположения.

Функции \code{zip/up}, \code{zip/down} и другие образуют универсальную \code{zip/next}. Эта
функция передвигает указатель так, что рано или поздно мы обойдем всю
структуру. При обходе исключены повторы: мы побываем в каждом месте только
раз. Пример с вектором:

\begin{english}
  \begin{clojure}
(def vzip (zip/vector-zip [1 [2 3] 4]))

(-> vzip zip/node)
;; [1 [2 3] 4]

(-> vzip zip/next zip/node)
;; 1

(-> vzip zip/next zip/next zip/node)
;; [2 3]

(-> vzip zip/next zip/next zip/next zip/node)
;; 2
  \end{clojure}
\end{english}

Очевидно, мы не знаем, сколько раз вызывать \code{zip/next}, поэтому пойдём на
хитрость. Функция \code{iterate} принимает функцию \code{f} и значение \code{x}. Результатом
станет последовательность, где первый элемент \code{x}, а каждый следующий~--- \code{f(x)}
от предыдущего. Для зиппера мы получим исходную локацию, затем \code{zip/next} от
неё, затем \code{zip/next} от прошлого шага и так далее.

Переменная \code{loc-seq} ниже~--- это цепочка локаций исходного зиппера. Чтобы
получить узлы, мы берём шесть первых элементов (число взяли случайно) и вызываем
для каждого \code{zip/node}.

\begin{english}
  \begin{clojure}
(def loc-seq
  (iterate zip/next vzip))

(->> loc-seq
     (take 6)
     (map zip/node))

;; ([1 [2 3] 4]
;;  1
;;  [2 3]
;;  2
;;  3
;;  4)
  \end{clojure}
\end{english}

\code{Iterate} порождает \textbf{ленивую} и \textbf{бесконечную} последовательность. Обе
характеристики важны. Ленивость означает, что очередной сдвиг (вызов \code{zip/next})
не произойдёт до тех пор, пока вы не дойдёте до элемента в
цепочке. Бесконечность означает, что \code{zip/next} вызывается неограниченное число
раз. Понадобится признак, по которому мы остановим вызов \code{zip/next}, иначе поток
локаций никогда не закончится.

Если исследовать \code{loc-seq}, станет ясно, что в какой-то момент \code{zip/next} уже не
сдвигает указатель. Возьмём наугад сотый и тысячный элементы итерации. Их узел
будет исходным вектором:

\begin{english}
  \begin{clojure}
(-> loc-seq (nth 100) zip/node)
;; [1 [2 3] 4]

(-> loc-seq (nth 1000) zip/node)
;; [1 [2 3] 4]

  \end{clojure}
\end{english}

Причина кроется в устройстве зиппера. Функция \code{zip/next} работает по принципу
кольца. Когда она достигает исходной локации, цикл завершается. При этом локация
получит признак завершения, и дальнейший вызов \code{zip/next} вернёт её
же. Проверить признак можно функцией \code{zip/end?}:

\begin{english}
  \begin{clojure}
(def loc-end
  (-> [1 2 3]
      zip/vector-zip
      zip/next
      zip/next
      zip/next))

loc-end
;; [[1 2 3] :end]

(zip/end? loc-end)
;; true

  \end{clojure}
\end{english}

Чтобы получить конечную цепь локаций, будем сдвигать указатель до тех пор, пока
локация не последняя. Всё вместе даёт функцию \code{iter-zip}:

\begin{english}
  \begin{clojure}
(defn iter-zip [zipper]
  (->> zipper
       (iterate zip/next)
       (take-while (complement zip/end?))))
  \end{clojure}
\end{english}

Функция вернёт все локации от начальной до конечной не включая ее. Напомним, что
локация хранит узел (элемент данных), который можно извлечь с помощью
\code{zip/node}. Код ниже показывает, как превратить локации в данные:

\begin{english}
  \begin{clojure}
(->> [1 [2 3] 4]
     zip/vector-zip
     iter-zip
     (map zip/node))

;; ([1 [2 3] 4]
;;  1
;;  [2 3]
;;  2
;;  3
;;  4)
  \end{clojure}
\end{english}

Теперь когда мы получили цепочку локаций, напишем поиск. Предположим, нужно
проверить, есть ли в векторе кейворд \code{:error}. Сначала напишем предикат для
локации~--- равен ли её узел этому значению:

\begin{english}
  \begin{clojure}
(defn loc-error? [loc]
  (-> loc zip/node (= :error)))
  \end{clojure}
\end{english}

Проверим, если ли среди локаций та, что подходит нашему предикату.  Для этого
вызовем \code{some}:

\begin{english}
  \begin{clojure}
(def data [1 [2 3 [:test [:foo :error]]] 4])

(some loc-error?
      (-> data zip/vector-zip iter-zip))

;; true
  \end{clojure}
\end{english}

Из-за ленивости мы не сканируем вектор целиком. Если нужный узел нашелся на
середине, \code{iter-zip} прекращает итерацию, и дальнейшие вызовы \code{zip/next} не
произойдут.

Полезно знать, что \code{zip/next} обходит дерево в глубину. При движении он
стремится вниз и вправо, а наверх поднимается лишь когда шаги в эти стороны
невозможны. Как мы увидим дальше, в некоторых случаях порядок обхода
важен. Попадаются задачи, где мы должны двигаться вширь. По умолчанию в
\code{clojure.zip} нет других вариантов обхода, но мы напишем собственный. Также мы
рассмотрим задачу, где понадобится обход вширь.

Встроенный зиппер \code{vector-zip} служит для вложенных векторов. Но гораздо чаще
встречаются вложенные словари. Напишем зиппер для обхода подобных данных:

\begin{english}
  \begin{clojure}
(def map-data
  {:foo 1
   :bar 2
   :baz {:test "hello"
         :word {:nested true}}})
  \end{clojure}
\end{english}

За основу возьмём знакомый нам \code{vector-zip}. Зипперы похожи, разница лишь в типе
коллекции. Подумаем, как задать функции \code{branch?} и \code{children}. Сам по себе
словарь~--- это ветка, чью потомки~--- элементы \code{MapEntry}. Тип \code{MapEntry} выражает
пару ключа и значения. Если значение~--- словарь, получим из него цепочку
вложенных \code{MapEntry} и так далее.

Для разминки напишем проверку на тип \code{MapEntry}:

\begin{english}
  \begin{clojure}
(def entry?
  (partial instance? clojure.lang.MapEntry))
  \end{clojure}
\end{english}

Зиппер \code{map-zip} выглядит так:

\begin{english}
  \begin{clojure}
(defn map-zip [mapping]
  (zip/zipper
   (some-fn entry? map?)
   (fn [x]
     (cond
       (map? x)
       (seq x)
       (and (entry? x) (-> x val map?))
       (-> x val seq)))
   nil
   mapping))
  \end{clojure}
\end{english}

Поясним основные моменты. Композиция \code{(some-fn ...)} вернёт истину, если хотя бы
один из предикатов сработает положительно. Иными словами, на роль ветки мы
рассматриваем только словарь или его узел (пару ключ-значение).

Во второй функции, которая ищет потомков, приходится делать перебор. Для словаря
(проверка \code{map?}) получим потомков функцией \code{seq}~--- она вернёт цепочку
элементов \code{MapEntry}. Если текущий элемент~--- \code{MapEntry}, проверим, является ли
его значение вложенным словарём (функция \code{var} вернет второй элемент
\code{MapEntry}). Если да, получим потомков той же функцией \code{seq}.

Обход зиппера вернет все пары ключей и значений. Если значение~--- вложенный
словарь, мы провалимся в него при обходе. Пример:

\begin{english}
  \begin{clojure}
(->> {:foo 42
      :bar {:baz 11
            :user/name "Ivan"}}
     map-zip
     iter-zip
     rest
     (map zip/node))

;; ([:foo 42]
;;  [:bar {:baz 11, :user/name "Ivan"}]
;;  [:baz 11]
;;  [:user/name "Ivan"])
  \end{clojure}
\end{english}

Обратите внимание на функцию \code{rest} после \code{iter-zip}. Мы отбросили первую
локацию, в которой находятся исходные данные. Поскольку они известны, нет смысла
печатать их.

С помощью нашего \code{map-zip} легко проверить, есть ли в словаре ключ \code{:error} со
значением \code{:auth}. По отдельности эти кейворды могут быть где угодно~--- и в
ключах, и в значениях на любом уровне. Однако нас интересует их комбинация. Для
этого напишем предикат:

\begin{english}
  \begin{clojure}
(defn loc-err-auth? [loc]
  (-> loc zip/node (= [:error :auth])))
  \end{clojure}
\end{english}

Убедимся, что в первом словаре нет пары, даже не смотря на то, что значения
встречаются по отдельности:

\begin{english}
  \begin{clojure}
(->> {:response {:error :expired
                 :auth :failed}}
     map-zip
     iter-zip
     (some loc-err-auth?))

;; nil
  \end{clojure}
\end{english}

Но даже если пара вложена глубоко, мы найдём её:

\begin{english}
  \begin{clojure}
(def data
  {:response {:info {:message "Auth error"
                     :error :auth
                     :code 1005}}})

(->> data
     map-zip
     iter-zip
     (some loc-err-auth?))

;; true
  \end{clojure}
\end{english}

Предлагаем читателю несколько заданий для самостоятельной работы.

\begin{enumerate}

\item
  Зиппер \code{map-zip} не учитывает случай, когда ключ словаря~--- другой словарь,
  например:

\begin{english}
  \begin{clojure}
{{:alg "MD5" :salt "..."} "deprecated"
 {:alg "SHA2" :salt "..."} "deprecated"
 {:alg "HMAC-SHA256" :key "..."} "ok"}
  \end{clojure}
\end{english}

Такие коллекции хоть и редко, но встречаются в практике. Доработайте \code{map-zip},
чтобы он проверял не только значение \code{MapEntry}, но и ключ (вместо \code{val}
используйте \code{key}).

\item
  Мы рассмотрели зипперы для векторов и словарей по отдельности. На практике мы
  работаем со смешанными данными, когда словари и векторы вложены друг в
  друга. Напишите универсальный зиппер, который учитывает обе коллекции при
  обходе.

\end{enumerate}

\section{XML-зипперы}

Мощь зипперов раскрывается в полной мере при работе с XML. От других форматов он
отличается тем, что задан рекурсивно. Например, JSON, YAML и другие форматы
предлагают типы~--- числа, строки, коллекции,~--- у которых разный синтаксис и
структура. В XML, где бы мы ни находились, текущий узел состоит из трёх
элементов: тега, атрибутов и содержимого.

Тег~--- это короткое имя узла, например \code{name} или \code{description}. Атрибуты~---
словарь свойств и их значений. Наиболее интересно содержимое: это набор строк
или других узлов. Вот как выглядит XML на псевдокоде:

\begin{english}
  \begin{text}
XML = [Tag, Attrs, [String|XML]]
  \end{text}
\end{english}

Чтобы убедиться в однородности XML, рассмотрим файл с товарами поставщиков:

\begin{english}
  \begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
  <organization name="re-Store">
    <product type="iphone">iPhone 11 Pro</product>
    <product type="iphone">iPhone SE</product>
  </organization>
  <organization name="DNS">
    <product type="tablet">iPad 3</product>
    <product type="notebook">Macbook Pro</product>
  </organization>
</catalog>
  \end{xml}
\end{english}

На вершине XML находится узел \code{catalog}. Это группировочный тег: он необходим,
потому что на вершине не может быть несколько тегов. Потомки каталога~---
организации. В атрибуте \code{name} организации указано её имя. Под организацией идут
товары~--- узлы с тегом \code{product} и атрибутом \code{type}. Вместо потомков товар
содержит текст~--- подробное описание. Ниже него спуститься уже нельзя.

Clojure предлагает XML-парсер, который вернет структуру, похожую на схему
\code{[Tag, Attrs, Content]} выше. Каждый узел станет словарем с ключами
\code{:tag}, \code{:attrs} и \code{:content}. Последний хранит вектор, где
элемент либо строка, либо вложенный словарь.

Поместим XML с товарами в файл \code{resources/products.xml}. Напишем функцию, чтобы
считать файл в XML-зиппер. Добавьте модули \code{xml} и \code{io}:

\begin{english}
  \begin{clojure}
(:require
 [clojure.java.io :as io]
 [clojure.xml :as xml])
  \end{clojure}
\end{english}

Оба входят в поставку Clojure и не требуют зависимостей. Чтобы получить зиппер,
пропустим параметр \code{path} через серию функций:

\begin{english}
  \begin{clojure}
(defn ->xml-zipper [path]
  (-> path
      io/resource
      io/file
      xml/parse
      zip/xml-zip))
  \end{clojure}
\end{english}

Функция \code{xml/parse} вернёт структуру словарей с ключами \code{:tag}, \code{:attrs} и
\code{:content}. Обратите внимание, что текстовое содержимое, например, название
товара, это тоже вектор с одной строкой. Тем самым достигается однородность
каждого узла.

Вот что получим после вызова \code{xml/parse}:

\begin{english}
  \begin{clojure}
{:tag :catalog
 :attrs nil
 :content
 [{:tag :organization
   :attrs {:name "re-Store"}
   :content
   [{:tag :product
     :attrs {:type "iphone"}
     :content ["iPhone 11 Pro"]}
    {:tag :product
     :attrs {:type "iphone"}
     :content ["iPhone SE"]}]}
  {:tag :organization
   :attrs {:name "DNS"}
   :content
   [{:tag :product
     :attrs {:type "tablet"}
     :content ["iPad 3"]}
    {:tag :product
     :attrs {:type "notebook"}
     :content ["Macbook Pro"]}]}]}
  \end{clojure}
\end{english}

Вызов \code{(->xml-zipper "products.xml")} вернет первую локацию зиппера XML. Прежде
чем работать с ним, заглянем в определение \code{xml-zip}, чтобы понять, что
происходит. Приведём код из \code{clojure.zip} в сокращении:

\begin{english}
  \begin{clojure}
(defn xml-zip
  [root]
  (zipper (complement string?)
          (comp seq :content)
          ...
          root))
  \end{clojure}
\end{english}

Очевидно, потомки узла~--- это его содержимое \code{:content}, дополнительно обёрнутое
в \code{seq}. У строки не может быть потомков, поэтому \code{(complement string?)}
означает: искать потомков в узлах, отличных от строки.

Рассмотрим, как бы мы нашли все товары из заданного XML. Для начала получим
ленивую итерацию по зипперу. Напомним, что на каждом шаге мы получим не словарь
с полями \code{:tag} и другими, а локацию с указателем на него. Останется
отфильтровать локации, чьи узлы содержат тег \code{product}. Для этого напишем
предикат:

\begin{english}
  \begin{clojure}
(defn loc-product? [loc]
  (-> loc zip/node :tag (= :product)))
  \end{clojure}
\end{english}

\noindent
и выборку с преобразованием:

\begin{english}
  \begin{clojure}
(->> "products.xml"
     ->xml-zipper
     iter-zip
     (filter loc-product?)
     (map loc->product))

;; ("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro")
  \end{clojure}
\end{english}

На первый взгляд здесь ничего особенного. Структура XML известна заранее,
поэтому можно обойтись без зиппера. Для этого выберем потомков каталога и
получим организации; из потомков организаций получим товары. Вместе получится
простой код:

\begin{english}
  \begin{clojure}
(def xml-data
  (-> "products.xml"
      io/resource
      io/file
      xml/parse))

(def orgs
  (:content xml-data))

(def products
  (mapcat :content orgs))

(def product-names
  (mapcat :content products))
  \end{clojure}
\end{english}

Для краткости уберем переменные и сведем код к одной форме:

\begin{english}
  \begin{clojure}
(->> "products.xml"
     io/resource
     io/file
     xml/parse
     :content
     (mapcat :content)
     (mapcat :content))

;; ("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro")
  \end{clojure}
\end{english}

На практике структура XML неоднородна. Предположим, крупный поставщик разбивает
товары по филиалам. В его случае XML выглядит так (фрагмент):

\begin{english}
  \begin{xml}
<organization name="DNS">
  <branch name="Office 1">
    <product type="tablet">iPad 3</product>
    <product type="notebook">Macbook Pro</product>
  </branch>
</organization>
  \end{xml}
\end{english}

Код выше, где мы слепо выбираем данные по уровню, сработает неверно. В списке
товаров окажется узел:

\begin{english}
  \begin{clojure}
("iPhone 11 Pro"
 "iPhone SE"
 {:tag :product :attrs {:type "tablet"} :content ...})
  \end{clojure}
\end{english}

В то время как зиппер вернёт \textbf{только} товары, в том числе из филиала:

\begin{english}
  \begin{clojure}
(->> "products-branch.xml"
     ->xml-zipper
     iter-zip
     (filter loc-product?)
     (map loc->product))

("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro")
  \end{clojure}
\end{english}

Очевидно, выгодно пользоваться кодом, который работает с обоими XML, а не
поддерживать отдельную версию для крупного поставщика. В противном случае нужно
где-то хранить признак и делать по нему \code{if/else}, что усложнит проект.

Однако и этот пример не раскрывает всю мощь зипперов. Для обхода XML служит
функция \code{xml-seq} из главного модуля Clojure. Она возвращает ленивую цепочку
XML-узлов в том же виде (словарь с ключами \code{:tag}, \code{:attr} и
\code{:content}). \code{Xml-seq}~--- это частный случай более абстрактной функции
\code{tree-seq}. Последняя похожа на зиппер тем, что принимает функции \code{branch?} и
\code{children}, чтобы определить, подходит ли узел на роль ветки и как извлечь
потомков. Определение \code{xml-seq} напоминает \code{xml-zip}:

\begin{english}
  \begin{clojure}
(defn xml-seq
  [root]
  (tree-seq (complement string?)
            (comp seq :content)
            root))
  \end{clojure}
\end{english}

Разница между зиппером и \code{tree-seq} в том, что при итерации зиппер возвращает
локацию~--- элемент, который несёт больше сведений. Кроме данных он содержит
ссылки на элементы по всем четырем направлениям. Наоборот, \code{tree-seq} итерирует
данные без обёрток. Для обычного поиска \code{tree-seq} даже предпочтительней,
поскольку не порождает лишних абстракций. Вот как выглядит сбор товаров с учётом
филиалов:

\begin{english}
  \begin{clojure}
(defn node-product? [node]
  (some-> node :tag (= :product)))

(->> "products-branch.xml"
     io/resource
     io/file
     xml/parse
     xml-seq
     (filter node-product?)
     (mapcat :content))

("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro")
  \end{clojure}
\end{english}

Чтобы показать мощь зипперов, подберём такую задачу, где возможностей \code{tree-seq}
не хватает. На эту роль подойдёт поиск с переходом между локациями.

\section{Поиск в XML}

Предположим, нам поставили задачу: выбрать из XML магазины, где продаются
айфоны. Обратите внимание: мы впервые коснулись связи между узлами, и это
важно. По отдельности выбрать данные легко. Магазины~--- это локации, у которых
тег \code{organization}. Айфоны~--- локации, в которых узел с тегом \code{product} и
атрибутом \code{type="tablet"}. Но как найти связь между ними?

В прошлый раз мы разложили XML в последовательность с помощью
\code{xml-seq}. Проблема в том, что функция порождает коллекцию узлов без какой-либо
связи, что не даёт нам решить задачу. Покажем это на примере. Для начала получим
цепочку узлов:

\begin{english}
  \begin{clojure}
(def xml-nodes
  (->> "products-branch.xml"
       io/resource
       io/file
       xml/parse
       xml-seq))
  \end{clojure}
\end{english}

Вообразим, что в одном из элементов находится нужный товар. Например, мы
встретим айфон в третьем (втором от нуля) узле:

\begin{english}
  \begin{clojure}
(-> xml-nodes (nth 2))
;; {:tag :product
;;  :attrs {:type "iphone"}
;;  :content ["iPhone 11 Pro"]}
  \end{clojure}
\end{english}

Однако трудно найти магазин, которому он принадлежит. Можно догадаться, что
магазин находится слева от товара, потому что предшествует ему в обходе
дерева. Это станет ясно, если напечатать теги узлов:

\begin{english}
  \begin{clojure}
(->> xml-nodes (mapv :tag) (remove nil?) (run! print))
;; :catalog :organization :product :product ...
  \end{clojure}
\end{english}

Идея верная, но в целом слабая, потому что зависит от порядка обхода. Кроме
того, задача усложняется: при обходе нужно не просто выбрать нужные товары, но и
переместиться назад в поисках магазина. Затем продолжить вперед и при этом
пропустить найденный товар, чтобы не попасть в вечный цикл. Схема подразумевает
состояние и хорошо смотрелась бы на императивных языках, но не в Clojure.

Здесь и приходит на помощь зиппер. Локация, которую он возвращает на каждом
шаге, помнит положение в структуре. От локации можно пройти в нужное место с
помощью функций \code{zip/up}, \code{zip/right} и других, что мы рассмотрели в первой
части. Это тот случай, когда ручная навигация оправдана.

Вернемся к XML со структурой <<каталог~--- организация~--- товары>>. Освежим его в
памяти:

\begin{english}
  \begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
  <organization name="re-Store">
    <product type="iphone">iPhone 11 Pro</product>
    <product type="iphone">iPhone SE</product>
  </organization>
  <organization name="DNS">
    <product type="tablet">iPad 3</product>
    <product type="notebook">Macbook Pro</product>
  </organization>
</catalog>
  \end{xml}
\end{english}

Прежде всего найдём локации-айфоны. Напишем предикат на айфон:

\begin{english}
  \begin{clojure}
(defn loc-iphone? [loc]
  (let [node (zip/node loc)]
    (and (-> node :tag (= :product))
         (-> node :attrs :type (= "iphone")))))
  \end{clojure}
\end{english}

Получим локации с айфонами:

\begin{english}
  \begin{clojure}
(def loc-iphones
  (->> "products.xml"
       ->xml-zipper
       iter-zip
       (filter loc-iphone?)))

(count loc-iphones)
2
  \end{clojure}
\end{english}

Теперь, чтобы найти организацию по товару, поднимемся на уровень выше с помощью
\code{zip/up}. Это верно, потому что организация~--- родитель товара:

\begin{english}
  \begin{clojure}
(def loc-orgs
  (->> loc-iphones
       (map zip/up)
       (map (comp :attrs zip/node))))

({:name "re-Store"}
 {:name "re-Store"})
  \end{clojure}
\end{english}

Для каждого айфона мы получим организацию, где его продают. Получились дубли,
потому что оба айфона продаются в re-Store. Чтобы избавиться от повторов,
оберните результат в \code{set}.

\begin{english}
  \begin{clojure}
(set loc-orgs)
#{{:name "re-Store"}}
  \end{clojure}
\end{english}

Это и есть ответ на вопрос: айфоны можно купить в магазине re-Store. Если
добавить айфон в организацию DNS, она тоже появится в \code{loc-orgs}.

Решим ту же задачу для XML с филиалами. Мы не можем вызвать \code{zip/up} для товара,
чтобы получить организацию, потому что в некоторых случаях получим филиал, и
понадобится еще один шаг вверх. Чтобы не гадать, сколько раз подниматься,
напишем функцию \code{loc->org}. Она вызывает \code{zip/ах} до тех пор, пока не выйдет на
нужный тег:

\begin{english}
  \begin{clojure}
(defn loc-org? [loc]
  (-> loc zip/node :tag (= :organization)))

(defn loc->org [loc]
  (->> loc
       (iterate zip/up)
       (find-first loc-org?)))
  \end{clojure}
\end{english}

Функция \code{find-first} находит первый элемент коллекции, который подошёл
предикату. Она ещё не раз пригодится нам.

\begin{english}
  \begin{clojure}
(defn find-first [pred coll]
  (some (fn [x]
          (when (pred x)
            x))
        coll))
  \end{clojure}
\end{english}

Чтобы сократить код, не будем объявлять переменные \code{loc-iphones} и
другие. Выразим поиск одной формой:

\begin{english}
  \begin{clojure}
(->> "products-branch.xml"
     ->xml-zipper
     iter-zip
     (filter loc-iphone?)
     (map loc->org)
     (map (comp :attrs zip/node))
     (set))
  \end{clojure}
\end{english}

Новое решение отличается лишь тем, что мы заменили \code{zip/up} на функцию с более
сложным восхождением. В остальном ничего не изменилось.

Обратите внимание, насколько удобен XML в плане поиска и навигации. Если бы мы
хранили данные в JSON, их структура и обход сильно бы отличались. Сравните
товары без филиалов:

\begin{english}
  \begin{json}
[
  {
    "name": "re-Store",
    "products": [
       {"type": "iphone", "name": "iPhone 11 Pro"},
       {"type": "iphone", "name": "iPhone SE"}
    ]
  },
  {
    "name": "DNS",
    "products": [
      {"type": "tablet", "name": "iPad 3"},
      {"type": "notebook", "name": "Macbook Pro"}
    ]
  }
]
  \end{json}
\end{english}

\noindent
и с ними:

\begin{english}
  \begin{json}
[
  {
    "name": "re-Store",
    "products": [
       {"type": "iphone", "name": "iPhone 11 Pro"},
       {"type": "iphone", "name": "iPhone SE"}
    ]
  },
  {
    "name": "DNS",
    "branches": [
      {
        "name": "Office 1",
        "products": [
          {"type": "tablet", "name": "iPad 3"},
          {"type": "notebook", "name": "Macbook Pro"}
        ]
      },
      {
        "name": "Office 2",
        "products": [
          {"type": "tablet", "name": "iPad 3"},
          {"type": "notebook", "name": "Macbook Pro"}
        ]
      }
    ]
  }
]
  \end{json}
\end{english}

Очевидно, для работы с этими данными нужен разный код. В случае с XML его
структура однородна: добавление филиала меняет лишь глубину товаров, но не
правило обхода.

Усложним задачу: среди обычных товаров встречаются наборы из них (bundle). Товар
из набора нельзя купить отдельно. Например, тряпочка для протирки экрана
продаётся чаще всего с устройством. Нас просят найти магазин, где тряпочку можно
купить отдельно.

Пример XML с наборами:

\begin{english}
  \begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
  <organization name="re-Store">
    <product type="fiber">VIP Fiber Plus</product>
    <product type="iphone">iPhone 11 Pro</product>
  </organization>
  <organization name="DNS">
    <branch name="Office 2">
      <bundle>
        <product type="fiber">Premium iFiber</product>
        <product type="iphone">iPhone 11 Pro</product>
      </bundle>
    </branch>
  </organization>
</catalog>
  \end{xml}
\end{english}

Сначала найдём все тряпочки. В них окажутся как отдельные товары, так и из
набора:

\begin{english}
  \begin{clojure}
(defn loc-fiber? [loc]
  (some-> loc zip/node :attrs :type (= "fiber")))

(->> "products-bundle.xml"
     ->xml-zipper
     iter-zip
     (filter loc-fiber?)
     (map (comp first :content zip/node)))

("VIP Fiber Plus" "Premium iFiber")
  \end{clojure}
\end{english}

Теперь решим задачу. Из найденных тряпочек отсекаем те, что входят в набор. С
точки зрения зиппера это значит, что у родителя этой локации тег не равен
\code{:bundle}. От оставшихся тряпочек переходим к магазинам.

Введём предикат \code{loc-in-bundle?}~--- входит ли локация в набор или нет:

\begin{english}
  \begin{clojure}
(defn loc-in-bundle? [loc]
  (some-> loc zip/up zip/node :tag (= :bundle)))
  \end{clojure}
\end{english}

Решение:

\begin{english}
  \begin{clojure}
(->> "products-bundle.xml"
     ->xml-zipper
     iter-zip
     (filter loc-fiber?)
     (remove loc-in-bundle?)
     (map loc->org)
     (map (comp :attrs zip/node))
     (set))

#{{:name "re-Store"}}
  \end{clojure}
\end{english}

Магазин DNS не попал в результат, потому что в нём тряпочка продаётся в наборе.

Новое усложнение: мы хотим купить айфон, \emph{но только в наборе} с тряпочкой. В
какой магазин направить покупателя?

Решение: сначала ищем все айфоны. Оставляем те, что входят в набор. Среди
соседей айфона ищем тряпочку. Если нашли, переходим от айфона или тряпочки к
магазину. Основные функции уже готовы: это предикаты на проверку набора, тип
товара и другие мелочи. Но мы не рассмотрели, как получить соседей локации.

Функции \code{zip/lefts} и \code{zip/rights} вернут узлы по левую и правую стороны от
текущей локации. Совместим их через \code{concat}, чтобы получить всех соседей:

\begin{english}
  \begin{clojure}
(defn node-neighbors [loc]
  (concat (zip/lefts loc)
          (zip/rights loc)))
  \end{clojure}
\end{english}

Уточним, что это будут именно узлы, а не локации. Покажем это на примере
вектора:

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/right
    node-neighbors)

;; (1 3)
  \end{clojure}
\end{english}

Зиппер устроен так, что получить правые и левые узлы проще, чем передвигать
локацию влево или вправо. Поэтому при поиске соседей выгодно работать с узлами
(данными), а не локациями.

Добавим функции, чтобы проверить, если в соседях локации тряпочка:

\begin{english}
  \begin{clojure}
(defn node-fiber? [node]
  (some-> node :attrs :type (= "fiber")))

(defn with-fiber? [loc]
  (let [nodes (node-neighbors loc)]
    (find-first node-fiber? nodes)))
  \end{clojure}
\end{english}

Финальное выражение:

\begin{english}
  \begin{clojure}
(->> "products-bundle.xml"
     ->xml-zipper
     iter-zip
     (filter loc-iphone?)
     (filter loc-in-bundle?)
     (filter with-fiber?)
     (map loc->org)
     (map (comp :name :attrs zip/node))
     (set))

;; #{"DNS"}
  \end{clojure}
\end{english}

В результате получим магазин DNS, потому что именно в нём айфон продается в
комплекте с тряпкой. Оба этих товара продаются и в re-Store, но по отдельности,
что не подходит. Если заменить в наборе тряпочку на гарнитуру, мы не получим ни
один магазин.

Можно добавить больше ограничений. Например, из найденных магазинов выбрать те,
что расположены в радиусе 300 метров от покупателя. Для этого понадобится
расположение магазинов на карте и функция попадания точки в окружность. Можно
выбрать только открытые магазины или те, что предлагают доставку. Запишем эти
признаки в атрибуты организаций и добавим функции отбора.

Легко увидеть, что XML-зиппер стал настоящей базой данных. Он даёт ответы на
сложные запросы, и при этом код растет медленней, чем их смысловая
нагрузка. Из-за рекурсивной структуры XML хорошо поддается обходу, и зипперы
усиливают это преимущество. Обратите внимание, как удобно работают переходы и
связи между узлами. Представьте, каких усилий стоило бы разбить данные на
таблицы и строить SQL-запросы со многими JOIN.

Конечно, по сравнению с настоящей базой у XML недостаток~--- в нём нет индексов, и
поиск работает линейным перебором, а не как в бинарных деревьях. Кроме того, наш
подход требует, чтобы все находились в памяти целиком. Он не сработает для очень
больших документов с миллионами записей, но пока что не будем волноваться об
этом.

\section{Редактирование}

До сих пор мы игнорировали другую возможность зипперов. Во время обхода можно не
только читать, но и менять локации. В широком плане нам доступны все операции
CRUD (Create, Read, Update, Delete), знакомые из веб-разработки. Ниже мы
разберем, как они работают в зипперах.

Напомним, зиппер принимает третью функцию \code{make-node}, в которую до сих пор мы
передавали \code{nil}. В ней не было нужды, потому что мы только читали
данные. Зиппер вызовет функцию в момент, когда мы просим вернуть данные с учётом
изменений, которые внесли в локации. Функция принимает два параметра: ветку и
потомков. Ее задача~--- соединить их должным образом.

Для простых коллекций вроде вектора функция проста~--- нужно только обернуть
потомков в \code{vec}, чтобы получить из последовательности вектор. В \code{vector-zip}
функция чуть сложнее, потому что учитывает метаданные. Приведём код этого
зиппера без сокращений:

\begin{english}
  \begin{clojure}
(defn vector-zip
  [root]
  (zipper vector?
          seq
          (fn [node children]
            (with-meta (vec children) (meta node)))
          root))
  \end{clojure}
\end{english}

Видим, что новый вектор (форма \code{(vec children)}) копирует метаданные прежнего
вектора (переменная \code{node}). Если вы дополняете оригинал через \code{assoc} или
\code{conj}, метаданные сохраняются. В случае с \code{vector-zip} мы строим новый вектор,
поэтому оборачиваем его в \code{with-meta}. Если убрать \code{with-meta}, на выходе
получим вектор без метаданных, что может повлиять на логику программы.

У XML-зиппера сборка иная: потомков помещают в поле \code{:content}.

\begin{english}
  \begin{clojure}
(fn [node children]
  (assoc node :content
              (and children (apply vector children))))
  \end{clojure}
\end{english}

Для нашего \code{map-zip}, который работает со словарями, функция сборки выглядела бы
как \code{assoc} или \code{into} с набором пар \code{MapEntry}.

Зиппер неявно вызывает эту функцию, если находит изменённые узлы. Для изменения
служат функции \code{zip/edit}, \code{zip/replace} и другие. Но перед тем, как рассмотреть
их, объясним, как именно протекают изменения в зиппере.

Особенность в том, что изменения сказываются не на исходных данных, а на
локациях. Если изменить текущую локацию, она помечается флагом \code{:changed?}. Это
сигнал к пересборке данных с помощью функции \code{zip/root}, о которой скажем чуть
позже.

Рассмотрим пример с вектором \code{[1 2 3]}. Переместимся на двойку и удвоим её с
помощью функции \code{zip/edit}. Она принимает локацию, функцию и остаточные
аргументы~--- подход, знакомый вам из атомов (\code{swap!}) и коллекций (\code{update}). По
аналогии с ними, локация получит новое значение, которое вернула функция на базе
прежнего.

Локация до изменений:

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/right)

[2 {:l [1] :pnodes [[1 2 3]] :ppath nil :r (3)}]
  \end{clojure}
\end{english}

\noindent
и после. Обратите внимание ключ \code{:changed?}:

\begin{english}
  \begin{clojure}
(def loc-2
  (-> [1 2 3]
      zip/vector-zip
      zip/down
      zip/right
      (zip/edit * 2)))

[4 {:l [1] :pnodes [[1 2 3]] :ppath nil :r (3)
    :changed? true}]
  \end{clojure}
\end{english}

Далее нам бы хотелось получить изменённый вектор \code{[1 4 3]}. Сделаем это вручную:

\begin{english}
  \begin{clojure}
(-> loc-2
    zip/up
    zip/node)
;; [1 4 3]
  \end{clojure}
\end{english}

То же самое делает функция \code{zip/root}, которая принимает локацию с
изменениями. Её алгоритм следующий:

\begin{itemize}

\item
  подняться до первичной локации, повторно вызывая \code{zip/up};

\item
  вернуть узел.

\end{itemize}

Чтобы получить результат за один проход, добавим \code{zip/root} на конец стрелочного
оператора:

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/right
    (zip/edit * 2)
    zip/root)
;; [1 4 3]
  \end{clojure}
\end{english}

Основная работа происходит в функции \code{zip/up}, которую мы вызвали вручную или
неявно в \code{zip/root}. При подъёме вверх она проверяет, была ли изменена локация,
и если да, перестраивает её с помощью \code{make-node}. Приведём её код в сокращении:

\begin{english}
  \begin{clojure}
(defn up
  [loc]
  (let [[node {... changed? :changed? :as path}] loc]
    (when pnodes
      (let [pnode (peek pnodes)]
        (with-meta (if changed?
                     [(make-node loc pnode (concat l ...))
                      (and ppath (assoc ...))]
                     [pnode ppath])
                   (meta loc))))))
  \end{clojure}
\end{english}

\subsection{Множественное изменение}

При изменении одной локации проблем не возникает. Однако мы редко изменяем одну
локацию~--- на практике это делают по признаку, то есть пакетно.

Ранее мы раскладывали зиппер в цепочку локаций с помощью \code{iter-zip}, а затем
пропускали через серию \code{map}, \code{filter} и других функций. Для редактирования этот
метод не подходит. Предположим, мы выбрали второй элемент из результата
\code{zip-iter} и исправили его:

\begin{english}
  \begin{clojure}
(def loc-seq
  (-> [1 2 3]
      zip/vector-zip
      iter-zip))

(-> loc-seq (nth 2) (zip/edit * 2))
;; [4 {:l [1] :pnodes [[1 2 3]] :ppath nil :r (3)
;;    :changed? true}]
  \end{clojure}
\end{english}

Функция \code{zip-iter} устроена так, что каждая следующая локация получается из
предыдущей. Вызов \code{zip/edit} на одном из элементов не повлияет на
последующие. Если подняться вверх от последней локации, получим вектор без
изменений.

\begin{english}
  \begin{clojure}
(-> loc-seq last zip/up zip/node)
;; [1 2 3]
  \end{clojure}
\end{english}

Как видно из примера, выражение с \code{zip/edit} не повлияло на результат.

При редактировании зипперов применяют следующие техники.

\textbf{Изменяется один элемент.} В этом случае мы итерируем зиппер до тех пор, пока
не встретим нужную локацию в цепочке. Затем меняем её и вызываем \code{zip/root}.

\textbf{Изменяются многие элементы.} С помощью функций \code{loop} и
\code{zip/next} мы вручную итерируем зиппер. При этом задана функция, которая
либо меняет локацию, любо оставляет нетронутой. В форму \code{recur} попадает
\code{zip/next} от её результата. Если изменения были, \code{zip/next}
оттолкнётся от новой, а не исходной локации.

Для изменения локаций служат функции:

\begin{itemize}

\item
  \code{zip/replace}~--- буквальная замена текущего узла на другой.

\item
  \code{zip/edit}~--- Редактирование узла. По аналогии с \code{update} и \code{swap!} принимает
  функцию и добавочные аргументы. Первым аргументом функция получит текущей
  узел. Результат заменит содержимое локации.

\item
  \code{zip/remove}~--- Удаляет локацию и перемещает указатель на родителя.

\end{itemize}

Функции для вставки соседей и потомков:

\begin{itemize}

\item
  \code{zip/insert-left}~--- добавить соседа слева от текущей локации;

\item
  \code{zip/insert-right}~--- добавить соседа справа;

\item
  \code{zip/insert-child}~--- добавить текущей локации потомка в начало;

\item
  \code{zip/append-child}~--- добавить потомка в конец.

\end{itemize}

Разница между соседом и потомком в иерархии. Сосед находится на одном уровне с
локацией, а потомок ниже. В центре диаграммы находится локация с вектором \code{[2
3]}. Её соседи~--- числа 1 и 4, а потомки~--- 2 и 3.

\begin{figure}[H]
  \centering
  \includesvg{charts/zip12.svg}
  \caption{Иерархия вектора}
  \label{fig:chart-zip-12}
\end{figure}

Рассмотрим функции на простых примерах. Предположим, в глубине вложенных
векторов находится ключ \code{:error}, и нужно исправить его на \code{:ok}. Сперва добавим
предикат для поиска:

\begin{english}
  \begin{clojure}
(defn loc-error? [loc]
  (some-> loc zip/node (= :error)))
  \end{clojure}
\end{english}

Теперь ищем локацию, исправляем её и поднимаемся к корню:

\begin{english}
  \begin{clojure}
(def data [1 2 [3 4 [5 :error]]])

(def loc-error
  (->> data
       zip/vector-zip
       iter-zip
       (find-first loc-error?)))

(-> loc-error
    (zip/replace :ok)
    zip/root)

;; [1 2 [3 4 [5 :ok]]]
  \end{clojure}
\end{english}

Другой пример~--- поменять во вложеном векторе все \code{nil} на 0, чтобы обезопасить
математические расчеты. На этот раз локация может быть не одна, поэтому
понадобится обход через \code{loop}. На каждом шаге мы проверяем, подходит ли
локация, и если да, передаём в \code{recur} вызов \code{zip/next} от изменённой версии:

\begin{english}
  \begin{clojure}
(def data [1 2 [5 nil 2 [3 nil]] nil 1])

(loop [loc (zip/vector-zip data)]
  (if (zip/end? loc)
    (zip/node loc)
    (if (-> loc zip/node nil?)
      (recur (zip/next (zip/replace loc 0)))
      (recur (zip/next loc)))))

;; [1 2 [5 0 2 [3 0]] 0 1]
  \end{clojure}
\end{english}

То же самое, но заменить все отрицательные числа по модулю. Для начала объявим
функцию \code{abs} (с версии 1.11 она встроена в Clojure):

\begin{english}
  \begin{clojure}
(defn abs [num]
  (if (neg? num)
    (- num)
    num))
  \end{clojure}
\end{english}

Обход похож на предыдущий, но теперь вместо \code{zip/replace} мы вызываем
\code{zip/edit}, который обновляет содержимое локации, отталкиваясь от прежнего
значения:

\begin{english}
  \begin{clojure}
(def data [-1 2 [5 -2 2 [-3 2]] -1 5])

(loop [loc (zip/vector-zip data)]
  (if (zip/end? loc)
    (zip/node loc)
    (if (and (-> loc zip/node number?)
             (-> loc zip/node neg?))
      (recur (zip/next (zip/edit loc abs)))
      (recur (zip/next loc)))))
  \end{clojure}
\end{english}

В обоих случаях цикл выглядит одинаково. Если это конечная локация, вернём её
узел. В противном случае, если локация подходит предикату, меняем ее содержимое
с помощью \code{zip/edit}. От изменённой локации переходим к следующей. Это ключевой
момент: в предпоследней строке вызов \code{zip/next} принимает результат \code{zip/edit},
а не исходную локацию. Поэтому изменения будут переданы в следующий шаг \code{loop}.

Примеры выше образуют паттерны~--- повторяющиеся приёмы. Поместим их в отдельные
функции, чтобы не тратить на них внимание в будущем.

\textbf{Поиск локации по предикату.} Принимает начальную локацию и предикат, начинает
итерацию. Вернёт первую же локацию, которая подошла предикату:

\begin{english}
  \begin{clojure}
(defn find-loc [loc loc-pred]
  (->> loc
       iter-zip
       (find-first loc-pred)))
  \end{clojure}
\end{english}

\textbf{Обход локаций с изменениями.} Перебирает локации с помощью \code{zip/next} и
\code{loop/recur}. При переходе на следующий шаг оборачивает локацию в
функцию. Ожидается, что функция либо изменит локацию, либо вернёт её без
изменений. Это обобщённая версия цикла, что мы написали выше.

\begin{english}
  \begin{clojure}
(defn alter-loc [loc loc-fn]
  (loop [loc loc]
    (if (zip/end? loc)
      loc
      (-> loc loc-fn zip/next recur))))
  \end{clojure}
\end{english}

Перепишем примеры с новыми функциями. Найдём в векторе локацию, чей узел равен
двойке:

\begin{english}
  \begin{clojure}
(defn loc-2? [loc]
  (-> loc zip/node (= 2)))

(def loc-2
  (-> [1 2 3]
      zip/vector-zip
      (find-loc loc-2?)))
  \end{clojure}
\end{english}

Удвоим её и выйдем на конечный вектор:

\begin{english}
  \begin{clojure}
(-> loc-2 (zip/edit * 2) zip/root)
;; [1 4 2]
  \end{clojure}
\end{english}

Изменим отрицательные числа по модулю. Для этого заведём функцию \code{loc-abs}. Если
в узле отрицательное число, вернём исправленную локацию, а иначе~--- исходную:

\begin{english}
  \begin{clojure}
(defn loc-abs [loc]
  (if (and (-> loc zip/node number?)
           (-> loc zip/node neg?))
    (zip/edit loc abs)
    loc))
  \end{clojure}
\end{english}

Осталось передать её в \code{alter-loc}:

\begin{english}
  \begin{clojure}
(-> [-1 2 [5 -2 2 [-3 2]] -1 5]
    zip/vector-zip
    (alter-loc loc-abs)
    zip/node)

;; [1 2 [5 2 2 [3 2]] 1 5]
  \end{clojure}
\end{english}

Как только мы вынесли часть кода в функции, преобразования стали короче и
понятней. Как правило, любое действие над зиппером можно обобщить и поместить в
функцию, тем самым упростив логику.

\subsection{Цены в XML}

Перейдём к практическим примерам с XML и товарами. Подготовим файл
\code{products-price.xml} (листинг \ref{fig:chart-xml-01} справа). Обратите
внимание, что у товаров появились цены~--- характеристика, которая часто
меняется.

\begin{figure}[ht!]

\begin{english}
  \begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
  <organization name="re-Store">
    <product type="fiber" price="8.99">
      VIP Fiber Plus
    </product>
    <product type="iphone" price="899.99">
      iPhone 11 Pro
    </product>
  </organization>
  <organization name="DNS">
    <branch name="Office 2">
      <bundle>
        <product type="fiber" price="9.99">
          Premium iFiber
        </product>
        <product type="iphone" price="999.99">
          iPhone 11 Pro
        </product>
      </bundle>
    </branch>
  </organization>
</catalog>
  \end{xml}
\end{english}

\caption{XML с товарами и ценами}
\label{fig:chart-xml-01}

\end{figure}

Напомним, что с точки зрения Clojure XML~--- это вложенные словари с ключами
\code{:tag}, \code{:attrs} и \code{:content}. После изменений мы бы хотели видеть его в
привычном, текстовом виде. Понадобится обратное действие~--- из структуры данных
получить XML в виде текста. Для этого импортируем модуль \code{clojure.xml}. Его
функция \code{emit} выводит XML на печать.

Часто \code{emit} оборачивают в \code{with-out-str}~--- макрос для перехвата печати в
строку. В примерах ниже мы просто выводим XML в консоль. \code{Emit} не поддерживает
отступы, поэтому мы добавили их вручную для ясности.

\textbf{Первая задача}~--- сделать скидку 10\% на все айфоны. У нас готовы почти все
абстракции, так что опишем решение сверху вниз:

\begin{english}
  \begin{clojure}
(require '[clojure.xml :as xml])

(-> "products-price.xml"
    ->xml-zipper
    (alter-loc alter-iphone-price)
    zip/node
    xml/emit)
  \end{clojure}
\end{english}

Этих пяти строк достаточно для нашей задачи. Под вопросом только функция
\code{alter-iphone-price}. Ожидается, что для локации-айфона она вернёт её же, но с
другим атрибутом \code{price}. Локация другого типа останется без изменений. Опишем
функцию:

\begin{english}
  \begin{clojure}
(defn alter-iphone-price [loc]
  (if (loc-iphone? loc)
    (zip/edit loc alter-attr-price 0.9)
    loc))
  \end{clojure}
\end{english}

Предикат \code{loc-iphone?} проверяет локацию на "айфонность". Мы уже писали его в
прошлом разделе:

\begin{english}
  \begin{clojure}
(defn loc-iphone? [loc]
  (let [node (zip/node loc)]
    (and (-> node :tag (= :product))
         (-> node :attrs :type (= "iphone")))))
  \end{clojure}
\end{english}

Осталась функция \code{alter-attr-price}. Она принимает узел (содержимое локации) и
должна изменить его атрибут \code{:price}. Второй аргумент функции~--- коэффициент, на
который нужно умножить текущую цену. Небольшая трудность в том, что атрибуты в
XML~--- строки. Чтобы выполнить умножение, нужно вывести число из строки, умножить
на коэффициент, а результат привести в строку с округлением до двух цифр. Все
вместе даёт нам функцию:

\begin{english}
  \begin{clojure}
(defn alter-attr-price [node ratio]
  (update-in node [:attrs :price]
             (fn [price]
               (->> price
                    read-string
                    (* ratio)
                    (format "%.2f")))))
  \end{clojure}
\end{english}

Быстрая проверка этой функции:

\begin{english}
  \begin{clojure}
(alter-attr-price {:attrs {:price "10"}} 1.1)
;; {:attrs {:price "11.00"}}
  \end{clojure}
\end{english}

Теперь когда известны все компоненты, запустим первое выражение и получим XML:

\begin{english}
  \begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
  <organization name="re-Store">
    <product price="8.99" type="fiber">VIP Fiber Plus</product>
    <product price="809.99" type="iphone">iPhone 11 Pro</product>
  </organization>
  <organization name="DNS">
    <branch name="Office 2">
      <bundle>
        <product price="9.99" type="fiber">Premium iFiber</product>
        <product price="899.99" type="iphone">iPhone 11 Pro</product>
      </bundle>
    </branch>
  </organization>
</catalog>
  \end{xml}
\end{english}

Видим, что цена на айфоны изменилась на 10%, а у остальных товаров осталась
прежней.

\textbf{Более сложная задача}~--- во все наборы (бандлы) добавить новый товар~---
гарнитуру. Опять же, опишем решение сверху вниз:

\begin{english}
  \begin{clojure}
(-> "products-price.xml"
    ->xml-zipper
    (alter-loc add-to-bundle)
    zip/node
    xml/emit)
  \end{clojure}
\end{english}

Решение отличается только функций \code{add-to-bundle}. Её логика следующая: если
текущая локация~--- набор, добавить ему потомка, а если нет, просто вернуть
локацию.

\begin{english}
  \begin{clojure}
(defn add-to-bundle [loc]
  (if (loc-bundle? loc)
    (zip/append-child loc node-headset)
    loc))
  \end{clojure}
\end{english}

Проверка на набор:

\begin{english}
  \begin{clojure}
(defn loc-bundle? [loc]
  (some-> loc zip/node :tag (= :bundle)))
  \end{clojure}
\end{english}

Функция \code{zip/append-child} добавляет значение в конец потомков локации. В данном
случае это узел \code{node-headset}, который вынесли в константу:

\begin{english}
  \begin{clojure}
(def node-headset
  {:tag :product
   :attrs {:type "headset"
           :price "199.99"}
   :content ["AirPods Pro"]})
  \end{clojure}
\end{english}

Итоговый XML, где в наборах появился новый товар:

\begin{english}
  \begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
  <organization name="re-Store">
    <product price="8.99" type="fiber">VIP Fiber Plus</product>
    <product price="899.99" type="iphone">iPhone 11 Pro</product>
  </organization>
  <organization name="DNS">
    <branch name="Office 2">
      <bundle>
        <product price="9.99" type="fiber">Premium iFiber</product>
        <product price="999.99" type="iphone">iPhone 11 Pro</product>
        <product price="199.99" type="headset">AirPods Pro</product>
      </bundle>
    </branch>
  </organization>
</catalog>
  \end{xml}
\end{english}

\textbf{Третья задача}~--- упразднить все наборы. Возможно, руководство решило, что
продавать товары в наборах невыгодно. Что ж, бывает. Для программиста это
значит, что из XML уходят все теги \code{<bundle>}, однако их товары должны перейти в
организацию.

И в третий раз решение отличается лишь целевой функцией:

\begin{english}
  \begin{clojure}
(-> "products-price.xml"
    ->xml-zipper
    (alter-loc disband-bundle)
    zip/node
    xml/emit)
  \end{clojure}
\end{english}

Опишем алгоритм \code{disband-bundle}. Если текущий узел~--- набор, сохраним его
потомков (товары) в переменную, чтобы не потерять их. Затем удалим
набор. Функция удаления вернёт предка локации, в нашем случае
организацию. Присоединим к ней товары и вернем её.

\begin{english}
  \begin{clojure}
(defn disband-bundle [loc]
  (if (loc-bundle? loc)
    (let [products (zip/children loc)
          loc-org (zip/remove loc)]
      (append-childs loc-org products))
    loc))
  \end{clojure}
\end{english}

Функция \code{append-childs}~--- это обёртка над встроенной
\code{zip/append-child}. Последняя присоединяет только один элемент, что
неудобно. Чтобы присоединить их список, напишем свёртку:

\begin{english}
  \begin{clojure}
(defn append-childs [loc items]
  (reduce (fn [loc item]
            (zip/append-child loc item))
          loc
          items))
  \end{clojure}
\end{english}

Финальный XML без наборов, но с теми же товарами:

\begin{english}
  \begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
  <organization name="re-Store">
    <product price="8.99" type="fiber">VIP Fiber Plus</product>
    <product price="899.99" type="iphone">iPhone 11 Pro</product>
  </organization>
  <organization name="DNS">
    <branch name="Office 2">
      <product price="9.99" type="fiber">Premium iFiber</product>
      <product price="999.99" type="iphone">iPhone 11 Pro</product>
    </branch>
  </organization>
</catalog>
  \end{xml}
\end{english}

Надеемся, этих примеров достаточно, чтобы читатель понял, как редактировать
зипперы. Обратите внимание, что кода получилось немного: для каждой задачи мы
писали в среднем три функции. Другое преимущество в том, что нет состояния. Все
функции чистые, и их вызов не сказывается на данных. Если на середине выскочит
исключение, дерево XML не будет частично изменённым.

\section{Виртуальные деревья. Обмен валют}

Предыдущих занятий было достаточно, чтобы перейти к экспериментам над
зипперами. Предлагаем читателю подумать над необычным примером.

До сих пор вторая функция, которую мы передавали в зиппер, возвращала потомков
из ветки. Для вектора это была просто \code{seq}, для XML~--- более сложная комбинация
\code{(comp seq :content)}. Оба варианта отталкиваются от родительского узла, и если
потомков нет, функция вернёт \code{nil}.

Но что если функция вернёт постоянный набор потомков:

\begin{english}
  \begin{clojure}
(fn [_]
  (seq [1 2 3]))
  \end{clojure}
\end{english}

Как поведёт себя такой зиппер? Напишем его:

\begin{english}
  \begin{clojure}
(def zip-123
  (zip/zipper any?
              (constantly (seq [1 2 3]))
              nil
              1))
  \end{clojure}
\end{english}

Из-за того, что у каждого элемента три потомка, зиппер станет бесконечным. Обойти
его с помощью \code{iter-zip} не получится~--- \code{zip/next} будет всё глубже погружаться
в зиппер, но не достигнет его конца.

Ради интереса сделаем несколько шагов по новому зипперу. Спустимся вниз и
вправо. Мы окажемся на двойке в середине вектора \code{[1 2 3]}:

\begin{english}
  \begin{clojure}
(def loc-2
  (-> zip-123
      zip/down
      zip/right))

(zip/node loc-2)
;; 2
  \end{clojure}
\end{english}

Покажем наше положение не схеме. Шаги влево и право сдвинут нас на единицу и
тройку:

\begin{figure}[H]
  \centering
  \includesvg{charts/zip13.svg}
\end{figure}

С шагом вниз мы провалимся в очередной вектор \code{[1 2 3]} и так далее. Ради
интереса спустимся вниз и вправо пять раз, и всё равно окажемся в двойке:

\begin{english}
  \begin{clojure}
(def down-right (comp zip/right zip/down))

(-> loc-2
    down-right
    down-right
    down-right
    down-right
    down-right
    zip/node)
;; 2
  \end{clojure}
\end{english}

Зиппер можно назвать виртуальным, потому что данных, по которым мы путешествуем,
на самом деле не существует~--- они появляются в полёте.

Пока что неясно, в чём польза от этого зиппера. Но он подтверждает важный тезис
— можно получать потомков в процессе обхода дерева. Это не нарушает правила
зипперов и даёт новые возможности.

Явно заданный вектор \code{[1 2 3]} не раскрывает их. Если потомки известны заранее,
нужда в зиппере отпадает~--- коллекцию можно обойти более простым
способом. Интересен случай, когда потомки зависят от каких-то внешних факторов,
например, приходят из сторонних источников. В терминах функционального
программирования зиппер становится "грязным": поскольку мы не контролируем
внешний источник, повторный обход может дать разный результат. Однако это не
значит, что грязный зиппер не имеет права на жизнь. Рассматривайте его как
абстракцию над источником, которая делает его удобней.

На роль примера отлично подходит файловая система. Ее элементы~--- файлы и
директории~--- отвечают всем условиям зиппера. Директория~--- это узел, который
содержит ссылки на другие элементы. Когда вы просматриваете файлы в любом
менеджере, курсор ведет себя как локация. Он знает текущий файл, его соседей по
директории и пути вверх и вглубь (если текущий файл~--- директория). Если
правильно подобрать функции \code{branch?} и \code{children}, обычный файл становится
зиппером.

Код оказывается на удивление коротким. Добавьте в пространство модуль
\code{clojure.zip} и класс \code{java.io.File}:

\begin{english}
  \begin{clojure}
(ns zipper-demo
  (:import java.io.File)
  (:require
   [clojure.zip :as zip]))
  \end{clojure}
\end{english}

Функция \code{file-zip} принимает строковый путь и возвращает зиппер. Проверка
\code{branch?} сводится к вызову метода \code{.isDirectory} файла. Очевидно, если это
обычный файл, а не папка, двигаться ниже нельзя. Функция \code{children} опирается на
метод \code{.listFiles}, который вернет массив файлов в директории. Обертка в \code{seq}
необходима, чтобы привести пустой массив к \code{nil}.

\begin{english}
  \begin{clojure}
(defn file-zip [^String path]
  (zip/zipper
   (fn [^File f] (.isDirectory f))
   (fn [^File f] (seq (.listFiles f)))
   nil
   (new File path)))
  \end{clojure}
\end{english}

Получим зиппер проведем с ним эксперименты. Первая локация указывает на
корневую папку:

\begin{english}
  \begin{clojure}
(def fz
  (file-zip "/Users/ivan"))

(-> fz zip/node)
;; #object[java.io.File 0xe413375 "/Users/ivan"]
  \end{clojure}
\end{english}

Вызов \code{zip/next} сдвигает указатель на вложенные папки и файлы. В случае автора
это скрытая папка \code{.eclipse}:

\begin{english}
  \begin{clojure}
(-> fz zip/next zip/node)
;; #object[java.io.File 0x23e1b67 "/Users/ivan/.eclipse"]
  \end{clojure}
\end{english}

Через три сдвига получим файл \code{secure\_storage} в ее недрах:

\begin{english}
  \begin{clojure}
(-> fz zip/next zip/next zip/next zip/node)
;; #object[java.io.File 0x138b3172 "/Users/ivan/.eclipse/org.eclipse.equinox.security/secure_storage"]
  \end{clojure}
\end{english}

Сохраним локацию в переменную и вызовем \code{zip/path}. Получим вектор папок,
ведущих к файлу из локации:

\begin{english}
  \begin{clojure}
(def file-loc
  (-> fz zip/next zip/next zip/next))

(zip/path file-loc)

[#object[java.io.File 0xe413375 "/Users/ivan"]
 #object[java.io.File 0x2067c8ff "/Users/ivan/.eclipse"]
 #object[java.io.File 0x69304325 "/Users/ivan/.eclipse/org.eclipse.equinox.security"]]
  \end{clojure}
\end{english}

Файловый зиппер поддерживает \code{iter-zip}, поиск, переходы и прочие техники, что
мы рассмотрели. Признаем, в случае с файлами это не самое оптимальное решение:
за долгие годы для них созданы инструменты намного быстрее. Но пример
подтверждает, что зиппером может выступить объект, который на первый взгляд не
подходит на эту роль.

Наверное, каждый программист сталкивался с неуклюжим API, который возвращает
сущности и ее потомков по одной. Например, древняя CRM по запросу \code{GET
/api/entity/<id>} вернет JSON вида:

\begin{english}
  \begin{json}
{
  "id": 3,
  "name": "Gizmo",
  "description": "Does something",
  "children": [6, 9, 11, 23]
}
  \end{json}
\end{english}

Если у сущности нет потомков, в поле \code{children} пустой массив или оно
отсутствует.

Чтобы обойти сущности, построим зиппер, замкнутый на API. Предположим, функция
\code{entity-by-id} принимает HTTP-клиент с активным соединением и номер сущности и
возвращает прочитанный JSON из тела ответа.

\begin{english}
  \begin{clojure}
(defn entity-by-id [http-client entity-id]
  ...)
  \end{clojure}
\end{english}

В этом случае зиппер выглядит как в примере ниже. Он принимает HTTP-клиент и
номер корневой сущности. Функция \code{branch?} проверяет, что поле \code{children} не
пустое. Функция потомков извлекает их в цикле \code{for}:

\begin{english}
  \begin{clojure}
(defn entity-zip [http-client entity-id]
  (zip/zipper (fn [{:keys [children]}]
                (pos? (count children)))
              (fn [{:keys [children]}]
                (for [child children]
                  (entity-by-id http-client child)))
              nil
              (entity-by-id http-client entity-id)))
  \end{clojure}
\end{english}

Вызывая \code{zip/next}, мы будем шагать по сущностям, извлекая их по сети по мере
необходимости. Ради оптимизации можно заменить цикл \code{for} на частично
параллельный \code{pmap} или применить библиотеки Aleph и Manifold для удобной
многопоточности.

Когда сведения о потомках приходят по сети, важно оценить частоту запросов и
нагрузку на источник данных. Если это CRM в банковской системе, ее замедление
скажется на других частях компании. В этом случае данные полезно кэшировать в
памяти или в key-value хранилищах типа Memcached или Redis. Зиппер, построенный
на базе подобного хранилища, выглядит похоже за исключением функции
\code{entity-by-id}. Изменится только его конструктор, но не принцип работы.

Еще один интересный пример~--- когда функции \code{branch?} и \code{children} замкнуты на
некоторых данных. Это тоже обход, но по другим правилам.

Рассмотрим следующую задачу. Банк разменивает валюты, например доллары на евро,
рубли на лиры и так далее. Для краткости обозначим их парами: \code{(usd, eur)},
\code{(rub, lir)}. Размен действует в одном направлении: чтобы поменять евро на
доллары или лиры на рубли, у банка должны быть отдельные правила \code{(eur, usd)} и
\code{(lir, rub)}.

В банк обращается клиент, чтобы разменять валюту \code{X} на \code{Y}. Если в правилах
есть пара \code{(X, Y)}, проблемы не возникает. Но если пары нет, банк строит цепочку
обменов. Например, клиент хочет поменять доллары на лиры, но в банке нет прямой
пары \code{(usd, lir)}. Однако есть пары \code{(usd, eur)} и \code{(eur, lir)}. В этом случае
клиенту предложат обмен \code{usd} \arr \code{eur} \arr \code{lir}.

Ваша задача~--- написать программу, которая принимает правила обмена, входную и
выходную валюты. Вы должны найти цепочки обмена. Чем короче цепочка, тем
лучше. Если возможны несколько цепочек одинаковой длины, вернуть их все, чтобы
клиент мог выбирать. Учесть, что решений может не быть и адекватно реагировать
на этот случай: не уйти в вечный цикл, не занимать все ресурсы компьютера.

Опишем входные данные в терминах Clojure. Каждое правило будет парой кейвордов~---
с какой валюты на какую происходит обмен. Вектор правил назовем \code{rules}. Кроме
правил, мы принимаем параметры \code{from} и \code{to} с какой и на какую валюту менять.

\begin{english}
  \begin{clojure}
;; rules
[[:usd :rub] [:rub :eur] [:eur :lir]]

:usd ;; from
:rub ;; to
  \end{clojure}
\end{english}

На выходе ожидаем набор цепочек от \code{from} к \code{to} или \code{nil}. Для случая выше
цепочка от доллара к евро выглядит так:

\begin{english}
  \begin{clojure}
[:usd :rub :eur]
  \end{clojure}
\end{english}

Всё вместе даёт функцию \code{exchanges}, тело которой нам предстоит заполнить:

\begin{english}
  \begin{clojure}
(defn exchanges [rules from to]
  ...)
  \end{clojure}
\end{english}

Для начала напишем несколько тестов. Они помогут размяться, и заодно мы лучше
поймем задачу. Первый тест~--- простой обмен, который есть среди правил:

\begin{english}
  \begin{clojure}
(deftest test-simple
  (is (= [[:usd :rub]]
         (exchanges [[:usd :rub]] :usd :rub))))
  \end{clojure}
\end{english}

Обмен в обратную сторону невозможен, если нет отдельного правила:

\begin{english}
  \begin{clojure}
(deftest test-reverse-err
  (is (nil? (exchanges [[:rub :usd]] :usd :rub))))
  \end{clojure}
\end{english}

Случай, когда цепочки обмена не существует:

\begin{english}
  \begin{clojure}
(deftest test-no-solution
  (is (nil? (exchanges [[:rub :usd] [:lir :eur]] :usd :eur))))
  \end{clojure}
\end{english}

Наиболее важный сценарий: множественный обмен. От долларов к рублям ведут два
пути с евро и лирами в середине:

\begin{english}
  \begin{clojure}
(deftest test-two-ways
  (is (= [[:usd :eur :rub]
          [:usd :lir :rub]]
         (exchanges [[:usd :eur]
                     [:eur :rub]
                     [:usd :lir]
                     [:lir :rub]] :usd :rub))))
  \end{clojure}
\end{english}

Ещё один тест проверяет, что вы вернём только самые короткие цепочки. Обмен с
четырьмя валютами (в данном случае \code{[:usd :yen :eur :rub]}) не попадёт в
результат:

\begin{english}
  \begin{clojure}
(deftest test-short-ways-only
  (is (= [[:usd :eur :rub]
          [:usd :lir :rub]]
         (exchanges [[:usd :eur]
                     [:eur :rub]
                     [:usd :lir]
                     [:lir :rub]
                     [:usd :yen]
                     [:yen :eur]] :usd :rub))))
  \end{clojure}
\end{english}

В терминах олимпиадного программирования можно сказать, что задача содержит
отдельные рёбра графа. Требуется проверить, можно ли составить из рёбер маршрут
от вершины А к B. Поскольку эта глава о зипперах, мы не будем использовать
термины "граф" и "рёбра". Мы не гарантируем, что решение будет оптимальным, и
возможно, алгоритм на графах справится лучше. Однако надеемся, что пример ещё
больше раскроет мощь зипперов.

Как вы помните, зипперы удобны там, где встречается иерархия. На первый взгляд у
валют нет иерархии, но ее легко построить. Представим, что на вершине дерева
стоит валюта \code{from}, которую мы хотим разменять. Пусть это будет
доллар. Очевидно, что потомки этой валюты~--- все те, что размениваются на
доллар. Для этого выберем второй элемент из каждой пары, где первый элемент
равен \code{from}:

\begin{english}
  \begin{clojure}
(def rules
  [[:usd :rub]
   [:usd :lir]
   [:rub :eur]
   [:rub :yen]
   [:eur :lir]
   [:lir :tug]])

(def from :usd)

(def usd-children
  (for [[v1 v2] rules
        :when (= v1 from)]
    v2))
;; (:rub :lir)
  \end{clojure}
\end{english}

Таким образом, потомки доллара~--- рубль и лира. Изобразим мнимое дерево и
обозначим уровни:

\begin{figure}[H]
  \centering
  \includesvg{charts/zip14.svg}
  \label{fig:chart-zip-14}
\end{figure}

Для каждой валюты второго уровня найдём потомков по такому же правилу. Для
удобства напишем функцию \code{get-children}:

\begin{english}
  \begin{clojure}
(defn get-children [value]
  (for [[v1 v2] rules
        :when (= v1 value)]
    v2))

(get-children :rub)
;; (:eur :yen)
  \end{clojure}
\end{english}

Новое дерево:

\begin{figure}[H]
  \centering
  \includesvg{charts/zip15.svg}
  \label{fig:chart-zip-15}
\end{figure}

Заметим, что это виртуальное дерево, о котором мы говорили недавно. У нас нет
этого дерева на руках~--- оно получается в процессе. Функция \code{make-children}
замкнута на исходных парах обмена. Это пример того, как обходить данные, которые
получаем в полёте из других данных.

Структура дерева валют известна, и его можно обойти. Вопрос, до каких пор его
обходить? Очевидно, мы остановимся, как только встретим локацию, чей узел равен
валюте \code{to}. Пусть это будут йены. Это значит, мы соединили \code{from} и \code{to} с
помощью других валют. Обозначим решение на схеме:

\begin{figure}[H]
  \centering
  \includesvg{charts/zip16.svg}
  \label{fig:chart-zip-16}
\end{figure}

Чтобы получить цепочку обмена, локацию \code{to} передают в функцию \code{zip/path}. Она
вернёт вектор родителей локации, не включая ее саму. Путь к локации и её узел
образуют цепочку обмена.

На базе этих рассуждений напишем код. Подготовим зиппер:

\begin{english}
  \begin{clojure}
(def zip-val
  (zip/zipper keyword?      ;; is it a currency?
              get-children  ;; what it can be exchanged to?
              nil
              from))        ;; the origin currency
  \end{clojure}
\end{english}

Ищем в зиппере локацию с целевой валютой:

\begin{english}
  \begin{clojure}
(defn loc-to? [loc]
  (-> loc zip/node (= to)))

(def loc-to
  (->> zip-val
       iter-zip
       (find-first loc-to?)))
  \end{clojure}
\end{english}

Если нашли, получим из неё цепочку обмена. Для этого к пути присоединим значение
\code{to}:

\begin{english}
  \begin{clojure}
(conj (zip/path loc-to) (zip/node loc-to))
;; [:usd :rub :yen]
  \end{clojure}
\end{english}

Задача решена, но с недостатком: для любых данных мы получим только одну
цепочку, даже если их несколько. Чтобы исправиться, ищем не только первую
локацию с валютой \code{to}, а их все с помощью \code{filter}.

Расширим исходные данные:

\begin{english}
  \begin{clojure}
(def rules
  [[:usd :rub]
   [:usd :lir]
   [:rub :eur]
   [:lir :yen]
   [:rub :yen]
   [:eur :lir]
   [:lir :tug]])

(def from :usd)
(def to :yen)
  \end{clojure}
\end{english}

и найдём цепочки. Для этого заменим \code{find-first} на \code{filter}, который вернёт все
элементы, подходящие предикату, а не только первый.

\begin{english}
  \begin{clojure}
(def locs-to
  (->> zip-val
       iter-zip
       (filter loc-to?)))
  \end{clojure}
\end{english}

Для каждой найденной локации постоим путь:

\begin{english}
  \begin{clojure}
(for [loc locs-to]
  (conj (zip/path loc) (zip/node loc)))

([:usd :rub :eur :lir :yen]
 [:usd :rub :yen]
 [:usd :lir :yen])
  \end{clojure}
\end{english}

Теперь мы нашли цепочки всех длин, что может быть избыточно. По условию задачи
нам не нужен обмен из четырёх операций, если найден с двумя. Напишем функцию,
которая вернёт самые короткие списки из результата выше. Она группирует обмены
по длине, находит меньшую длину и выбирает из словаря.

\begin{english}
  \begin{clojure}
(defn get-shortest-chains
  [chains]
  (when (seq chains)
    (let [count->chains (group-by count chains)
          min-count (apply min (keys count->chains))]
      (get count->chains min-count))))
  \end{clojure}
\end{english}

Для последнего результата получим два вектора по три валюты в каждом. Этот
случай покрывает последний тест \code{test-short-ways-only}, где длинные цепочки
отбрасываются:

\begin{english}
  \begin{clojure}
[[:usd :rub :yen] [:usd :lir :yen]]
  \end{clojure}
\end{english}

Составьте функцию \code{exchanges} из фрагментов кода. Убедитесь, что тесты
проходят. Добавьте в них больше случаев.

Кажется, что задача решена, однако её можно улучшить. Дело в том, что при особых
входных данных дерево станет бесконечным. Программа либо уйдёт в вечный цикл,
либо, если число шагов ограничить, не найдет решения. Не заглядывая вперед,
подумайте, что может быть тому причиной и как это исправить. На эти вопросы мы
ответим в следующем разделе.

\section{Обход в ширину. Улучшенный обмен валют}

В прошлый раз мы работали с деревом валют, чтобы построить цепочку обмена. Мы
нашли решение задачи, но упомянули, что в особых случаях дерево может получиться
бесконечным. Объясним, как это возможно. Для этого вспомним, как \code{zip/next}
обходит дерево.

\def\urldepthfirst{https://en.wikipedia.org/wiki/Depth-first\_search}

Алгоритм называется \footurl{depth first search}{\urldepthfirst}[Depth first]
или обход в глубину. При таком обходе код стремится в первую очередь вниз, а уже
потом~--- в сторону (в нашем случае вправо). В этом легко убедиться, если
разложить данные на части с помощью зиппера:

\begin{english}
  \begin{clojure}
(->> [1 [2 [3] 4] 5]
     zip/vector-zip
     iter-zip
     (map zip/node)
     (map println))

;; 1
;; [2 [3] 4]
;; 2
;; [3]
;; 3
;; 4
;; 5
  \end{clojure}
\end{english}

Цифра \code{3}, идущая перед \code{4}, говорит о том, что зиппер следует вглубь (внутрь
вектора \code{[3]}) и только потом право.

Ещё более интересен случай с деревом, где у каждого узла потомки \code{[1 2 3]}. При
обходе такого дерева зиппер будет стремиться вниз, каждый раз спускаясь в
очередной вектор \code{[1 2 3]} и становясь на единицу. Покажем это на схеме:

\begin{english}
  \begin{clojure}
(def zip-123
  (zip/zipper any?
              (constantly (seq [1 2 3]))
              nil
              1))
  \end{clojure}
\end{english}

\begin{figure}[H]
  \centering
  \includesvg{charts/zip17.svg}
  \label{fig:chart-zip-17}
\end{figure}

Поскольку в зиппере нет условия, по которому производство потомков
останавливается, их вложенность неограничена. Функция \code{iter-zip} вернёт
бесконечную цепочку локаций, в каждой из которых единица. Неважно, сколько
единиц мы возьмём от неё~--- сто или тысячу~--- получим столько же единиц.

\begin{english}
  \begin{clojure}
(->> zip-123
     iter-zip
     (take 10)
     (map zip/node))

;; (1 1 1 1 1 1 1 1 1 1)
  \end{clojure}
\end{english}

Вернёмся к обмену валют. Предположим, банк меняет рубли на доллары, доллары на
евро и евро на рубли. Выразим это в коде:

\begin{english}
  \begin{clojure}
(def rules
  [[:rub :usd]
   [:usd :eur]
   [:eur :rub]])
  \end{clojure}
\end{english}

Читатель заметит, что получился замкнутый круг:

\begin{figure}[H]
  \centering
  \includesvg{charts/zip18.svg}
  \label{fig:chart-zip-18}
\end{figure}

Недостаток прошлого решения в том, что оно не учитывает цикличность
правил. Предположим, клиент хочет обменять рубли на лиры. Начнём строить дерево
от рубля. Начало цепочки:

\begin{figure}[H]
  \centering
  \includesvg{charts/zip19.svg}
  \label{fig:chart-zip-19}
\end{figure}

Мы снова пришли к рублю. Для него мы получим доллар, для доллара евро, затем
рубль. Если продолжить итерацию, будем бесконечно погружаться в эту цепочку.

Логика подсказывает, что нужно пресечь обход вглубь, если очередная валюта равна
исходной. Проще говоря, у элемента \code{:rub}, который стоит \emph{не на вершине}, не
может быть потомков. Но функции \code{branch?} и \code{make-children} не знают, какое
место в дереве занимает элемент. Они принимают значения, а не локации, и не
могут ответить на вопрос, вершина это или нет.

Проблему можно исправить с помощью состояния, например атома, который хранил бы
список валют, которые мы обошли. Другой вариант – проверять, в какой раз мы
обращаемся к валюте \code{from} для поиска потомков. Если в первый раз, мы на вершине
дерева. Найдём потомков и изменим атом, на котором замкнута функция
\code{children}. Если это последующий раз (атом изменён), мы наткнулись на цикл, и
для него потомков нет.

Оба способа имеют право на жизнь, но хотелось бы решить задачу без состояния и
изменяемых средств.

Если посмотреть на дерево, станет ясно: проблема в порядке обхода. Поскольку мы
стремимся вглубь, велика вероятность попасть в кротовую нору, из которой нельзя
выбраться. Нам может повезти, когда мы удачно шагнули в ветку с решением
(слева), а бесконечная ветка (справа) осталась нетронутой:

\begin{figure}[H]
  \centering
  \includesvg{charts/zip20.svg}
  \label{fig:chart-zip-20}
\end{figure}

Однако это везение, и на него нельзя полагаться в решении задач.

Предположим теперь, зиппер обходит локации не вглубь, а вширь и вправо. С таким
порядком нам не страшны бесконечные ветки. Если таковая закралась в дерево, она
не оттянет на себя обход. Вместо этого мы спускаемся по этажам и читаем все
элементы этого уровня. Даже если один из них относится к бесконечной ветви, это
не помешает исследовать остальные. Рисунок ниже показывает, как горизонтальный
обход поможет добраться до цели. Вертикальный обход ушёл бы вы бесконечность,
потому что обе ветви цикличны.

\begin{figure}[H]
  \centering
  \includesvg{charts/zip21.svg}
  \label{fig:chart-zip-21}
\end{figure}

Проблема в том, что модуль \code{clojure.zip} предлагает только один способ обхода~---
в глубину с помощью \code{zip/next}. Другого алгоритма не предусмотрено. Мы напишем
свою функцию, чтобы обойти зиппер "послойно". Говоря иначе, для дерева как на
рисунке:

\begin{figure}[H]
  \centering
  \includesvg{charts/zip22.svg}
  \label{fig:chart-zip-22}
\end{figure}

\noindent
мы получим слои:

\begin{english}
  \begin{clojure}
[1]
[2 3]
[4 5 6 7]
  \end{clojure}
\end{english}

\noindent
, при этом каждый элемент будет не примитивом, а локацией. Это значит, элемент
помнит свое положение в дереве, от него можно переходить к другим элементам,
получить его путь и так далее.

Для начала нужна функция, которая вернёт дочерние локации исходной. Её логика
проста: погружаемся вниз, и если результат не пуст, двигаемся вправо.

\begin{english}
  \begin{clojure}
(defn loc-children [loc]
  (when-let [loc-child (zip/down loc)]
    (->> loc-child
         (iterate zip/right)
         (take-while some?))))
  \end{clojure}
\end{english}

Обратите внимание, что это не то же самое, что \code{zip/children}. Последняя вернёт
значения, а не локации, а нам нужны именно локации. Сравните выражения:

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/children)

(1 2 3)
  \end{clojure}
\end{english}

\noindent
и

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    loc-children)

([1 {:l [] :pnodes [[1 2 3]] :ppath nil :r (2 3)}]
 [2 {:l [1] :pnodes [[1 2 3]] :ppath nil :r (3)}]
 [3 {:l [1 2] :pnodes [[1 2 3]] :ppath nil :r nil}])
  \end{clojure}
\end{english}

Во втором случае получили локации, в то время как \code{zip/children} просто
обращается к функции для нахождения потомков, которую передали в зиппер.

Предположим, что для некоторой локации \code{loc-children} вернула список её
потомков. Чтобы спуститься на уровень ниже, нужно найти потомков для них и
объединить результат. Проще всего это это сделать выражением:

\begin{english}
  \begin{clojure}
(mapcat loc-children locs)
  \end{clojure}
\end{english}

\noindent
, где \code{locs}~--- локации текущего уровня. Если передать в \code{locs} результат
\code{mapcat}, продвинемся ещё дальше, и так до тех пор, пока не получим пустую
последовательность. Всё вместе даёт нам функцию \code{loc-layers}:

\begin{english}
  \begin{clojure}
(defn loc-layers [loc]
  (->> [loc]
       (iterate (fn [locs]
                  (mapcat loc-children locs)))
       (take-while seq)))
  \end{clojure}
\end{english}

Она принимает корневую локацию, от которой начинается итерация по слоям. Первый
слой мы задали явно как вектор одной локации. Затем идут его потомки, затем
потомки потомков и так далее. Мы остановимся лишь когда получим пустой
слой. Быстрая проверка:

\begin{english}
  \begin{clojure}
(def data [[[[1]]] 2 [[[3]]] 3])

(let [layers (-> data
                 zip/vector-zip
                 loc-layers)]
  (for [layer layers]
    (->> layer
         (map zip/node)
         println)))

;; ([[[[1]]] 2 [[[3]]] 3])
;; ([[[1]]] 2 [[[3]]] 3)
;; ([[1]] [[3]])
;; ([1] [3])
;; (1 3)
  \end{clojure}
\end{english}

Чтобы соединить слои в цепь, воспользуемся \code{apply} и \code{concat}. Эта функция не
понадобится в решении задачи, но может оказаться полезной:

\begin{english}
  \begin{clojure}
(defn loc-seq-layers [loc]
  (apply concat (loc-layers loc)))
  \end{clojure}
\end{english}

Вернёмся к обмену валют. Подберём правила обмена так, чтобы в них были
циклические зависимости:

\begin{english}
  \begin{clojure}
(def rules2
  [[:rub :usd]
   [:usd :eur]
   [:eur :rub]

   [:rub :lir]
   [:lir :eur]
   [:eur :din]
   [:din :tug]])
  \end{clojure}
\end{english}

Зиппер не изменится, но теперь мы обходим его по-другому: не с помощью
\code{zip/next}, а функцией \code{loc-layers}. На каждом шаге получим слои обмена. Наша
задача~--- найти в очередном слое локации, чей узел равен конечной валюте. Если
нашли хотя бы одну, задача решена. Останется вычислить до них путь.

\begin{english}
  \begin{clojure}
(defn exchange2 [rules from to]

  (letfn [(get-children [value]
            (seq (for [[v1 v2] rules
                       :when (= v1 value)]
                   v2)))

          (loc-to? [loc]
            (-> loc zip/node (= to)))

          (find-locs-to [layer]
            (seq (filter loc-to? layer)))

          (->exchange [loc]
            (conj (zip/path loc) (zip/node loc)))]

    (let [zipper (zip/zipper keyword?
                             get-children
                             nil
                             from)]

      (->> zipper
           loc-layers
           (some find-locs-to)
           (map ->exchange)))))
  \end{clojure}
\end{english}

Заметим, что теперь не нужно сравнивать длины цепочек: если локации относятся к
одному уровню, число шагов до них одинаково. По условию задачи мы заинтересованы
в самых коротких вариантах обмена. Если на третьем уровне нашлась одна цепочка,
а на четвертом их три, последние нам не интересны~--- обход завершится на третьем
слое.

Примеры обмена с правилами, заданными в \code{rules2}:

\begin{english}
  \begin{clojure}
(exchange2 rules2 :rub :eur)
([:rub :usd :eur] [:rub :lir :eur])

(exchange2 rules2 :rub :tug)
([:rub :usd :eur :din :tug] [:rub :lir :eur :din :tug])

(exchange2 rules2 :lir :din)
([:lir :eur :din])
  \end{clojure}
\end{english}

Решение все ещё не идеально. Если указать пару валют, для которых нет цепочки,
получим бесконечный цикл. Чтобы пресечь его, ограничьте число слоев каким-то
разумным числом, например пятью. С точки зрения финансов обмен с таким числом
операций будет невыгодным, а потому лишен смысла. Технически это значит добавить
форму \code{(take N)} сразу после \code{loc-layers}:

\begin{english}
  \begin{clojure}
(->> zipper
     loc-layers
     (take 5)
     (some find-locs-to)
     (map ->exchange))
  \end{clojure}
\end{english}

Теперь для неверной пары получим пустой результат:

\begin{english}
  \begin{clojure}
(exchange2 rules2 :tug :yen)
()
  \end{clojure}
\end{english}

Задачу можно развить еще дальше. Скажем, для каждой цепочки считать издержки и
комиссию за операцию. Для этого в вектор \code{[:from :to]} добавим обменный курс и
вознаграждение. В зависимости от того, на чьей мы стороне~--- клиента или банка~---
будем искать самые затратные или оптимальные обмены. Предлагаем читателю
придумать свои вариации к этой задаче.

На этом мы закончим с валютами и двинемся дальше. Мы рассмотрели, как порядок
обхода влияет на решение задачи. В разных случаях применяют методы в глубину и в
ширину. Это важно для бесконечных деревьев, когда алгоритм может зациклиться при
обходе. В поставке \code{clojure.zip} нет обхода вширь, но легко написать функцию
деления зиппера на слои. Возможно, \code{loc-layers} пригодится вам в других случаях,
связанных с графами и вершинами.

\section{Заключение}

В заключение рассмотрим другие возможности зипперов, которые могут быть вам
полезны.

\subsection{HTML}

Из прошлых примеров видно, что зипперы подходят для XML. В том числе их можно
применить для HTML. Синтаксис форматов отличается: некоторые HTML-элементы вроде
\code{<br>} или \code{<img>} не имеют закрывающих тегов. Проблему решают парсеры, которые
учитывают эти особенности. На выходе получим дерево, которое поддается обходу
как XML.

\def\hickory{https://github.com/davidsantiago/hickory}
\def\jsoup{https://jsoup.org/}

Библиотека \footurl{Hickory}{\hickory}[Hickory] предлагает парсер разметки
HTML. Разбор основан на Java-библиотеке \footurl{JSoup}{\jsoup}[JSoup], которая
строит дерево элементов. Hickory содержит функцию, чтобы перестроить Java-дерево
в Clojure-подобное и получить зиппер. Добавьте в проект зависимость:

\begin{english}
  \begin{clojure}
[hickory "0.7.1"]
  \end{clojure}
\end{english}

\noindent
и выполните пример:

\begin{english}
  \begin{clojure}
(ns zipper-manual.core
  (:require
   [hickory.core :as h]
   [hickory.zip :as hz]
   [clojure.zip :as zip]))

(def html (-> "https://grishaev.me/"
              java.net.URL.
              slurp))

(def doc-src (h/parse html))
(def doc-clj (h/as-hiccup doc-src))
(def doc-zip (hz/hiccup-zip doc-clj))
  \end{clojure}
\end{english}

Объясним эти преобразованиия. В переменную \code{html} загружается разметка сайта в
виде строки. В переменной \code{doc-src} оказалось дерево, полученное из HTML. Это
объект класса \code{Document} из пакета \code{org.jsoup.nodes}. С точки зрения Clojure это
чёрный ящик: чтобы работать с ним, нужно читать документацию к классу
\code{Document}.

Функция \code{as-hiccup} переводит документ в набор вложенных векторов вида:

\begin{english}
  \begin{clojure}
[:tag {:attr "value"} & [...]],
  \end{clojure}
\end{english}

На первом месте тег, затем словарь атрибутов, а за ним~--- любое число таких же
векторов или строк. Это стандартное представление HTML в Clojure, и многие
библиотеки используют такой же формат.

Функция \code{hiccup-zip} возвращает зиппер этой структуры. С ним можно сделать всё
то, в чём мы упражнялись ранее, например:

\begin{itemize}

\item
  удалить нежелательные теги вроде \code{<script>}, \code{<iframe>};

\item
  оставить эти теги, но обезопасить их атрибуты;

\item
  оставить, только если источник указывает на доверенные сайты;

\item
  искать интересующие нас элементы.

\end{itemize}

Вот как найти все картинки страницы:

\begin{english}
  \begin{clojure}
(defn loc-img? [loc]
  (some-> loc zip/node first (= :img)))

(defn loc->src [loc]
  (some-> loc zip/node second :src))

(->> doc-zip
     iter-zip
     (filter loc-img?)
     (map loc->src))

("/assets/static/photo-round-small.png" ...)
  \end{clojure}
\end{english}

Первая функция проверяет, что локация указывает на узел с тегом \code{<img>}, вторая
извлекает из него атрибут \code{src}. Третья форма вернёт список ссылок на
изображения.

На этой базе можно построить фильтрацию HTML, что особенно важно, если разметка
приходит от пользователя. Другой сценарий~--- найти в HTML подходящее изображение
для обложки в соцсети. Для этого нужно выбрать все изображения, оценить их
ширину и высоту и выбрать наибольшее по площади (если заполнены атрибуты \code{width}
и \code{height}).

Hickory предлагает селекторы для поиска по тегу и атрибуту. Для этого даже не
обязательно приводить дерево JSoup к зипперу. Однако в редких случаях нужно
найти теги со сложной взаимосвязью как в примере с товаром и набором (только в
наборе или строго не в нём). Эти задачи изящно ложатся на зипперы.

\subsection{Данные и сериализация}

Плюс зипперов в том, что они остаются данными~--- комбинацией списков и
словарей. Локацию можно записать в EDN или JSON. При чтении мы получим ее же и
продолжим обход с того места, где остановились. Это отличает Clojure от
объектных языков, где в общем случае нельзя записать объект в файл без
определенных усилий.

При восстановлении зиппера помните о его метаданных. Функции \code{branch?},
\code{children} и \code{make-node}, которые мы передали в конструктор, хранятся в
метаданных зиппера. Это сделано для того, чтобы отделить данные от действий над
ними. Проверим метаданные зиппера, который получили из HTML:

\begin{english}
  \begin{clojure}
(meta doc-zip)

#:zip{:branch? #function[clojure.core/sequential?],
      :children #function[hickory.zip/children],
      :make-node #function[hickory.zip/make]}
  \end{clojure}
\end{english}

Напишем функции для сброса и чтения EDN:

\begin{english}
  \begin{clojure}
(defn edn-save [data path]
  (spit path (pr-str data)))

(defn edn-load [path]
  (-> path slurp edn/read-string))
  \end{clojure}
\end{english}

Предположим, мы дошли со середины зиппера и сохранили его в файл:

\begin{english}
  \begin{clojure}
(-> doc-zip
    zip/next
    zip/next
    zip/next
    (edn-save "zipper.edn"))
  \end{clojure}
\end{english}

Если считать EDN и передать результат в \code{zip/next}, получим ошибку. Функция
вызовет \code{branch?} и \code{children} из метаданных, которые не сохранились, что
приведёт к исключению. Чтобы зиппер из файла заработал, добавьте ему
метаданные. Скопируйте их из зиппера или объявите вручную:

\begin{english}
  \begin{clojure}
(def zip-meta (meta doc-zip))

;; or

(def zip-meta
  #:zip{:branch? sequential?
        :children #'hickory.zip/children
        :make-node #'hickory.zip/make})
  \end{clojure}
\end{english}

Во втором случае нам прошлось указать ссылки на функции \code{children} и
\code{make-node}, потому что они приватные. После вызова \code{with-meta} локация из файла
окажется в том же состоянии, что и при сохранении.

\begin{english}
  \begin{clojure}
(def doc-zip-new
  (-> "zipper.edn"
      edn-load
      (with-meta zip-meta)))

(-> doc-zip-new zip/node first)
:head
  \end{clojure}
\end{english}

Хранение зиппера в долговременной памяти дает новые возможности. Например, обход
каких-то данных занимает время, и программа выполняет задачу порциями, сохраняя
промежуточный результат. Так работают сложные бизнес-сценарии. Если клиент
отказывается от услуг фирмы, мы должны удалить его записи в базе, файлы, ссылки
в документах и много другое. Этот процесс можно представить как набор шагов. На
каждом шаге код читает из базы зиппер в формате EDN и добавляет
метаданные. Затем сдвигает его на один шаг при помощи \code{zip/next}, выполняет
задачу текущего узла и сохраняет в базу новую версию зиппера.

\subsection{Другое}

Пример с разменом показывает, как найти решение задачи перебором. Если вы ищете
оптимальную цепочку шагов, максимальную цену, короткий маршрут~--- возможно, вам
помогут зипперы. Необходимо лишь одно условие: чтобы сущности строились в
иерархию. Как только вы знаете принцип подчинения, не составит труда написать
зиппер и обойти его.

Скажем, согласно таблице доллар (текущее значение) можно разменять на евро и
рубль (дочерние значения). Из точки A (текущее) можно проехать в пункты B и C
(дочерние). В HTML один тег может включать в себя другие. Все три случая
подходят зипперу, нужно только описать функции \code{branch?}~--- может ли элемент
иметь потомков~--- и \code{children}~--- как конкретно их найти.

\subsection{Сторонние библиотеки}

\def\zippo{https://github.com/igrishaev/zippo}
\def\datazip{https://github.com/clojure/data.zip/}

Модуль \code{clojure.zip} предлагает достаточно функций для навигации, однако по
ходу главы мы создали немало своих инструментов. Автор собрал их в библиотеке
\footurl{Zippo}{\zippo}[Zippo]. Похожий проект
\footurl{data.zip}{\datazip}[data.zip] содержит различные дополнения к
зипперами. Возможно, эти две библиотеки окажутся вам полезны.

\subsection{Заключение}

Зиппер~--- это способ навигации по структуре данных. Он предлагает движение по
четырём сторонам: вниз, вверх, влево, вправо. Элемент в центре называется
текущим.

Зиппер работает с самыми разными структурами. Ему нужно знать только две вещи:
является ли текущий элемент веткой дерева и если да, то как найти потомков. Для
этого зиппер принимает функции \code{branch?} и \code{children}, которые хранит в
метаданных.

Обычно потомков находят из родительского узла, но в некоторых случаях получают
динамически. Например, чтобы узнать, на какие валюты можно разменять текущую,
обращаются к словарю обмена. Для этого словарь должен быть виден функции
\code{children} как глобальная переменная или замыкание.

Текущий элемент зиппера называют локацией. Он хранит не только значение, но и
данные для перехода во все стороны, а также путь. Это выгодно отличает зиппер от
\code{tree-seq} и аналогов, которые раскладывают дерево в цепь без учета пути к
элементу. Некоторые задачи состоят именно в поиске нужного пути.

Зиппер предлагает функции для правки и удаления текущего узла. Правка может
отталкиваться от текущего значения (\code{zip/edit}) или нового (\code{zip/replace}).

По умолчанию обход зиппера происходит в глубину (depth first). При переходе в
конец локация получит отметку о том, что цикл пройден. Используйте функцию
\code{zip/end?} как признак конца итерации. В наших примерах мы написали функцию
\code{zip-iter}, которая завершает обход на предпоследнем элементе.

Для некоторых задач необходим обход в ширину. Это может случиться, когда одна из
ветвей дерева потенциально бесконечна. Для обхода в ширину мы написали свои
функции, которых нет в поставке Clojure.zip.

Зипперы полезны в работе с XML, поиском решений, фильтрации HTML. Потратьте на
них время, чтобы в будущем решать такие задачи коротко и изящно.
