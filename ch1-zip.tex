\chapter{Зипперы}

\begin{teaser}
В этой главе мы рассмотрим зипперы в языке Clojure. Это необычный способ работы
с коллекциями. С помощью зиппера можно обойти произвольные данные, изменить их и
выполнить поиск. Зиппер — мощный инструмент, и вложения в него окупаются со
временем. Вместе с тем это довольно сложная абстракция, которая требует
подготовки.
\end{teaser}

\section{Азы навигации}

Объясним зиппер простыми словами. Это обёртка над данными с набором
действий. Вот некоторые из них:

\begin{itemize}

\item
  перемещение по вертикали: вниз к потомкам или вверх к родителю;

\item
  перемещение по горизонтали: влево или вправо среди потомков;

\item
обход всех элементов;

\item
добавление, редактирование и удаление узлов.

\end{itemize}

Это неполный список того, на что способны зипперы. Другие их свойства мы
рассмотрим по ходу главы. Важно, что указанные действия относятся к любым
данным, будь то комбинация векторов и словарей, дерево узлов или XML. Из-за
этого зипперы становятся мощным инструментом. Разобраться с ними означает
повысить свои навыки и открыть новые двери.

\def\huet{https://en.wikipedia.org/wiki/Gerard\_Huet}
\def\huetzipper{https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf}

Термин <<зиппер>> ввел французкий ученый \footurl{Жерар Юэ}{\huet}[G\'{e}rard Huet]
(G\'{e}rard Huet) в 1996 году. Юэ занимался деревьями и искал универсальный
способ работы с ними. В знаменитой работе \footurl{<<Functional Pearl: The Zipper>>}{\huetzipper}[The Zipper]
Юэ привел концепцию зиппера на языке OCaml. Документ
привлек внимание простотой и ясностью: описание зиппера, включая код и
комментарии, уместились на четырех страницах. Современные зипперы почти не
отличаются от того изложения 1996 года.

Хотя Юэ отмечает, что зиппер можно создать на любом языке, лучше всего они
прижились в функциональных: Haskell, OCaml, Clojure. Зипперы поощряют
неизменяемые данные и чистые преобразования. Для упомянутых языков написаны
библиотеки зипперов, и разработчики хотя бы поверхностно знакомы с
ними. Наоборот, в императивной среде зипперы почти неизвестны.

Зипперы доступны в Clojure с первой версии. Их легко добавить в проект, не
опасаясь проблем лицензии или новых зависимостей.

Зипперы в Clojure используют мощь неизменяемых коллекций. Технически зиппер~---
это коллекция, которая хранит данные и позицию в них. Всё вместе это называется
локацией (location). Шаг в любую сторону вернёт новую локацию подобно тому, как
функции \code{assoc} или \code{update} производят новые данные из прежних.

Из текущей локации можно получить \emph{узел} (ноду)~--- данные, на которые ссылается
указатель. На этом моменте путаются новички, поэтому уточним различие. Локация~---
это исходные данные и положение в них. Передвижение по локации порождает
локацию. Из локации можно извлечь узел~--- данные, которые встретились на этом
участке.

Приведём пример с вектором \code{[1 2 3]}. Чтобы переместиться на \textbf{двойку}, обернем
данные в зиппер и выполним команды \code{zip/down} и \code{zip/right}. С первым шагом мы
провалимся в вектор и окажемся на единице. Шаг вправо сдвинет нас на
двойку. Выразим это в коде: подключим модуль \code{clojure.zip} и переместимся по
вектору:

\begin{english}
  \begin{clojure}
(require '[clojure.zip :as zip])

(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/right
    zip/node)
;; 2
  \end{clojure}
\end{english}

Функция \code{zip/vector-zip} зиппер из вектора. Вызовы \code{zip/down} и
\code{zip/right} передвинут указатель на двойку, как и ожидалось. Последний шаг
\code{zip/node} вернет значение (узел) из текущей локации. Если убрать \code{zip/node},
получим локацию, которая соответствует двойке. Вот как она выглядит:

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/right)

;; [2 {:l [1], :pnodes [[1 2 3]], :ppath nil, :r (3)}]
  \end{clojure}
\end{english}

Наверняка у вас возникли вопросы: откуда мы знаем путь к двойке, ведь она могла
быть в другом месте вектора? Что произойдет, если выйти за пределы коллекции?
Мы ответим на эти вопросы ниже. Пока что, если вам что-то непонятно, не впадайте
в панику: мы не раз обсудим всё, что происходит.

Итак, зиппер предлагает перемещение по данным. Несмотря на всю мощь, он не
знает, как делать это для конкретной коллекции, и нуждается в вашей помощи. Вот
что нужно знать зипперу:

\begin{itemize}

\item
  Является ли текущий элемент веткой или нет? Веткой называют элемент, из
  которого можно извлечь другие элементы.

\item
  Если это ветка, как именно получить её элементы?

\end{itemize}

Как только мы знаем ответы на эти вопросы, зиппер готов. Заметим, что для
изменения зиппера нужен ответ на третий вопрос~--- как присоединить потомков к
ветке. Однако сейчас мы рассматриваем только навигацию, и третий вопрос
подождет.

В техническом плане ответы на эти вопросы~--- функции. Первая принимает узел и
возвращает истину или ложь. Если получили истину, зиппер вызовет вторую функцию
с тем же узлом. От нее ожидают коллекцию дочерних узлов или \code{nil}, если их
нет. В терминах зиппера функции называют \code{branch?} и \code{children}
соответственно.

Чтобы получить зиппер, сообщите ему данные и эти две функции. Посколько мы
только читаем зиппер, третья функция будет \code{nil}.

\def\urlclojurezip{https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj}

Зипперы находятся в модуле \code{clojure.zip}. В свободное время исследуйте его код:
он занимает всего \footurl{280 строк}{\urlclojurezip}[zip.clj]!

\begin{english}
  \begin{clojure}
(ns my.project
  (:require [clojure.zip :as zip]))
  \end{clojure}
\end{english}

Функция \code{zip/zipper} порождает зиппер из исходных данных и функций. Это
центральная точка модуля, его строительный материал. Для особых случаев модуль
содержит вспомогательные функции, которые ожидают только данные. Примером служит
функция \code{vector-zip}. Она работает с вектором, элементы которого могут быть
вложенным вектором и так далее. Приведём ее код в сокращении:

\begin{english}
  \begin{clojure}
(defn vector-zip
  [root]
  (zipper vector?
          seq
          ...
          root))
  \end{clojure}
\end{english}

Третий параметр мы заменили на многоточие. Это функция, которая присоединяет к
ветке дочерные узлы при изменении (пока что обходим вопрос стороной).

Если передать в \code{vector-zip} данные \code{[1 2 3]}, произойдёт
следующее. Зиппер обернёт вектор и выставит на него указатель. Из начального
положения можно следовать только вниз, потому что у вершины нет родителя (вверх)
и соседей (влево и вправо). При смещении \textbf{вниз} зиппер сначала проверит,
что текущий узел~--- ветка. Сработает выражение \code{(vector? [1 2 3])}, что
вернёт истину. В этом случае зиппер выполнит \code{(seq [1 2 3])}, чтобы
получить потомков. Ими станет последовательность \code{(1 2 3)}. Как только
потомки найдены, зиппер установит указатель на крайний левый потомок~---
единицу.

Покажем это на схеме. Начальная позиция, указатель на исходном векторе:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-01}
  \caption{Начальная позиция}
  \label{fig:chart-zip-01}
\end{figure}

Шаг вниз, указатель на единице:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-02}
  \caption{Результат смещения вниз}
  \label{fig:chart-zip-02}
\end{figure}

Шаг вправо, указатель на двойке:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-03}
  \caption{Перемещение вправо}
  \label{fig:chart-zip-03}
\end{figure}

Итак, мы находимся на двойке и можем двигаться дальше по горизонтали. Шаг вправо
сдвинет нас на тройку, влево~--- на единицу. Вот как это выглядит в коде:

\begin{english}
  \begin{clojure}
(def loc2
  (-> [1 2 3]
      zip/vector-zip
      zip/down
      zip/right))

(-> loc2 zip/node)
;; 2

(-> loc2 zip/right zip/node)
;; 3

(-> loc2 zip/left zip/node)
;; 1
  \end{clojure}
\end{english}

При попытке сдвинуться вниз зиппер выполнит предикат \code{(vector? 2)}. Результат
будет ложью, что означает, что текущий элемент не ветка, и движение вниз
запрещено.

Во время движения каждый шаг порождает новую локацию, не изменяя старую. Если вы
сохранили очередную локацию в переменную, дальнейшие вызовы \code{zip/right} или
\code{zip/down} не изменят её. Выше мы объявили переменную \code{loc2}, которая
указывает на двойку. Проследуем от нее к исходному вектору:

\begin{english}
  \begin{clojure}
(-> loc2 zip/up zip/node)
;; [1 2 3]
  \end{clojure}
\end{english}

При ручном перемещении велики шансы выйти за пределы данных. Шаг в никуда вернёт
\code{nil} вместо локации:

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/left)
nil
  \end{clojure}
\end{english}

Это сигнал, что вы идёте по неверному пути. Из \code{nil} нельзя вернуться на
прежнее место, потому что у \code{nil} нет сведений о позиции. Для \code{nil}
функции \code{zip/up}, \code{zip/right} и другие тоже вернут \code{nil}. Если не
учесть это в цикле, вы будете топтаться на месте.

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/left
    zip/left
    zip/left
    ...)

;; nil
  \end{clojure}
\end{english}

К исключению относится функция \code{zip/down}: при попытке спуститься из \code{nil} вы
получите \code{NullPointerException}. Это недочёт, который, возможно, когда-нибудь
исправят.

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/left
    zip/down)

;; Execution error (NullPointerException)...
  \end{clojure}
\end{english}

Рассмотрим случай, когда у вектора вложенные элементы: \code{[1 [2 3] 4]}. Чтобы
переместиться на \textbf{тройку}, выполним шаги <<вниз>>, <<вправо>>, <<вниз>>,
<<вправо>>. Сохраним локацию в переменную \code{loc3}:

\begin{english}
  \begin{clojure}
(def loc3
  (-> [1 [2 3] 4]
      zip/vector-zip
      zip/down
      zip/right
      zip/down
      zip/right))

(zip/node loc3)
3
  \end{clojure}
\end{english}

Рисунки ниже показывают, что происходит на каждом шаге. Исходная позиция:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-04}
  \caption{Исходная позиция}
  \label{fig:chart-zip-04}
\end{figure}

Шаг вниз:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-05}
  \caption{Шаг вниз}
  \label{fig:chart-zip-05}
\end{figure}

Вправо:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-06}
  \caption{Шаг вправо}
  \label{fig:chart-zip-06}
\end{figure}

Вниз:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-07}
  \caption{Шаг вниз}
  \label{fig:chart-zip-07}
\end{figure}

Вправо. Мы у цели:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-08}
  \caption{Шаг вправо}
  \label{fig:chart-zip-08}
\end{figure}

Чтобы перейти на \textbf{четвёрку} из текущей позиции, сначала поднимемся
вверх. Указатель сдвинется на вектор \code{[2 3]}. Мы находимся среди потомков
исходного вектора и можем перемещаться по горизонтали. Сделаем шаг вправо и
окажемся на цифре 4.

То же самое графически. Текущая локация (тройка):

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-09}
  \caption{Текущая локация}
  \label{fig:chart-zip-09}
\end{figure}

Шаг вверх:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-10}
  \caption{Шаг вверх}
  \label{fig:chart-zip-10}
\end{figure}

Шаг вправо:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-11}
  \caption{Шаг вправо}
  \label{fig:chart-zip-11}
\end{figure}

Исходный вектор может быть любой вложенности. Ради интереса замените тройку на
\code{[5 [6 [7 [8] 9]]]} и проследуйте до девятки.

Что случится, если передать в \code{vector-zip} что-то отличное от вектора?
Предположим, \code{nil}, строку или число. Перед тем, как двигаться, зиппер проверит,
подходит ли узел на роль ветки. Сработает функция \code{vector?}, которая вернет
\code{nil} для всех отличных от вектора значений. В результате получим локацию, из
которой нельзя никуда шагнуть: ни вниз, ни в стороны. Это тупиковый случай, и
его нужно избегать.

\begin{english}
  \begin{clojure}
(-> "test"
    zip/vector-zip
    zip/down)
nil
  \end{clojure}
\end{english}

Модуль \code{clojure.zip} предлагает и другие встроенные зипперы. Особенно интересен
\code{xml-zip} для навигации по XML-дереву. Мы обсудим его отдельно, когда читатель
познакомится с другими свойствами зипперов.
