\chapter{Зипперы}

\begin{teaser}
В этой главе мы рассмотрим зипперы в языке Clojure. Это необычный способ работы
с коллекциями. С помощью зиппера можно обойти произвольные данные, изменить их и
выполнить поиск. Зиппер~--- мощный инструмент, и вложения в него окупаются со
временем. Вместе с тем это довольно сложная абстракция, которая требует
подготовки.
\end{teaser}

\section{Азы навигации}

Объясним зиппер простыми словами. Это обёртка над данными с набором
действий. Вот некоторые из них:

\begin{itemize}

\item
  перемещение по вертикали: вниз к потомкам или вверх к родителю;

\item
  перемещение по горизонтали: влево или вправо среди потомков;

\item
обход всех элементов;

\item
добавление, редактирование и удаление узлов.

\end{itemize}

Это неполный список того, на что способны зипперы. Другие их свойства мы
рассмотрим по ходу главы. Важно, что указанные действия относятся к любым
данным, будь то комбинация векторов и словарей, дерево узлов или XML. Из-за
этого зипперы становятся мощным инструментом. Разобраться с ними означает
повысить свои навыки и открыть новые двери.

\def\huet{https://en.wikipedia.org/wiki/Gerard\_Huet}
\def\huetzipper{https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf}

Термин <<зиппер>> ввел французкий ученый \footurl{Жерар Юэ}{\huet}[G\'{e}rard Huet]
(G\'{e}rard Huet) в 1996 году. Юэ занимался деревьями и искал универсальный
способ работы с ними. В знаменитой работе \footurl{<<Functional Pearl: The Zipper>>}{\huetzipper}[The Zipper]
Юэ привел концепцию зиппера на языке OCaml. Документ
привлек внимание простотой и ясностью: описание зиппера, включая код и
комментарии, уместились на четырех страницах. Современные зипперы почти не
отличаются от того изложения 1996 года.

Хотя Юэ отмечает, что зиппер можно создать на любом языке, лучше всего они
прижились в функциональных: Haskell, OCaml, Clojure. Зипперы поощряют
неизменяемые данные и чистые преобразования. Для упомянутых языков написаны
библиотеки зипперов, и разработчики хотя бы поверхностно знакомы с
ними. Наоборот, в императивной среде зипперы почти неизвестны.

Зипперы доступны в Clojure с первой версии. Их легко добавить в проект, не
опасаясь проблем лицензии или новых зависимостей.

Зипперы в Clojure используют мощь неизменяемых коллекций. Технически зиппер~---
это коллекция, которая хранит данные и позицию в них. Всё вместе это называется
локацией (location). Шаг в любую сторону вернёт новую локацию подобно тому, как
функции \code{assoc} или \code{update} производят новые данные из прежних.

Из текущей локации можно получить \emph{узел} (ноду)~--- данные, на которые ссылается
указатель. На этом моменте путаются новички, поэтому уточним различие. Локация~---
это исходные данные и положение в них. Передвижение по локации порождает
локацию. Из локации можно извлечь узел~--- данные, которые встретились на этом
участке.

Приведём пример с вектором \code{[1 2 3]}. Чтобы переместиться на \textbf{двойку}, обернем
данные в зиппер и выполним команды \code{zip/down} и \code{zip/right}. С первым шагом мы
провалимся в вектор и окажемся на единице. Шаг вправо сдвинет нас на
двойку. Выразим это в коде: подключим модуль \code{clojure.zip} и переместимся по
вектору:

\begin{english}
  \begin{clojure}
(require '[clojure.zip :as zip])

(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/right
    zip/node)
;; 2
  \end{clojure}
\end{english}

Функция \code{zip/vector-zip} зиппер из вектора. Вызовы \code{zip/down} и
\code{zip/right} передвинут указатель на двойку, как и ожидалось. Последний шаг
\code{zip/node} вернет значение (узел) из текущей локации. Если убрать \code{zip/node},
получим локацию, которая соответствует двойке. Вот как она выглядит:

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/right)

;; [2 {:l [1], :pnodes [[1 2 3]], :ppath nil, :r (3)}]
  \end{clojure}
\end{english}

Наверняка у вас возникли вопросы: откуда мы знаем путь к двойке, ведь она могла
быть в другом месте вектора? Что произойдет, если выйти за пределы коллекции?
Мы ответим на эти вопросы ниже. Пока что, если вам что-то непонятно, не впадайте
в панику: мы не раз обсудим всё, что происходит.

Итак, зиппер предлагает перемещение по данным. Несмотря на всю мощь, он не
знает, как делать это для конкретной коллекции, и нуждается в вашей помощи. Вот
что нужно знать зипперу:

\begin{itemize}

\item
  Является ли текущий элемент веткой или нет? Веткой называют элемент, из
  которого можно извлечь другие элементы.

\item
  Если это ветка, как именно получить её элементы?

\end{itemize}

Как только мы знаем ответы на эти вопросы, зиппер готов. Заметим, что для
изменения зиппера нужен ответ на третий вопрос~--- как присоединить потомков к
ветке. Однако сейчас мы рассматриваем только навигацию, и третий вопрос
подождет.

В техническом плане ответы на эти вопросы~--- функции. Первая принимает узел и
возвращает истину или ложь. Если получили истину, зиппер вызовет вторую функцию
с тем же узлом. От нее ожидают коллекцию дочерних узлов или \code{nil}, если их
нет. В терминах зиппера функции называют \code{branch?} и \code{children}
соответственно.

Чтобы получить зиппер, сообщите ему данные и эти две функции. Посколько мы
только читаем зиппер, третья функция будет \code{nil}.

\def\urlclojurezip{https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj}

Зипперы находятся в модуле \code{clojure.zip}. В свободное время исследуйте его код:
он занимает всего \footurl{280 строк}{\urlclojurezip}[zip.clj]!

\begin{english}
  \begin{clojure}
(ns my.project
  (:require [clojure.zip :as zip]))
  \end{clojure}
\end{english}

Функция \code{zip/zipper} порождает зиппер из исходных данных и функций. Это
центральная точка модуля, его строительный материал. Для особых случаев модуль
содержит вспомогательные функции, которые ожидают только данные. Примером служит
функция \code{vector-zip}. Она работает с вектором, элементы которого могут быть
вложенным вектором и так далее. Приведём ее код в сокращении:

\begin{english}
  \begin{clojure}
(defn vector-zip
  [root]
  (zipper vector?
          seq
          ...
          root))
  \end{clojure}
\end{english}

Третий параметр мы заменили на многоточие. Это функция, которая присоединяет к
ветке дочерные узлы при изменении (пока что обходим вопрос стороной).

Если передать в \code{vector-zip} данные \code{[1 2 3]}, произойдёт
следующее. Зиппер обернёт вектор и выставит на него указатель. Из начального
положения можно следовать только вниз, потому что у вершины нет родителя (вверх)
и соседей (влево и вправо). При смещении \textbf{вниз} зиппер сначала проверит,
что текущий узел~--- ветка. Сработает выражение \code{(vector? [1 2 3])}, что
вернёт истину. В этом случае зиппер выполнит \code{(seq [1 2 3])}, чтобы
получить потомков. Ими станет последовательность \code{(1 2 3)}. Как только
потомки найдены, зиппер установит указатель на крайний левый потомок~---
единицу.

Покажем это на схеме. Начальная позиция, указатель на исходном векторе:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-01}
  \caption{Начальная позиция}
  \label{fig:chart-zip-01}
\end{figure}

Шаг вниз, указатель на единице:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-02}
  \caption{Результат смещения вниз}
  \label{fig:chart-zip-02}
\end{figure}

Шаг вправо, указатель на двойке:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-03}
  \caption{Перемещение вправо}
  \label{fig:chart-zip-03}
\end{figure}

Итак, мы находимся на двойке и можем двигаться дальше по горизонтали. Шаг вправо
сдвинет нас на тройку, влево~--- на единицу. Вот как это выглядит в коде:

\begin{english}
  \begin{clojure}
(def loc2
  (-> [1 2 3]
      zip/vector-zip
      zip/down
      zip/right))

(-> loc2 zip/node)
;; 2

(-> loc2 zip/right zip/node)
;; 3

(-> loc2 zip/left zip/node)
;; 1
  \end{clojure}
\end{english}

При попытке сдвинуться вниз зиппер выполнит предикат \code{(vector? 2)}. Результат
будет ложью, что означает, что текущий элемент не ветка, и движение вниз
запрещено.

Во время движения каждый шаг порождает новую локацию, не изменяя старую. Если вы
сохранили очередную локацию в переменную, дальнейшие вызовы \code{zip/right} или
\code{zip/down} не изменят её. Выше мы объявили переменную \code{loc2}, которая
указывает на двойку. Проследуем от нее к исходному вектору:

\begin{english}
  \begin{clojure}
(-> loc2 zip/up zip/node)
;; [1 2 3]
  \end{clojure}
\end{english}

При ручном перемещении велики шансы выйти за пределы данных. Шаг в никуда вернёт
\code{nil} вместо локации:

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/left)
nil
  \end{clojure}
\end{english}

Это сигнал, что вы идёте по неверному пути. Из \code{nil} нельзя вернуться на
прежнее место, потому что у \code{nil} нет сведений о позиции. Для \code{nil}
функции \code{zip/up}, \code{zip/right} и другие тоже вернут \code{nil}. Если не
учесть это в цикле, вы будете топтаться на месте.

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/left
    zip/left
    zip/left
    ...)

;; nil
  \end{clojure}
\end{english}

К исключению относится функция \code{zip/down}: при попытке спуститься из \code{nil} вы
получите \code{NullPointerException}. Это недочёт, который, возможно, когда-нибудь
исправят.

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/left
    zip/down)

;; Execution error (NullPointerException)...
  \end{clojure}
\end{english}

Рассмотрим случай, когда у вектора вложенные элементы: \code{[1 [2 3] 4]}. Чтобы
переместиться на \textbf{тройку}, выполним шаги <<вниз>>, <<вправо>>, <<вниз>>,
<<вправо>>. Сохраним локацию в переменную \code{loc3}:

\begin{english}
  \begin{clojure}
(def loc3
  (-> [1 [2 3] 4]
      zip/vector-zip
      zip/down
      zip/right
      zip/down
      zip/right))

(zip/node loc3)
3
  \end{clojure}
\end{english}

Рисунки ниже показывают, что происходит на каждом шаге. Исходная позиция:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-04}
  \caption{Исходная позиция}
  \label{fig:chart-zip-04}
\end{figure}

Шаг вниз:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-05}
  \caption{Шаг вниз}
  \label{fig:chart-zip-05}
\end{figure}

Вправо:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-06}
  \caption{Шаг вправо}
  \label{fig:chart-zip-06}
\end{figure}

Вниз:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-07}
  \caption{Шаг вниз}
  \label{fig:chart-zip-07}
\end{figure}

Вправо. Мы у цели:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-08}
  \caption{Шаг вправо}
  \label{fig:chart-zip-08}
\end{figure}

Чтобы перейти на \textbf{четвёрку} из текущей позиции, сначала поднимемся
вверх. Указатель сдвинется на вектор \code{[2 3]}. Мы находимся среди потомков
исходного вектора и можем перемещаться по горизонтали. Сделаем шаг вправо и
окажемся на цифре 4.

То же самое графически. Текущая локация (тройка):

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-09}
  \caption{Текущая локация}
  \label{fig:chart-zip-09}
\end{figure}

Шаг вверх:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-10}
  \caption{Шаг вверх}
  \label{fig:chart-zip-10}
\end{figure}

Шаг вправо:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-11}
  \caption{Шаг вправо}
  \label{fig:chart-zip-11}
\end{figure}

Исходный вектор может быть любой вложенности. Ради интереса замените тройку на
\code{[5 [6 [7 [8] 9]]]} и проследуйте до девятки.

Что случится, если передать в \code{vector-zip} что-то отличное от вектора?
Предположим, \code{nil}, строку или число. Перед тем, как двигаться, зиппер проверит,
подходит ли узел на роль ветки. Сработает функция \code{vector?}, которая вернет
\code{nil} для всех отличных от вектора значений. В результате получим локацию, из
которой нельзя никуда шагнуть: ни вниз, ни в стороны. Это тупиковый случай, и
его нужно избегать.

\begin{english}
  \begin{clojure}
(-> "test"
    zip/vector-zip
    zip/down)
nil
  \end{clojure}
\end{english}

Модуль \code{clojure.zip} предлагает и другие встроенные зипперы. Особенно интересен
\code{xml-zip} для навигации по XML-дереву. Мы обсудим его отдельно, когда читатель
познакомится с другими свойствами зипперов.

\section{Автонавигация}

Мы разобрались с тем, как перемещаться по коллекции. Однако у читателя возникнет
вопрос: как мы узнаем заранее, куда двигаться? Откуда приходит путь?

Ответ покажется странным, но все же: ручная навигация по данным лишена всякого
смысла. Если путь известен заранее, вам не нужен зиппер~--- это лишнее
усложнение.

Clojure предлагает более простую работу с данными, структура которых
известна. Например, если мы точно знаем, что на вход поступил вектор, второй
элемент которого вектор, и нужно взять его второй элемент, воспользуемся
\code{get-in}:

\begin{english}
  \begin{clojure}
(def data [1 [2 3] 4])

(get-in data [1 1])
;; 3
  \end{clojure}
\end{english}

То же самое касается других типов данных. Неважно, какую какую комбинацию
образуют списки и словари: если структура известна заранее, до элемента легко
добраться с помощью \code{get-in} или стрелочного оператора. В данном случае зипперы
только усложнят код.

\begin{english}
  \begin{clojure}
(def data {:users [{:name "Ivan"}]})

(-> data :users first :name)
;; "Ivan"
  \end{clojure}
\end{english}

В чем же тогда преимущество зипперов? Свои сильные стороны они проявляют там,
где \code{get-in} не работает. Речь о данных с \textbf{неизвестной} структурой. Представьте,
что на вход поступил произвольный вектор, и нужно найти в нём строку. Она может
быть как на поверхности вектора, так и вложена на три уровня. В этом случае
\code{get-in} не поможет, потому что мы не знаем путь. Другой пример~---
XML-документ. Нужный тег может располагаться где угодно, и нужно как-то его
найти. Таким образом, идеальный случай для зиппера~--- нечёткая структура данных,
о которой у нас только предположения.

Функции \code{zip/up}, \code{zip/down} и другие образуют универсальную \code{zip/next}. Эта
функция передвигает указатель так, что рано или поздно мы обойдем всю
структуру. При обходе исключены повторы: мы побываем в каждом месте только
раз. Пример с вектором:

\begin{english}
  \begin{clojure}
(def vzip (zip/vector-zip [1 [2 3] 4]))

(-> vzip zip/node)
;; [1 [2 3] 4]

(-> vzip zip/next zip/node)
;; 1

(-> vzip zip/next zip/next zip/node)
;; [2 3]

(-> vzip zip/next zip/next zip/next zip/node)
;; 2
  \end{clojure}
\end{english}

Очевидно, мы не знаем, сколько раз вызывать \code{zip/next}, поэтому пойдём на
хитрость. Функция \code{iterate} принимает функцию \code{f} и значение \code{x}. Результатом
станет последовательность, где первый элемент \code{x}, а каждый следующий~--- \code{f(x)}
от предыдущего. Для зиппера мы получим исходную локацию, затем \code{zip/next} от
неё, затем \code{zip/next} от прошлого шага и так далее.

Переменная \code{loc-seq} ниже -- это цепочка локаций исходного зиппера. Чтобы
получить узлы, мы берём шесть первых элементов (число взяли случайно) и вызываем
для каждого \code{zip/node}.

\begin{english}
  \begin{clojure}
(def loc-seq (iterate zip/next vzip))

(->> loc-seq
     (take 6)
     (map zip/node))

;; ([1 [2 3] 4]
;;   1
;;   [2 3]
;;   2
;;   3
;;   4)
  \end{clojure}
\end{english}

\code{Iterate} порождает \textbf{ленивую} и \textbf{бесконечную} последовательность. Обе
характеристики важны. Ленивость означает, что очередной сдвиг (вызов \code{zip/next})
не произойдёт до тех пор, пока вы не дойдёте до элемента в
цепочке. Бесконечность означает, что \code{zip/next} вызывается неограниченное число
раз. Понадобится признак, по которому мы остановим вызов \code{zip/next}, иначе поток
локаций никогда не закончится.

Если исследовать \code{loc-seq}, станет ясно, что в какой-то момент \code{zip/next} уже не
сдвигает указатель. Возьмём наугад сотый и тысячный элементы итерации. Их узел
будет исходным вектором:

\begin{english}
  \begin{clojure}
(-> loc-seq (nth 100) zip/node)
;; [1 [2 3] 4]

(-> loc-seq (nth 1000) zip/node)
;; [1 [2 3] 4]

  \end{clojure}
\end{english}

Причина кроется в устройстве зиппера. Функция \code{zip/next} работает по принципу
кольца. Когда она достигает исходной локации, цикл завершается. При этом локация
получит признак завершения, и дальнейший вызов \code{zip/next} вернёт её
же. Проверить признак можно функцией \code{zip/end?}:

\begin{english}
  \begin{clojure}
(def loc-end
  (-> [1 2 3]
      zip/vector-zip
      zip/next
      zip/next
      zip/next
      zip/next))

loc-end
;; [[1 2 3] :end]

(zip/end? loc-end)
;; true

  \end{clojure}
\end{english}

Чтобы получить конечную цепь локаций, будем сдвигать указатель до тех пор, пока
локация не последняя. Всё вместе даёт функцию \code{iter-zip}:

\begin{english}
  \begin{clojure}
(defn iter-zip [zipper]
  (->> zipper
       (iterate zip/next)
       (take-while (complement zip/end?))))
  \end{clojure}
\end{english}

Функция вернёт все локации от начальной до конечной не включая ее. Напомним, что
локация хранит узел (элемент данных), который можно извлечь с помощью
\code{zip/node}. Код ниже показывает, как превратить локации в данные:

\begin{english}
  \begin{clojure}
(->> [1 [2 3] 4]
     zip/vector-zip
     iter-zip
     (map zip/node))

;; ([1 [2 3] 4]
;;  1
;;  [2 3]
;;  2
;;  3
;;  4)
  \end{clojure}
\end{english}

Теперь когда мы получили цепочку локаций, напишем поиск. Предположим, нужно
проверить, есть ли в векторе кейворд \code{:error}. Сначала напишем предикат для
локации -- равен ли её узел этому значению:

\begin{english}
  \begin{clojure}
(defn loc-error? [loc]
  (-> loc zip/node (= :error)))
  \end{clojure}
\end{english}

Проверим, если ли среди локаций та, что подходит нашему предикату.  Для этого
вызовем \code{some}:

\begin{english}
  \begin{clojure}
(def data [1 [2 3 [:test [:foo :error]]] 4])

(some loc-error?
      (-> data zip/vector-zip iter-zip))

;; true
  \end{clojure}
\end{english}

Из-за ленивости мы не сканируем вектор целиком. Если нужный узел нашелся на
середине, \code{iter-zip} прекращает итерацию, и дальнейшие вызовы \code{zip/next} не
произойдут.

Полезно знать, что \code{zip/next} обходит дерево в глубину. При движении он
стремится вниз и вправо, а наверх поднимается лишь когда шаги в эти стороны
невозможны. Как мы увидим дальше, в некоторых случаях порядок обхода
важен. Попадаются задачи, где мы должны двигаться вширь. По умолчанию в
\code{clojure.zip} нет других вариантов обхода, но мы напишем собственный. Также мы
рассмотрим задачу, где понадобится обход вширь.

Встроенный зиппер \code{vector-zip} служит для вложенных векторов. Но гораздо чаще
встречаются вложенные словари. Напишем зиппер для обхода подобных данных:

\begin{english}
  \begin{clojure}
(def map-data
  {:foo 1
   :bar 2
   :baz {:test "hello"
         :word {:nested true}}})
  \end{clojure}
\end{english}

За основу возьмём знакомый нам \code{vector-zip}. Зипперы похожи, разница лишь в типе
коллекции. Подумаем, как задать функции \code{branch?} и \code{children}. Сам по себе
словарь~--- это ветка, чью потомки~--- элементы \code{MapEntry}. Тип \code{MapEntry} выражает
пару ключа и значения. Если значение~--- словарь, получим из него цепочку
вложенных \code{MapEntry} и так далее.

Для разминки напишем проверку на тип \code{MapEntry}:

\begin{english}
  \begin{clojure}
(def entry?
  (partial instance? clojure.lang.MapEntry))
  \end{clojure}
\end{english}

Зиппер \code{map-zip} выглядит так:

\begin{english}
  \begin{clojure}
(defn map-zip [mapping]
  (zip/zipper
   (some-fn entry? map?)
   (fn [x]
     (cond
       (map? x)
       (seq x)
       (and (entry? x) (-> x val map?))
       (-> x val seq)))
   nil
   mapping))
  \end{clojure}
\end{english}

Поясним основные моменты. Композиция \code{(some-fn ...)} вернёт истину, если хотя бы
один из предикатов сработает положительно. Иными словами, на роль ветки мы
рассматриваем только словарь или его узел (пару ключ-значение).

Во второй функции, которая ищет потомков, приходится делать перебор. Для словаря
(проверка \code{map?}) получим потомков функцией \code{seq} -- она вернёт цепочку
элементов \code{MapEntry}. Если текущий элемент -- \code{MapEntry}, проверим, является ли
его значение вложенным словарём (функция \code{var} вернет второй элемент
\code{MapEntry}). Если да, получим потомков той же функцией \code{seq}.

Обход зиппера вернет все пары ключей и значений. Если значение~--- вложенный
словарь, мы провалимся в него при обходе. Пример:

\begin{english}
  \begin{clojure}
(->> {:foo 42
      :bar {:baz 11
            :user/name "Ivan"}}
     map-zip
     iter-zip
     rest
     (map zip/node))

;; ([:foo 42]
;;  [:bar {:baz 11, :user/name "Ivan"}]
;;  [:baz 11]
;;  [:user/name "Ivan"])
  \end{clojure}
\end{english}

Обратите внимание на функцию \code{rest} после \code{iter-zip}. Мы отбросили первую
локацию, в которой находятся исходные данные. Поскольку они известны, нет смысла
печатать их.

С помощью нашего \code{map-zip} легко проверить, есть ли в словаре ключ \code{:error} со
значением \code{:auth}. По отдельности эти кейворды могут быть где угодно~--- и в
ключах, и в значениях на любом уровне. Однако нас интересует их комбинация. Для
этого напишем предикат:

\begin{english}
  \begin{clojure}
(defn loc-err-auth? [loc]
  (-> loc zip/node (= [:error :auth])))
  \end{clojure}
\end{english}

Убедимся, что в первом словаре нет пары, даже не смотря на то, что значения
встречаются по отдельности:

\begin{english}
  \begin{clojure}
(->> {:response {:error :expired
                 :auth :failed}}
     map-zip
     iter-zip
     (some loc-err-auth?))

;; nil
  \end{clojure}
\end{english}

Но даже если пара вложена глубоко, мы найдём её:

\begin{english}
  \begin{clojure}
(def data
  {:response {:info {:message "Auth error"
                     :error :auth
                     :code 1005}}})

(->> data
     map-zip
     iter-zip
     (some loc-err-auth?))

;; true
  \end{clojure}
\end{english}

Предлагаем читателю несколько заданий для самостоятельной работы.

\begin{enumerate}

\item
  Зиппер \code{map-zip} не учитывает случай, когда ключ словаря -- другой словарь,
  например:

\begin{english}
  \begin{clojure}
{{:alg "MD5" :salt "..."} "deprecated"
 {:alg "SHA2" :salt "..."} "deprecated"
 {:alg "HMAC-SHA256" :key "..."} "ok"}
  \end{clojure}
\end{english}

Такие коллекции хоть и редко, но встречаются в практике. Доработайте \code{map-zip},
чтобы он проверял не только значение \code{MapEntry}, но и ключ (вместо \code{val}
используйте \code{key}).

\item
  Мы рассмотрели зипперы для векторов и словарей по отдельности. На практике мы
  работаем со смешанными данными, когда словари и векторы вложены друг в
  друга. Напишите универсальный зиппер, который учитывает обе коллекции при
  обходе.

\end{enumerate}
