\chapter{Зипперы}

\begin{teaser}
В этой главе мы рассмотрим зипперы в языке Clojure. Это необычный способ работы
с коллекциями. С помощью зиппера можно обойти произвольные данные, изменить их и
выполнить поиск. Зиппер~--- мощный инструмент, и вложения в него окупаются со
временем. Вместе с тем это довольно сложная абстракция, которая требует
подготовки.
\end{teaser}

\section{Азы навигации}

Объясним зиппер простыми словами. Это обёртка над данными с набором
действий. Вот некоторые из них:

\begin{itemize}

\item
  перемещение по вертикали: вниз к потомкам или вверх к родителю;

\item
  перемещение по горизонтали: влево или вправо среди потомков;

\item
обход всех элементов;

\item
добавление, редактирование и удаление узлов.

\end{itemize}

Это неполный список того, на что способны зипперы. Другие их свойства мы
рассмотрим по ходу главы. Важно, что указанные действия относятся к любым
данным, будь то комбинация векторов и словарей, дерево узлов или XML. Из-за
этого зипперы становятся мощным инструментом. Разобраться с ними означает
повысить свои навыки и открыть новые двери.

\def\huet{https://en.wikipedia.org/wiki/Gerard\_Huet}
\def\huetzipper{https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf}

Термин <<зиппер>> ввел французкий ученый \footurl{Жерар Юэ}{\huet}[G\'{e}rard Huet]
(G\'{e}rard Huet) в 1996 году. Юэ занимался деревьями и искал универсальный
способ работы с ними. В знаменитой работе \footurl{<<Functional Pearl: The Zipper>>}{\huetzipper}[The Zipper]
Юэ привел концепцию зиппера на языке OCaml. Документ
привлек внимание простотой и ясностью: описание зиппера, включая код и
комментарии, уместились на четырех страницах. Современные зипперы почти не
отличаются от того изложения 1996 года.

Хотя Юэ отмечает, что зиппер можно создать на любом языке, лучше всего они
прижились в функциональных: Haskell, OCaml, Clojure. Зипперы поощряют
неизменяемые данные и чистые преобразования. Для упомянутых языков написаны
библиотеки зипперов, и разработчики хотя бы поверхностно знакомы с
ними. Наоборот, в императивной среде зипперы почти неизвестны.

Зипперы доступны в Clojure с первой версии. Их легко добавить в проект, не
опасаясь проблем лицензии или новых зависимостей.

Зипперы в Clojure используют мощь неизменяемых коллекций. Технически зиппер~---
это коллекция, которая хранит данные и позицию в них. Всё вместе это называется
локацией (location). Шаг в любую сторону вернёт новую локацию подобно тому, как
функции \code{assoc} или \code{update} производят новые данные из прежних.

Из текущей локации можно получить \emph{узел} (ноду)~--- данные, на которые ссылается
указатель. На этом моменте путаются новички, поэтому уточним различие. Локация~---
это исходные данные и положение в них. Передвижение по локации порождает
локацию. Из локации можно извлечь узел~--- данные, которые встретились на этом
участке.

Приведём пример с вектором \code{[1 2 3]}. Чтобы переместиться на \textbf{двойку}, обернем
данные в зиппер и выполним команды \code{zip/down} и \code{zip/right}. С первым шагом мы
провалимся в вектор и окажемся на единице. Шаг вправо сдвинет нас на
двойку. Выразим это в коде: подключим модуль \code{clojure.zip} и переместимся по
вектору:

\begin{english}
  \begin{clojure}
(require '[clojure.zip :as zip])

(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/right
    zip/node)
;; 2
  \end{clojure}
\end{english}

Функция \code{zip/vector-zip} зиппер из вектора. Вызовы \code{zip/down} и
\code{zip/right} передвинут указатель на двойку, как и ожидалось. Последний шаг
\code{zip/node} вернет значение (узел) из текущей локации. Если убрать \code{zip/node},
получим локацию, которая соответствует двойке. Вот как она выглядит:

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/right)

;; [2 {:l [1], :pnodes [[1 2 3]], :ppath nil, :r (3)}]
  \end{clojure}
\end{english}

Наверняка у вас возникли вопросы: откуда мы знаем путь к двойке, ведь она могла
быть в другом месте вектора? Что произойдет, если выйти за пределы коллекции?
Мы ответим на эти вопросы ниже. Пока что, если вам что-то непонятно, не впадайте
в панику: мы не раз обсудим всё, что происходит.

Итак, зиппер предлагает перемещение по данным. Несмотря на всю мощь, он не
знает, как делать это для конкретной коллекции, и нуждается в вашей помощи. Вот
что нужно знать зипперу:

\begin{itemize}

\item
  Является ли текущий элемент веткой или нет? Веткой называют элемент, из
  которого можно извлечь другие элементы.

\item
  Если это ветка, как именно получить её элементы?

\end{itemize}

Как только мы знаем ответы на эти вопросы, зиппер готов. Заметим, что для
изменения зиппера нужен ответ на третий вопрос~--- как присоединить потомков к
ветке. Однако сейчас мы рассматриваем только навигацию, и третий вопрос
подождет.

В техническом плане ответы на эти вопросы~--- функции. Первая принимает узел и
возвращает истину или ложь. Если получили истину, зиппер вызовет вторую функцию
с тем же узлом. От нее ожидают коллекцию дочерних узлов или \code{nil}, если их
нет. В терминах зиппера функции называют \code{branch?} и \code{children}
соответственно.

Чтобы получить зиппер, сообщите ему данные и эти две функции. Посколько мы
только читаем зиппер, третья функция будет \code{nil}.

\def\urlclojurezip{https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj}

Зипперы находятся в модуле \code{clojure.zip}. В свободное время исследуйте его код:
он занимает всего \footurl{280 строк}{\urlclojurezip}[zip.clj]!

\begin{english}
  \begin{clojure}
(ns my.project
  (:require [clojure.zip :as zip]))
  \end{clojure}
\end{english}

Функция \code{zip/zipper} порождает зиппер из исходных данных и функций. Это
центральная точка модуля, его строительный материал. Для особых случаев модуль
содержит вспомогательные функции, которые ожидают только данные. Примером служит
функция \code{vector-zip}. Она работает с вектором, элементы которого могут быть
вложенным вектором и так далее. Приведём ее код в сокращении:

\begin{english}
  \begin{clojure}
(defn vector-zip
  [root]
  (zipper vector?
          seq
          ...
          root))
  \end{clojure}
\end{english}

Третий параметр мы заменили на многоточие. Это функция, которая присоединяет к
ветке дочерные узлы при изменении (пока что обходим вопрос стороной).

Если передать в \code{vector-zip} данные \code{[1 2 3]}, произойдёт
следующее. Зиппер обернёт вектор и выставит на него указатель. Из начального
положения можно следовать только вниз, потому что у вершины нет родителя (вверх)
и соседей (влево и вправо). При смещении \textbf{вниз} зиппер сначала проверит,
что текущий узел~--- ветка. Сработает выражение \code{(vector? [1 2 3])}, что
вернёт истину. В этом случае зиппер выполнит \code{(seq [1 2 3])}, чтобы
получить потомков. Ими станет последовательность \code{(1 2 3)}. Как только
потомки найдены, зиппер установит указатель на крайний левый потомок~---
единицу.

Покажем это на схеме. Начальная позиция, указатель на исходном векторе:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-01}
  \caption{Начальная позиция}
  \label{fig:chart-zip-01}
\end{figure}

Шаг вниз, указатель на единице:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-02}
  \caption{Результат смещения вниз}
  \label{fig:chart-zip-02}
\end{figure}

Шаг вправо, указатель на двойке:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-03}
  \caption{Перемещение вправо}
  \label{fig:chart-zip-03}
\end{figure}

Итак, мы находимся на двойке и можем двигаться дальше по горизонтали. Шаг вправо
сдвинет нас на тройку, влево~--- на единицу. Вот как это выглядит в коде:

\begin{english}
  \begin{clojure}
(def loc2
  (-> [1 2 3]
      zip/vector-zip
      zip/down
      zip/right))

(-> loc2 zip/node)
;; 2

(-> loc2 zip/right zip/node)
;; 3

(-> loc2 zip/left zip/node)
;; 1
  \end{clojure}
\end{english}

При попытке сдвинуться вниз зиппер выполнит предикат \code{(vector? 2)}. Результат
будет ложью, что означает, что текущий элемент не ветка, и движение вниз
запрещено.

Во время движения каждый шаг порождает новую локацию, не изменяя старую. Если вы
сохранили очередную локацию в переменную, дальнейшие вызовы \code{zip/right} или
\code{zip/down} не изменят её. Выше мы объявили переменную \code{loc2}, которая
указывает на двойку. Проследуем от нее к исходному вектору:

\begin{english}
  \begin{clojure}
(-> loc2 zip/up zip/node)
;; [1 2 3]
  \end{clojure}
\end{english}

При ручном перемещении велики шансы выйти за пределы данных. Шаг в никуда вернёт
\code{nil} вместо локации:

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/left)
nil
  \end{clojure}
\end{english}

Это сигнал, что вы идёте по неверному пути. Из \code{nil} нельзя вернуться на
прежнее место, потому что у \code{nil} нет сведений о позиции. Для \code{nil}
функции \code{zip/up}, \code{zip/right} и другие тоже вернут \code{nil}. Если не
учесть это в цикле, вы будете топтаться на месте.

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/left
    zip/left
    zip/left
    ...)

;; nil
  \end{clojure}
\end{english}

К исключению относится функция \code{zip/down}: при попытке спуститься из \code{nil} вы
получите \code{NullPointerException}. Это недочёт, который, возможно, когда-нибудь
исправят.

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/left
    zip/down)

;; Execution error (NullPointerException)...
  \end{clojure}
\end{english}

Рассмотрим случай, когда у вектора вложенные элементы: \code{[1 [2 3] 4]}. Чтобы
переместиться на \textbf{тройку}, выполним шаги <<вниз>>, <<вправо>>, <<вниз>>,
<<вправо>>. Сохраним локацию в переменную \code{loc3}:

\begin{english}
  \begin{clojure}
(def loc3
  (-> [1 [2 3] 4]
      zip/vector-zip
      zip/down
      zip/right
      zip/down
      zip/right))

(zip/node loc3)
3
  \end{clojure}
\end{english}

Рисунки ниже показывают, что происходит на каждом шаге. Исходная позиция:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-04}
  \caption{Исходная позиция}
  \label{fig:chart-zip-04}
\end{figure}

Шаг вниз:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-05}
  \caption{Шаг вниз}
  \label{fig:chart-zip-05}
\end{figure}

Вправо:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-06}
  \caption{Шаг вправо}
  \label{fig:chart-zip-06}
\end{figure}

Вниз:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-07}
  \caption{Шаг вниз}
  \label{fig:chart-zip-07}
\end{figure}

Вправо. Мы у цели:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-08}
  \caption{Шаг вправо}
  \label{fig:chart-zip-08}
\end{figure}

Чтобы перейти на \textbf{четвёрку} из текущей позиции, сначала поднимемся
вверх. Указатель сдвинется на вектор \code{[2 3]}. Мы находимся среди потомков
исходного вектора и можем перемещаться по горизонтали. Сделаем шаг вправо и
окажемся на цифре 4.

То же самое графически. Текущая локация (тройка):

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-09}
  \caption{Текущая локация}
  \label{fig:chart-zip-09}
\end{figure}

Шаг вверх:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-10}
  \caption{Шаг вверх}
  \label{fig:chart-zip-10}
\end{figure}

Шаг вправо:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-11}
  \caption{Шаг вправо}
  \label{fig:chart-zip-11}
\end{figure}

Исходный вектор может быть любой вложенности. Ради интереса замените тройку на
\code{[5 [6 [7 [8] 9]]]} и проследуйте до девятки.

Что случится, если передать в \code{vector-zip} что-то отличное от вектора?
Предположим, \code{nil}, строку или число. Перед тем, как двигаться, зиппер проверит,
подходит ли узел на роль ветки. Сработает функция \code{vector?}, которая вернет
\code{nil} для всех отличных от вектора значений. В результате получим локацию, из
которой нельзя никуда шагнуть: ни вниз, ни в стороны. Это тупиковый случай, и
его нужно избегать.

\begin{english}
  \begin{clojure}
(-> "test"
    zip/vector-zip
    zip/down)
nil
  \end{clojure}
\end{english}

Модуль \code{clojure.zip} предлагает и другие встроенные зипперы. Особенно интересен
\code{xml-zip} для навигации по XML-дереву. Мы обсудим его отдельно, когда читатель
познакомится с другими свойствами зипперов.

\section{Автонавигация}

Мы разобрались с тем, как перемещаться по коллекции. Однако у читателя возникнет
вопрос: как мы узнаем заранее, куда двигаться? Откуда приходит путь?

Ответ покажется странным, но все же: ручная навигация по данным лишена всякого
смысла. Если путь известен заранее, вам не нужен зиппер~--- это лишнее
усложнение.

Clojure предлагает более простую работу с данными, структура которых
известна. Например, если мы точно знаем, что на вход поступил вектор, второй
элемент которого вектор, и нужно взять его второй элемент, воспользуемся
\code{get-in}:

\begin{english}
  \begin{clojure}
(def data [1 [2 3] 4])

(get-in data [1 1])
;; 3
  \end{clojure}
\end{english}

То же самое касается других типов данных. Неважно, какую какую комбинацию
образуют списки и словари: если структура известна заранее, до элемента легко
добраться с помощью \code{get-in} или стрелочного оператора. В данном случае зипперы
только усложнят код.

\begin{english}
  \begin{clojure}
(def data {:users [{:name "Ivan"}]})

(-> data :users first :name)
;; "Ivan"
  \end{clojure}
\end{english}

В чем же тогда преимущество зипперов? Свои сильные стороны они проявляют там,
где \code{get-in} не работает. Речь о данных с \textbf{неизвестной} структурой. Представьте,
что на вход поступил произвольный вектор, и нужно найти в нём строку. Она может
быть как на поверхности вектора, так и вложена на три уровня. В этом случае
\code{get-in} не поможет, потому что мы не знаем путь. Другой пример~---
XML-документ. Нужный тег может располагаться где угодно, и нужно как-то его
найти. Таким образом, идеальный случай для зиппера~--- нечёткая структура данных,
о которой у нас только предположения.

Функции \code{zip/up}, \code{zip/down} и другие образуют универсальную \code{zip/next}. Эта
функция передвигает указатель так, что рано или поздно мы обойдем всю
структуру. При обходе исключены повторы: мы побываем в каждом месте только
раз. Пример с вектором:

\begin{english}
  \begin{clojure}
(def vzip (zip/vector-zip [1 [2 3] 4]))

(-> vzip zip/node)
;; [1 [2 3] 4]

(-> vzip zip/next zip/node)
;; 1

(-> vzip zip/next zip/next zip/node)
;; [2 3]

(-> vzip zip/next zip/next zip/next zip/node)
;; 2
  \end{clojure}
\end{english}

Очевидно, мы не знаем, сколько раз вызывать \code{zip/next}, поэтому пойдём на
хитрость. Функция \code{iterate} принимает функцию \code{f} и значение \code{x}. Результатом
станет последовательность, где первый элемент \code{x}, а каждый следующий~--- \code{f(x)}
от предыдущего. Для зиппера мы получим исходную локацию, затем \code{zip/next} от
неё, затем \code{zip/next} от прошлого шага и так далее.

Переменная \code{loc-seq} ниже~--- это цепочка локаций исходного зиппера. Чтобы
получить узлы, мы берём шесть первых элементов (число взяли случайно) и вызываем
для каждого \code{zip/node}.

\begin{english}
  \begin{clojure}
(def loc-seq (iterate zip/next vzip))

(->> loc-seq
     (take 6)
     (map zip/node))

;; ([1 [2 3] 4]
;;   1
;;   [2 3]
;;   2
;;   3
;;   4)
  \end{clojure}
\end{english}

\code{Iterate} порождает \textbf{ленивую} и \textbf{бесконечную} последовательность. Обе
характеристики важны. Ленивость означает, что очередной сдвиг (вызов \code{zip/next})
не произойдёт до тех пор, пока вы не дойдёте до элемента в
цепочке. Бесконечность означает, что \code{zip/next} вызывается неограниченное число
раз. Понадобится признак, по которому мы остановим вызов \code{zip/next}, иначе поток
локаций никогда не закончится.

Если исследовать \code{loc-seq}, станет ясно, что в какой-то момент \code{zip/next} уже не
сдвигает указатель. Возьмём наугад сотый и тысячный элементы итерации. Их узел
будет исходным вектором:

\begin{english}
  \begin{clojure}
(-> loc-seq (nth 100) zip/node)
;; [1 [2 3] 4]

(-> loc-seq (nth 1000) zip/node)
;; [1 [2 3] 4]

  \end{clojure}
\end{english}

Причина кроется в устройстве зиппера. Функция \code{zip/next} работает по принципу
кольца. Когда она достигает исходной локации, цикл завершается. При этом локация
получит признак завершения, и дальнейший вызов \code{zip/next} вернёт её
же. Проверить признак можно функцией \code{zip/end?}:

\begin{english}
  \begin{clojure}
(def loc-end
  (-> [1 2 3]
      zip/vector-zip
      zip/next
      zip/next
      zip/next
      zip/next))

loc-end
;; [[1 2 3] :end]

(zip/end? loc-end)
;; true

  \end{clojure}
\end{english}

Чтобы получить конечную цепь локаций, будем сдвигать указатель до тех пор, пока
локация не последняя. Всё вместе даёт функцию \code{iter-zip}:

\begin{english}
  \begin{clojure}
(defn iter-zip [zipper]
  (->> zipper
       (iterate zip/next)
       (take-while (complement zip/end?))))
  \end{clojure}
\end{english}

Функция вернёт все локации от начальной до конечной не включая ее. Напомним, что
локация хранит узел (элемент данных), который можно извлечь с помощью
\code{zip/node}. Код ниже показывает, как превратить локации в данные:

\begin{english}
  \begin{clojure}
(->> [1 [2 3] 4]
     zip/vector-zip
     iter-zip
     (map zip/node))

;; ([1 [2 3] 4]
;;  1
;;  [2 3]
;;  2
;;  3
;;  4)
  \end{clojure}
\end{english}

Теперь когда мы получили цепочку локаций, напишем поиск. Предположим, нужно
проверить, есть ли в векторе кейворд \code{:error}. Сначала напишем предикат для
локации~--- равен ли её узел этому значению:

\begin{english}
  \begin{clojure}
(defn loc-error? [loc]
  (-> loc zip/node (= :error)))
  \end{clojure}
\end{english}

Проверим, если ли среди локаций та, что подходит нашему предикату.  Для этого
вызовем \code{some}:

\begin{english}
  \begin{clojure}
(def data [1 [2 3 [:test [:foo :error]]] 4])

(some loc-error?
      (-> data zip/vector-zip iter-zip))

;; true
  \end{clojure}
\end{english}

Из-за ленивости мы не сканируем вектор целиком. Если нужный узел нашелся на
середине, \code{iter-zip} прекращает итерацию, и дальнейшие вызовы \code{zip/next} не
произойдут.

Полезно знать, что \code{zip/next} обходит дерево в глубину. При движении он
стремится вниз и вправо, а наверх поднимается лишь когда шаги в эти стороны
невозможны. Как мы увидим дальше, в некоторых случаях порядок обхода
важен. Попадаются задачи, где мы должны двигаться вширь. По умолчанию в
\code{clojure.zip} нет других вариантов обхода, но мы напишем собственный. Также мы
рассмотрим задачу, где понадобится обход вширь.

Встроенный зиппер \code{vector-zip} служит для вложенных векторов. Но гораздо чаще
встречаются вложенные словари. Напишем зиппер для обхода подобных данных:

\begin{english}
  \begin{clojure}
(def map-data
  {:foo 1
   :bar 2
   :baz {:test "hello"
         :word {:nested true}}})
  \end{clojure}
\end{english}

За основу возьмём знакомый нам \code{vector-zip}. Зипперы похожи, разница лишь в типе
коллекции. Подумаем, как задать функции \code{branch?} и \code{children}. Сам по себе
словарь~--- это ветка, чью потомки~--- элементы \code{MapEntry}. Тип \code{MapEntry} выражает
пару ключа и значения. Если значение~--- словарь, получим из него цепочку
вложенных \code{MapEntry} и так далее.

Для разминки напишем проверку на тип \code{MapEntry}:

\begin{english}
  \begin{clojure}
(def entry?
  (partial instance? clojure.lang.MapEntry))
  \end{clojure}
\end{english}

Зиппер \code{map-zip} выглядит так:

\begin{english}
  \begin{clojure}
(defn map-zip [mapping]
  (zip/zipper
   (some-fn entry? map?)
   (fn [x]
     (cond
       (map? x)
       (seq x)
       (and (entry? x) (-> x val map?))
       (-> x val seq)))
   nil
   mapping))
  \end{clojure}
\end{english}

Поясним основные моменты. Композиция \code{(some-fn ...)} вернёт истину, если хотя бы
один из предикатов сработает положительно. Иными словами, на роль ветки мы
рассматриваем только словарь или его узел (пару ключ-значение).

Во второй функции, которая ищет потомков, приходится делать перебор. Для словаря
(проверка \code{map?}) получим потомков функцией \code{seq}~--- она вернёт цепочку
элементов \code{MapEntry}. Если текущий элемент~--- \code{MapEntry}, проверим, является ли
его значение вложенным словарём (функция \code{var} вернет второй элемент
\code{MapEntry}). Если да, получим потомков той же функцией \code{seq}.

Обход зиппера вернет все пары ключей и значений. Если значение~--- вложенный
словарь, мы провалимся в него при обходе. Пример:

\begin{english}
  \begin{clojure}
(->> {:foo 42
      :bar {:baz 11
            :user/name "Ivan"}}
     map-zip
     iter-zip
     rest
     (map zip/node))

;; ([:foo 42]
;;  [:bar {:baz 11, :user/name "Ivan"}]
;;  [:baz 11]
;;  [:user/name "Ivan"])
  \end{clojure}
\end{english}

Обратите внимание на функцию \code{rest} после \code{iter-zip}. Мы отбросили первую
локацию, в которой находятся исходные данные. Поскольку они известны, нет смысла
печатать их.

С помощью нашего \code{map-zip} легко проверить, есть ли в словаре ключ \code{:error} со
значением \code{:auth}. По отдельности эти кейворды могут быть где угодно~--- и в
ключах, и в значениях на любом уровне. Однако нас интересует их комбинация. Для
этого напишем предикат:

\begin{english}
  \begin{clojure}
(defn loc-err-auth? [loc]
  (-> loc zip/node (= [:error :auth])))
  \end{clojure}
\end{english}

Убедимся, что в первом словаре нет пары, даже не смотря на то, что значения
встречаются по отдельности:

\begin{english}
  \begin{clojure}
(->> {:response {:error :expired
                 :auth :failed}}
     map-zip
     iter-zip
     (some loc-err-auth?))

;; nil
  \end{clojure}
\end{english}

Но даже если пара вложена глубоко, мы найдём её:

\begin{english}
  \begin{clojure}
(def data
  {:response {:info {:message "Auth error"
                     :error :auth
                     :code 1005}}})

(->> data
     map-zip
     iter-zip
     (some loc-err-auth?))

;; true
  \end{clojure}
\end{english}

Предлагаем читателю несколько заданий для самостоятельной работы.

\begin{enumerate}

\item
  Зиппер \code{map-zip} не учитывает случай, когда ключ словаря~--- другой словарь,
  например:

\begin{english}
  \begin{clojure}
{{:alg "MD5" :salt "..."} "deprecated"
 {:alg "SHA2" :salt "..."} "deprecated"
 {:alg "HMAC-SHA256" :key "..."} "ok"}
  \end{clojure}
\end{english}

Такие коллекции хоть и редко, но встречаются в практике. Доработайте \code{map-zip},
чтобы он проверял не только значение \code{MapEntry}, но и ключ (вместо \code{val}
используйте \code{key}).

\item
  Мы рассмотрели зипперы для векторов и словарей по отдельности. На практике мы
  работаем со смешанными данными, когда словари и векторы вложены друг в
  друга. Напишите универсальный зиппер, который учитывает обе коллекции при
  обходе.

\end{enumerate}

\section{XML-зипперы}

Мощь зипперов раскрывается в полной мере при работе с XML. От других форматов он
отличается тем, что задан рекурсивно. Например, JSON, YAML и другие форматы
предлагают типы~--- числа, строки, коллекции,~--- у которых разный синтаксис и
структура. В XML, где бы мы ни находились, текущий узел состоит из трёх
элементов: тега, атрибутов и содержимого.

Тег~--- это короткое имя узла, например \code{name} или \code{description}. Атрибуты~---
словарь свойств и их значений. Наиболее интересно содержимое: это набор строк
или других узлов. Вот как выглядит XML на псевдокоде:

\begin{english}
  \begin{text}
XML = [Tag, Attrs, [String|XML]]
  \end{text}
\end{english}

Чтобы убедиться в однородности XML, рассмотрим файл с товарами поставщиков:

\begin{english}
  \begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
  <organization name="re-Store">
    <product type="iphone">iPhone 11 Pro</product>
    <product type="iphone">iPhone SE</product>
  </organization>
  <organization name="DNS">
    <product type="tablet">iPad 3</product>
    <product type="notebook">Macbook Pro</product>
  </organization>
</catalog>
  \end{xml}
\end{english}

На вершине XML находится узел \code{catalog}. Это группировочный тег: он необходим,
потому что на вершине не может быть несколько тегов. Потомки каталога~---
организации. В атрибуте \code{name} организации указано её имя. Под организацией идут
товары~--- узлы с тегом \code{product} и атрибутом \code{type}. Вместо потомков товар
содержит текст~--- подробное описание. Ниже него спуститься уже нельзя.

Clojure предлагает XML-парсер, который вернет структуру, похожую на схему
\code{[Tag, Attrs, Content]} выше. Каждый узел станет словарем с ключами
\code{:tag}, \code{:attrs} и \code{:content}. Последний хранит вектор, где
элемент либо строка, либо вложенный словарь.

Поместим XML с товарами в файл \code{resources/products.xml}. Напишем функцию, чтобы
считать файл в XML-зиппер. Добавьте модули \code{xml} и \code{io}:

\begin{english}
  \begin{clojure}
(:require
 [clojure.java.io :as io]
 [clojure.xml :as xml])
  \end{clojure}
\end{english}

Оба входят в поставку Clojure и не требуют зависимостей. Чтобы получить зиппер,
пропустим параметр \code{path} через серию функций:

\begin{english}
  \begin{clojure}
(defn ->xml-zipper [path]
  (-> path
      io/resource
      io/file
      xml/parse
      zip/xml-zip))
  \end{clojure}
\end{english}

Функция \code{xml/parse} вернёт структуру словарей с ключами \code{:tag}, \code{:attrs} и
\code{:content}. Обратите внимание, что текстовое содержимое, например, название
товара, это тоже вектор с одной строкой. Тем самым достигается однородность
каждого узла.

Вот что получим после вызова \code{xml/parse}:

\begin{english}
  \begin{clojure}
{:tag :catalog
 :attrs nil
 :content
 [{:tag :organization
   :attrs {:name "re-Store"}
   :content
   [{:tag :product
     :attrs {:type "iphone"}
     :content ["iPhone 11 Pro"]}
    {:tag :product :attrs {:type "iphone"} :content ["iPhone SE"]}]}
  {:tag :organization
   :attrs {:name "DNS"}
   :content
   [{:tag :product :attrs {:type "tablet"} :content ["iPad 3"]}
    {:tag :product
     :attrs {:type "notebook"}
     :content ["Macbook Pro"]}]}]}
  \end{clojure}
\end{english}

Вызов \code{(->xml-zipper "products.xml")} вернет первую локацию зиппера XML. Прежде
чем работать с ним, заглянем в определение \code{xml-zip}, чтобы понять, что
происходит. Приведём код из \code{clojure.zip} в сокращении:

\begin{english}
  \begin{clojure}
(defn xml-zip
  [root]
  (zipper (complement string?)
          (comp seq :content)
          ...
          root))
  \end{clojure}
\end{english}

Очевидно, потомки узла~--- это его содержимое \code{:content}, дополнительно обёрнутое
в \code{seq}. У строки не может быть потомков, поэтому \code{(complement string?)}
означает: искать потомков в узлах, отличных от строки.

Рассмотрим, как бы мы нашли все товары из заданного XML. Для начала получим
ленивую итерацию по зипперу. Напомним, что на каждом шаге мы получим не словарь
с полями \code{:tag} и другими, а локацию с указателем на него. Останется
отфильтровать локации, чьи узлы содержат тег \code{product}. Для этого напишем
предикат:

\begin{english}
  \begin{clojure}
(defn loc-product? [loc]
  (-> loc zip/node :tag (= :product)))
  \end{clojure}
\end{english}

и выборку с преобразованием:

\begin{english}
  \begin{clojure}
(->> "products.xml"
     ->xml-zipper
     iter-zip
     (filter loc-product?)
     (map loc->product))

;; ("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro")
  \end{clojure}
\end{english}

На первый взгляд здесь ничего особенного. Структура XML известна заранее,
поэтому можно обойтись без зиппера. Для этого выберем потомков каталога и
получим организации; из потомков организаций получим товары. Вместе получится
простой код:

\begin{english}
  \begin{clojure}
(def xml-data
  (-> "products.xml"
      io/resource
      io/file
      xml/parse))

(def orgs
  (:content xml-data))

(def products
  (mapcat :content orgs))

(def product-names
  (mapcat :content products))
  \end{clojure}
\end{english}

Для краткости уберем переменные и сведем код к одной форме:

\begin{english}
  \begin{clojure}
(->> "products.xml"
     io/resource
     io/file
     xml/parse
     :content
     (mapcat :content)
     (mapcat :content))

;; ("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro")
  \end{clojure}
\end{english}

На практике структура XML неоднородна. Предположим, крупный поставщик разбивает
товары по филиалам. В его случае XML выглядит так (фрагмент):

\begin{english}
  \begin{xml}
<organization name="DNS">
  <branch name="Office 1">
    <product type="tablet">iPad 3</product>
    <product type="notebook">Macbook Pro</product>
  </branch>
  <branch name="Office 2">
    <product type="tablet">iPad 4</product>
    <product type="phone">Samsung A6+</product>
  </branch>
</organization>
  \end{xml}
\end{english}

Код выше, где мы слепо выбираем данные по уровню, сработает неверно. В списке
товаров окажется филиал:

\begin{english}
  \begin{clojure}
("iPhone 11 Pro"
 "iPhone SE"
 {:tag :product, :attrs {:type "tablet"}, :content ["iPad 3"]} ...)
  \end{clojure}
\end{english}

В то время как зиппер вернёт \textbf{только} товары, в том числе из филиала:

\begin{english}
  \begin{clojure}
(->> "products-branch.xml"
     ->xml-zipper
     iter-zip
     (filter loc-product?)
     (map loc->product))

("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro" "iPad 4" "Samsung A6+")
  \end{clojure}
\end{english}

Очевидно, выгодно пользоваться кодом, который работает с обоими XML, а не
поддерживать отдельную версию для крупного поставщика. В противном случае нужно
где-то хранить признак и делать по нему \code{if/else}, что усложнит проект.

Однако и этот пример не раскрывает всю мощь зипперов. Для обхода XML служит
функция \code{xml-seq} из главного модуля Clojure. Она возвращает ленивую цепочку
XML-узлов в том же виде (словарь с ключами \code{:tag}, \code{:attr} и
\code{:content}). \code{Xml-seq}~--- это частный случай более абстрактной функции
\code{tree-seq}. Последняя похожа на зиппер тем, что принимает функции \code{branch?} и
\code{children}, чтобы определить, подходит ли узел на роль ветки и как извлечь
потомков. Определение \code{xml-seq} напоминает \code{xml-zip}:

\begin{english}
  \begin{clojure}
(defn xml-seq
  [root]
  (tree-seq
    (complement string?)
    (comp seq :content)
    root))
  \end{clojure}
\end{english}

Разница между зиппером и \code{tree-seq} в том, что при итерации зиппер возвращает
локацию~--- элемент, который несёт больше сведений. Кроме данных он содержит
ссылки на элементы по всем четырем направлениям. Наоборот, \code{tree-seq} итерирует
данные без обёрток. Для обычного поиска \code{tree-seq} даже предпочтительней,
поскольку не порождает лишних абстракций. Вот как выглядит сбор товаров с учётом
филиалов:

\begin{english}
  \begin{clojure}
(defn node-product? [node]
  (some-> node :tag (= :product)))

(->> "products-branch.xml"
     io/resource
     io/file
     xml/parse
     xml-seq
     (filter node-product?)
     (mapcat :content))

("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro" "iPad 4" "Samsung A6+")
  \end{clojure}
\end{english}

Чтобы показать мощь зипперов, подберём такую задачу, где возможностей \code{tree-seq}
не хватает. На эту роль подойдёт поиск с переходом между локациями.

\section{Поиск в XML}

Предположим, нам поставили задачу: выбрать из XML магазины, где продаются
айфоны. Обратите внимание: мы впервые коснулись связи между узлами, и это
важно. По отдельности выбрать данные легко. Магазины~--- это локации, у которых
тег \code{organization}. Айфоны~--- локации, в которых узел с тегом \code{product} и
атрибутом \code{type="tablet"}. Но как найти связь между ними?

В прошлый раз мы разложили XML в последовательность с помощью
\code{xml-seq}. Проблема в том, что функция порождает коллекцию узлов без какой-либо
связи, что не даёт нам решить задачу. Покажем это на примере. Для начала получим
цепочку узлов:

\begin{english}
  \begin{clojure}
(def xml-nodes
  (->> "products-branch.xml"
     io/resource
     io/file
     xml/parse
     xml-seq))
  \end{clojure}
\end{english}

Вообразим, что в одном из элементов находится нужный товар. Например, мы
встретим айфон в третьем (втором от нуля) узле:

\begin{english}
  \begin{clojure}
(-> xml-nodes (nth 2))
;; {:tag :product :attrs {:type "iphone"} :content ["iPhone 11 Pro"]}
  \end{clojure}
\end{english}

Однако трудно найти магазин, которому он принадлежит. Можно догадаться, что
магазин находится слева от товара, потому что предшествует ему в обходе
дерева. Это станет ясно, если напечатать теги узлов:

\begin{english}
  \begin{clojure}
(->> xml-nodes (mapv :tag) (remove nil?) (run! print))
;; :catalog :organization :product :product :organization ...
  \end{clojure}
\end{english}

Идея верная, но в целом слабая, потому что зависит от порядка обхода. Кроме
того, задача усложняется: при обходе нужно не просто выбрать нужные товары, но и
переместиться назад в поисках магазина. Затем продолжить вперед и при этом
пропустить найденный товар, чтобы не попасть в вечный цикл. Схема подразумевает
состояние и хорошо смотрелась бы на императивных языках, но не в Clojure.

Здесь и приходит на помощь зиппер. Локация, которую он возвращает на каждом
шаге, помнит положение в структуре. От локации можно пройти в нужное место с
помощью функций \code{zip/up}, \code{zip/right} и других, что мы рассмотрели в первой
части. Это тот случай, когда ручная навигация оправдана.

Вернемся к XML со структурой <<каталог~--- организация~--- товары>>. Освежим его в
памяти:

\begin{english}
  \begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
  <organization name="re-Store">
    <product type="iphone">iPhone 11 Pro</product>
    <product type="iphone">iPhone SE</product>
  </organization>
  <organization name="DNS">
    <product type="tablet">iPad 3</product>
    <product type="notebook">Macbook Pro</product>
  </organization>
</catalog>
  \end{xml}
\end{english}

Прежде всего найдём локации-айфоны. Напишем предикат на айфон:

\begin{english}
  \begin{clojure}
(defn loc-iphone? [loc]
  (let [node (zip/node loc)]
    (and (-> node :tag (= :product))
         (-> node :attrs :type (= "iphone")))))
  \end{clojure}
\end{english}

Получим локации с айфонами:

\begin{english}
  \begin{clojure}
(def loc-iphones
  (->> "products.xml"
       ->xml-zipper
       iter-zip
       (filter loc-iphone?)))

(count loc-iphones)
2
  \end{clojure}
\end{english}

Теперь, чтобы найти организацию по товару, поднимемся на уровень выше с помощью
\code{zip/up}. Это верно, потому что организация~--- родитель товара:

\begin{english}
  \begin{clojure}
(def loc-orgs
  (->> loc-iphones
       (map zip/up)
       (map (comp :attrs zip/node))))

({:name "re-Store"} {:name "re-Store"})
  \end{clojure}
\end{english}

Для каждого айфона мы получим организацию, где его продают. Получились дубли,
потому что оба айфона продаются в re-Store. Чтобы избавиться от повторов,
оберните результат в \code{set}.

\begin{english}
  \begin{clojure}
(set loc-orgs)
#{{:name "re-Store"}}
  \end{clojure}
\end{english}

Это и есть ответ на вопрос: айфоны можно купить в магазине re-Store. Если
добавить айфон в организацию DNS, она тоже появится в \code{loc-orgs}.

Решим ту же задачу для XML с филиалами. Мы не можем вызвать \code{zip/up} для товара,
чтобы получить организацию, потому что в некоторых случаях получим филиал, и
понадобится еще один шаг вверх. Чтобы не гадать, сколько раз подниматься,
напишем функцию \code{loc->org}. Она вызывает \code{zip/ах} до тех пор, пока не выйдет на
нужный тег:

\begin{english}
  \begin{clojure}
(defn loc-org? [loc]
  (-> loc zip/node :tag (= :organization)))

(defn loc->org [loc]
  (->> loc
       (iterate zip/up)
       (find-first loc-org?)))
  \end{clojure}
\end{english}

Функция \code{find-first} находит первый элемент коллекции, который подошёл
предикату. Она ещё не раз пригодится нам.

\begin{english}
  \begin{clojure}
(defn find-first [pred coll]
  (some (fn [x]
          (when (pred x)
            x))
        coll))
  \end{clojure}
\end{english}

Чтобы сократить код, не будем объявлять переменные \code{loc-iphones} и
другие. Выразим поиск одной формой:

\begin{english}
  \begin{clojure}
(->> "products-branch.xml"
     ->xml-zipper
     iter-zip
     (filter loc-iphone?)
     (map loc->org)
     (map (comp :attrs zip/node))
     (set))
  \end{clojure}
\end{english}

Новое решение отличается лишь тем, что мы заменили \code{zip/up} на функцию с более
сложным восхождением. В остальном ничего не изменилось.

Обратите внимание, насколько удобен XML в плане поиска и навигации. Если бы мы
хранили данные в JSON, их структура и обход сильно бы отличались. Сравните
товары без филиалов:

\begin{english}
  \begin{json}
[{"name": "re-Store",
  "products": [{"type": "iphone", "name": "iPhone 11 Pro"},
               {"type": "iphone", "name": "iPhone SE"}]},
 {"name": "DNS",
  "products": [{"type": "tablet", "name": "iPad 3"},
               {"type": "notebook", "name": "Macbook Pro"}]}]
  \end{json}
\end{english}

и с ними:

\begin{english}
  \begin{json}
[{"name": "re-Store",
  "products": [{"type": "iphone", "name": "iPhone 11 Pro"},
               {"type": "iphone", "name": "iPhone SE"}]},
 {"name": "DNS",
  "branches": [{"name": "Office 1",
                "products": [{"type": "tablet", "name": "iPad 3"},
                             {"type": "notebook", "name": "Macbook Pro"}]},
               {"name": "Office 2",
                "products": [{"type": "tablet", "name": "iPad 3"},
                             {"type": "notebook", "name": "Macbook Pro"}]}]}]
  \end{json}
\end{english}

Очевидно, для работы с этими данными нужен разный код. В случае с XML его
структура однородна: добавление филиала меняет лишь глубину товаров, но не
правило обхода.

Усложним задачу: среди обычных товаров встречаются наборы из них (bundle). Товар
из набора нельзя купить отдельно. Например, тряпочка для протирки экрана
продаётся чаще всего с устройством. Нас просят найти магазин, где тряпочку можно
купить отдельно.

Пример XML с наборами:

\begin{english}
  \begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
  <organization name="re-Store">
    <product type="fiber">VIP Fiber Plus</product>
    <product type="iphone">iPhone 11 Pro</product>
  </organization>
  <organization name="DNS">
    <branch name="Office 2">
      <bundle>
        <product type="fiber">Premium iFiber</product>
        <product type="iphone">iPhone 11 Pro</product>
      </bundle>
    </branch>
  </organization>
</catalog>
  \end{xml}
\end{english}

Сначала найдём все тряпочки. В них окажутся как отдельные товары, так и из
набора:

\begin{english}
  \begin{clojure}
(defn loc-fiber? [loc]
  (some-> loc zip/node :attrs :type (= "fiber")))

(->> "products-bundle.xml"
     ->xml-zipper
     iter-zip
     (filter loc-fiber?)
     (map (comp first :content zip/node)))

("VIP Fiber Plus" "Premium iFiber")
  \end{clojure}
\end{english}

Теперь решим задачу. Из найденных тряпочек отсекаем те, что входят в набор. С
точки зрения зиппера это значит, что у родителя этой локации тег не равен
\code{:bundle}. От оставшихся тряпочек переходим к магазинам.

Введём предикат \code{loc-in-bundle?}~--- входит ли локация в набор или нет:

\begin{english}
  \begin{clojure}
(defn loc-in-bundle? [loc]
  (some-> loc zip/up zip/node :tag (= :bundle)))
  \end{clojure}
\end{english}

Решение:

\begin{english}
  \begin{clojure}
(->> "products-bundle.xml"
     ->xml-zipper
     iter-zip
     (filter loc-fiber?)
     (remove loc-in-bundle?)
     (map loc->org)
     (map (comp :attrs zip/node))
     (set))

#{{:name "re-Store"}}
  \end{clojure}
\end{english}

Магазин DNS не попал в результат, потому что в нём тряпочка продаётся в наборе.

Новое усложнение: мы хотим купить айфон, \emph{но только в наборе} с тряпочкой. В
какой магазин направить покупателя?

Решение: сначала ищем все айфоны. Оставляем те, что входят в набор. Среди
соседей айфона ищем тряпочку. Если нашли, переходим от айфона или тряпочки к
магазину. Основные функции уже готовы: это предикаты на проверку набора, тип
товара и другие мелочи. Но мы не рассмотрели, как получить соседей локации.

Функции \code{zip/lefts} и \code{zip/rights} вернут узлы по левую и правую стороны от
текущей локации. Совместим их через \code{concat}, чтобы получить всех соседей:

\begin{english}
  \begin{clojure}
(defn node-neighbors [loc]
  (concat (zip/lefts loc)
          (zip/rights loc)))
  \end{clojure}
\end{english}

Уточним, что это будут именно узлы, а не локации. Покажем это на примере
вектора:

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/right
    node-neighbors)

;; (1 3)
  \end{clojure}
\end{english}

Зиппер устроен так, что получить правые и левые узлы проще, чем передвигать
локацию влево или вправо. Поэтому при поиске соседей выгодно работать с узлами
(данными), а не локациями.

Добавим функции, чтобы проверить, если в соседях локации тряпочка:

\begin{english}
  \begin{clojure}
(defn node-fiber? [node]
  (some-> node :attrs :type (= "fiber")))

(defn with-fiber? [loc]
  (let [nodes (node-neighbors loc)]
    (find-first node-fiber? nodes)))
  \end{clojure}
\end{english}

Финальное выражение:

\begin{english}
  \begin{clojure}
(->> "products-bundle.xml"
     ->xml-zipper
     iter-zip
     (filter loc-iphone?)
     (filter loc-in-bundle?)
     (filter with-fiber?)
     (map loc->org)
     (map (comp :name :attrs zip/node))
     (set))

;; #{"DNS"}
  \end{clojure}
\end{english}

В результате получим магазин DNS, потому что именно в нём айфон продается в
комплекте с тряпкой. Оба этих товара продаются и в re-Store, но по отдельности,
что не подходит. Если заменить в наборе тряпочку на гарнитуру, мы не получим ни
один магазин.

Можно добавить больше ограничений. Например, из найденных магазинов выбрать те,
что расположены в радиусе 300 метров от покупателя. Для этого понадобится
расположение магазинов на карте и функция попадания точки в окружность. Можно
выбрать только открытые магазины или те, что предлагают доставку. Запишем эти
признаки в атрибуты организаций и добавим функции отбора.

Легко увидеть, что XML-зиппер стал настоящей базой данных. Он даёт ответы на
сложные запросы, и при этом код растет медленней, чем их смысловая
нагрузка. Из-за рекурсивной структуры XML хорошо поддается обходу, и зипперы
усиливают это преимущество. Обратите внимание, как удобно работают переходы и
связи между узлами. Представьте, каких усилий стоило бы разбить данные на
таблицы и строить SQL-запросы со многими JOIN.

Конечно, по сравнению с настоящей базой у XML недостаток~--- в нём нет индексов, и
поиск работает линейным перебором, а не как в бинарных деревьях. Кроме того, наш
подход требует, чтобы все находились в памяти целиком. Он не сработает для очень
больших документов с миллионами записей, но пока что не будем волноваться об
этом.

\section{Редактирование}

До сих пор мы игнорировали другую возможность зипперов. Во время обхода можно не
только читать, но и менять локации. В широком плане нам доступны все операции
CRUD (Create, Read, Update, Delete), знакомые из веб-разработки. Ниже мы
разберем, как они работают в зипперах.

Напомним, зиппер принимает третью функцию \code{make-node}, в которую до сих пор мы
передавали \code{nil}. В ней не было нужды, потому что мы только читали
данные. Зиппер вызовет функцию в момент, когда мы просим вернуть данные с учётом
изменений, которые внесли в локации. Функция принимает два параметра: ветку и
потомков. Ее задача~--- соединить их должным образом.

Для простых коллекций вроде вектора функция проста~--- нужно только обернуть
потомков в \code{vec}, чтобы получить из последовательности вектор. В \code{vector-zip}
функция чуть сложнее, потому что учитывает метаданные. Приведём код этого
зиппера без сокращений:

\begin{english}
  \begin{clojure}
(defn vector-zip
  [root]
  (zipper vector?
          seq
          (fn [node children]
            (with-meta (vec children) (meta node)))
          root))
  \end{clojure}
\end{english}

Видим, что новый вектор (форма \code{(vec children)}) копирует метаданные прежнего
вектора (переменная \code{node}). Если вы дополняете оригинал через \code{assoc} или
\code{conj}, метаданные сохраняются. В случае с \code{vector-zip} мы строим новый вектор,
поэтому оборачиваем его в \code{with-meta}. Если убрать \code{with-meta}, на выходе
получим вектор без метаданных, что может повлиять на логику программы.

У XML-зиппера сборка иная: потомков помещают в поле \code{:content}.

\begin{english}
  \begin{clojure}
(fn [node children]
  (assoc node :content (and children (apply vector children))))
  \end{clojure}
\end{english}

Для нашего \code{map-zip}, который работает со словарями, функция сборки выглядела бы
как \code{assoc} или \code{into} с набором пар \code{MapEntry}.

Зиппер неявно вызывает эту функцию, если находит изменённые узлы. Для изменения
служат функции \code{zip/edit}, \code{zip/replace} и другие. Но перед тем, как рассмотреть
их, объясним, как именно протекают изменения в зиппере.

Особенность в том, что изменения сказываются не на исходных данных, а на
локациях. Если изменить текущую локацию, она помечается флагом \code{:changed?}. Это
сигнал к пересборке данных с помощью функции \code{zip/root}, о которой скажем чуть
позже.

Рассмотрим пример с вектором \code{[1 2 3]}. Переместимся на двойку и удвоим её с
помощью функции \code{zip/edit}. Она принимает локацию, функцию и остаточные
аргументы~--- подход, знакомый вам из атомов (\code{swap!}) и коллекций (\code{update}). По
аналогии с ними, локация получит новое значение, которое вернула функция на базе
прежнего.

Локация до изменений:

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/right)

[2 {:l [1] :pnodes [[1 2 3]] :ppath nil :r (3)}]
  \end{clojure}
\end{english}

и после. Обратите внимание ключ \code{:changed?}:

\begin{english}
  \begin{clojure}
(def loc-2
  (-> [1 2 3]
      zip/vector-zip
      zip/down
      zip/right
      (zip/edit * 2)))

[4 {:l [1] :pnodes [[1 2 3]] :ppath nil :r (3)
    :changed? true}]
  \end{clojure}
\end{english}

Далее нам бы хотелось получить изменённый вектор \code{[1 4 3]}. Сделаем это вручную:

\begin{english}
  \begin{clojure}
(-> loc-2
    zip/up
    zip/node)
;; [1 4 3]
  \end{clojure}
\end{english}

То же самое делает функция \code{zip/root}, которая принимает локацию с
изменениями. Её алгоритм следующий:

- подняться до первичной локации, повторно вызывая \code{zip/up};
- вернуть узел.

Чтобы получить результат за один проход, добавим \code{zip/root} на конец стрелочного
оператора:

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/right
    (zip/edit * 2)
    zip/root)
;; [1 4 3]
  \end{clojure}
\end{english}

Основная работа происходит в функции \code{zip/up}, которую мы вызвали вручную или
неявно в \code{zip/root}. При подъёме вверх она проверяет, была ли изменена локация,
и если да, перестраивает её с помощью \code{make-node}. Приведём её код в сокращении:

\begin{english}
  \begin{clojure}
(defn up
  [loc]
  (let [[node {... changed? :changed? :as path}] loc]
    (when pnodes
      (let [pnode (peek pnodes)]
        (with-meta (if changed?
                     [(make-node loc pnode (concat l ...))
                      (and ppath (assoc ...))]
                     [pnode ppath])
                   (meta loc))))))
  \end{clojure}
\end{english}

\subsection{Множественное изменение}

При изменении одной локации проблем не возникает. Однако мы редко изменяем одну
локацию~--- на практике это делают по признаку, то есть пакетно.

Ранее мы раскладывали зиппер в цепочку локаций с помощью \code{iter-zip}, а затем
пропускали через серию \code{map}, \code{filter} и других функций. Для редактирования этот
метод не подходит. Предположим, мы выбрали второй элемент из результата
\code{zip-iter} и исправили его:

\begin{english}
  \begin{clojure}
(def loc-seq
  (-> [1 2 3]
      zip/vector-zip
      iter-zip))

(-> loc-seq (nth 2) (zip/edit * 2))
;; [4 {:l [1] :pnodes [[1 2 3]] :ppath nil :r (3)
;;    :changed? true}]
  \end{clojure}
\end{english}

Функция \code{zip-iter} устроена так, что каждая следующая локация получается из
предыдущей. Вызов \code{zip/edit} на одном из элементов не повлияет на
последующие. Если подняться вверх от последней локации, получим вектор без
изменений.

\begin{english}
  \begin{clojure}
(-> loc-seq last zip/up zip/node)
;; [1 2 3]
  \end{clojure}
\end{english}

Как видно из примера, выражение с \code{zip/edit} не повлияло на результат.

При редактировании зипперов применяют следующие паттерны.

\textbf{Изменяется один элемент.} В этом случае мы итерируем зиппер до тех пор, пока
не встретим нужную локацию в цепочке. Затем меняем её и вызываем \code{zip/root}.

\textbf{Изменяются многие элементы.} С помощью \code{loop} и \code{zip/next} мы вручную
итерируем зиппер. При этом задана функция, которая либо меняет локацию, любо
оставляет нетронутой. В форму \code{recur} попадает \code{zip/next} от её результата. Если
изменения были, \code{zip/next} оттолкнётся от новой, а не исходной локации.

Для изменения локаций служат функции:

\begin{itemize}

\item
  \code{zip/replace}~--- буквальная замена текущего узла на другой.

\item
  \code{zip/edit}~--- Редактирование узла. По аналогии с \code{update} и \code{swap!} принимает
  функцию и добавочные аргументы. Первым аргументом функция получит текущей
  узел. Результат заменит содержимое локации.

\item
  \code{zip/remove}~--- Удаляет локацию и перемещает указатель на родителя.

\end{itemize}

Функции для вставки соседей и потомков:

\begin{itemize}

\item
  \code{zip/insert-left}~--- добавить соседа слева от текущей локации;

\item
  \code{zip/insert-right}~--- добавить соседа справа;

\item
  \code{zip/insert-child}~--- добавить текущей локации потомка в начало;

\item
  \code{zip/append-child}~--- добавить потомка в конец.

\end{itemize}

Разница между соседом и потомком в иерархии. Сосед находится на одном уровне с
локацией, а потомок ниже. В центре диаграммы находится локация с вектором \code{[2
3]}. Её соседи~--- числа 1 и 4, а потомки~--- 2 и 3.

%% TODO
%% {: .asciichart}
%% \begin{english}
%%  \begin{
%%}
%%                 ┌─────────────┐
%%                 │ [1 [2 3] 4] │
%%                 └─────────────┘
%%                        ▲
%%                        │
%%     ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
%%     │   1   │◀───┃   [2 3]   ┃───▶│   4   │
%%     └───────┘    ┗━━━━━━━━━━━┛    └───────┘
%%                        │
%%                  ┌─────┴─────┐
%%                  ▼           ▼
%%              ┌───────┐   ┌───────┐
%%              │   2   │   │   3   │
%%              └───────┘   └───────┘
%%   \end{
%%}
%% \end{english}

Рассмотрим функции на простых примерах. Предположим, в глубине вложенных
векторов находится ключ \code{:error}, и нужно исправить его на \code{:ok}. Сперва добавим
предикат для поиска:

\begin{english}
  \begin{clojure}
(defn loc-error? [loc]
  (some-> loc zip/node (= :error)))
  \end{clojure}
\end{english}

Теперь ищем локацию, исправляем её и поднимаемся к корню:

\begin{english}
  \begin{clojure}
(def data [1 2 [3 4 [5 :error]]])

(def loc-error
  (->> data
       zip/vector-zip
       iter-zip
       (find-first loc-error?)))

(-> loc-error
    (zip/replace :ok)
    zip/root)

;; [1 2 [3 4 [5 :ok]]]
  \end{clojure}
\end{english}

Другой пример~--- поменять во вложеном векторе все \code{nil} на 0, чтобы обезопасить
математические расчеты. На этот раз локация может быть не одна, поэтому
понадобится обход через \code{loop}. На каждом шаге мы проверяем, подходит ли
локация, и если да, передаём в \code{recur} вызов \code{zip/next} от изменённой версии:

\begin{english}
  \begin{clojure}
(def data [1 2 [5 nil 2 [3 nil]] nil 1])

(loop [loc (zip/vector-zip data)]
  (if (zip/end? loc)
    (zip/node loc)
    (if (-> loc zip/node nil?)
      (recur (zip/next (zip/replace loc 0)))
      (recur (zip/next loc)))))

;; [1 2 [5 0 2 [3 0]] 0 1]
  \end{clojure}
\end{english}

То же самое, но заменить все отрицательные числа по модулю. Для начала объявим
функцию \code{abs} (с версии 1.11 она встроена в Clojure):

\begin{english}
  \begin{clojure}
(defn abs [num]
  (if (neg? num)
    (- num)
    num))
  \end{clojure}
\end{english}

Обход похож на предыдущий, но теперь вместо \code{zip/replace} мы вызываем
\code{zip/edit}, который обновляет содержимое локации, отталкиваясь от прежнего
значения:

\begin{english}
  \begin{clojure}
(def data [-1 2 [5 -2 2 [-3 2]] -1 5])

(loop [loc (zip/vector-zip data)]
  (if (zip/end? loc)
    (zip/node loc)
    (if (and (-> loc zip/node number?)
             (-> loc zip/node neg?))
      (recur (zip/next (zip/edit loc abs)))
      (recur (zip/next loc)))))
  \end{clojure}
\end{english}

В обоих случаях цикл выглядит одинаково. Если это конечная локация, вернём её
узел. В противном случае, если локация подходит предикату, меняем ее содержимое
с помощью \code{zip/edit}. От изменённой локации переходим к следующей. Это ключевой
момент: в предпоследней строке вызов \code{zip/next} принимает результат \code{zip/edit},
а не исходную локацию. Поэтому изменения будут переданы в следующий шаг \code{loop}.

Примеры выше образуют паттерны~--- повторяющиеся приёмы. Поместим их в отдельные
функции, чтобы не тратить на них внимание в будущем.

\textbf{Поиск локации по предикату.} Принимает начальную локацию и предикат, начинает
итерацию. Вернёт первую же локацию, которая подошла предикату:

\begin{english}
  \begin{clojure}
(defn find-loc [loc loc-pred]
  (->> loc
       iter-zip
       (find-first loc-pred)))
  \end{clojure}
\end{english}

\textbf{Обход локаций с изменениями.} Перебирает локации с помощью \code{zip/next} и
\code{loop/recur}. При переходе на следующий шаг оборачивает локацию в
функцию. Ожидается, что функция либо изменит локацию, либо вернёт её без
изменений. Это обобщённая версия цикла, что мы написали выше.

\begin{english}
  \begin{clojure}
(defn alter-loc [loc loc-fn]
  (loop [loc loc]
    (if (zip/end? loc)
      loc
      (-> loc loc-fn zip/next recur))))
  \end{clojure}
\end{english}

Перепишем примеры с новыми функциями. Найдём в векторе локацию, чей узел равен
двойке:

\begin{english}
  \begin{clojure}
(defn loc-2? [loc]
  (-> loc zip/node (= 2)))

(def loc-2
  (-> [1 2 3]
      zip/vector-zip
      (find-loc loc-2?)))
  \end{clojure}
\end{english}

Удвоим её и выйдем на конечный вектор:

\begin{english}
  \begin{clojure}
(-> loc-2 (zip/edit * 2) zip/root)
;; [1 4 2]
  \end{clojure}
\end{english}

Изменим отрицательные числа по модулю. Для этого заведём функцию \code{loc-abs}. Если
в узле отрицательное число, вернём исправленную локацию, а иначе~--- исходную:

\begin{english}
  \begin{clojure}
(defn loc-abs [loc]
  (if (and (-> loc zip/node number?)
           (-> loc zip/node neg?))
    (zip/edit loc abs)
    loc))
  \end{clojure}
\end{english}

Осталось передать её в \code{alter-loc}:

\begin{english}
  \begin{clojure}
(-> [-1 2 [5 -2 2 [-3 2]] -1 5]
    zip/vector-zip
    (alter-loc loc-abs)
    zip/node)

;; [1 2 [5 2 2 [3 2]] 1 5]
  \end{clojure}
\end{english}

Как только мы вынесли часть кода в функции, преобразования стали короче и
понятней. Как правило, любое действие над зиппером можно обобщить и поместить в
функцию, тем самым упростив логику.

\subsection{Цены в XML}

Перейдём к практическим примерам с XML и товарами. Подготовим следующий файл
\code{products-price.xml}:

\begin{english}
  \begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
  <organization name="re-Store">
    <product type="fiber" price="8.99">VIP Fiber Plus</product>
    <product type="iphone" price="899.99">iPhone 11 Pro</product>
  </organization>
  <organization name="DNS">
    <branch name="Office 2">
      <bundle>
        <product type="fiber" price="9.99">Premium iFiber</product>
        <product type="iphone" price="999.99">iPhone 11 Pro</product>
      </bundle>
    </branch>
  </organization>
</catalog>
  \end{xml}
\end{english}

Обратите внимание, что у товаров появились цены~--- характеристика, которая часто
меняется.

Напомним, что с точки зрения Clojure XML~--- это вложенные словари с ключами
\code{:tag}, \code{:attrs} и \code{:content}. После изменений мы бы хотели видеть его в
привычном, текстовом виде. Понадобится обратное действие~--- из структуры данных
получить XML в виде текста. Для этого импортируем модуль \code{clojure.xml}. Его
функция \code{emit} выводит XML на печать.

Часто \code{emit} оборачивают в \code{with-out-str}~--- макрос для перехвата печати в
строку. В примерах ниже мы просто выводим XML в консоль. \code{Emit} не поддерживает
отступы, поэтому мы добавили их вручную для ясности.

\textbf{Первая задача}~--- сделать скидку 10\% на все айфоны. У нас готовы почти все
абстракции, так что опишем решение сверху вниз:

\begin{english}
  \begin{clojure}
(require '[clojure.xml :as xml])

(-> "products-price.xml"
    ->xml-zipper
    (alter-loc alter-iphone-price)
    zip/node
    xml/emit)
  \end{clojure}
\end{english}

Этих пяти строк достаточно для нашей задачи. Под вопросом только функция
\code{alter-iphone-price}. Ожидается, что для локации-айфона она вернёт её же, но с
другим атрибутом \code{price}. Локация другого типа останется без изменений. Опишем
функцию:

\begin{english}
  \begin{clojure}
(defn alter-iphone-price [loc]
  (if (loc-iphone? loc)
    (zip/edit loc alter-attr-price 0.9)
    loc))
  \end{clojure}
\end{english}

Предикат \code{loc-iphone?} проверяет локацию на "айфонность". Мы уже писали его в
прошлом разделе:

\begin{english}
  \begin{clojure}
(defn loc-iphone? [loc]
  (let [node (zip/node loc)]
    (and (-> node :tag (= :product))
         (-> node :attrs :type (= "iphone")))))
  \end{clojure}
\end{english}

Осталась функция \code{alter-attr-price}. Она принимает узел (содержимое локации) и
должна изменить его атрибут \code{:price}. Второй аргумент функции~--- коэффициент, на
который нужно умножить текущую цену. Небольшая трудность в том, что атрибуты в
XML~--- строки. Чтобы выполнить умножение, нужно вывести число из строки, умножить
на коэффициент, а результат привести в строку с округлением до двух цифр. Все
вместе даёт нам функцию:

\begin{english}
  \begin{clojure}
(defn alter-attr-price [node ratio]
  (update-in node [:attrs :price]
             (fn [price]
               (->> price
                    read-string
                    (* ratio)
                    (format "%.2f")))))
  \end{clojure}
\end{english}

Быстрая проверка этой функции:

\begin{english}
  \begin{clojure}
(alter-attr-price {:attrs {:price "10"}} 1.1)
;; {:attrs {:price "11.00"}}
  \end{clojure}
\end{english}

Теперь когда известны все компоненты, запустим первое выражение и получим XML:

\begin{english}
  \begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
  <organization name="re-Store">
    <product price="8.99" type="fiber">VIP Fiber Plus</product>
    <product price="809.99" type="iphone">iPhone 11 Pro</product>
  </organization>
  <organization name="DNS">
    <branch name="Office 2">
      <bundle>
        <product price="9.99" type="fiber">Premium iFiber</product>
        <product price="899.99" type="iphone">iPhone 11 Pro</product>
      </bundle>
    </branch>
  </organization>
</catalog>
  \end{xml}
\end{english}

Видим, что цена на айфоны изменилась на 10%, а у остальных товаров осталась
прежней.

\textbf{Более сложная задача}~--- во все наборы (бандлы) добавить новый товар~---
гарнитуру. Опять же, опишем решение сверху вниз:

\begin{english}
  \begin{clojure}
(-> "products-price.xml"
    ->xml-zipper
    (alter-loc add-to-bundle)
    zip/node
    xml/emit)
  \end{clojure}
\end{english}

Решение отличается только функций \code{add-to-bundle}. Её логика следующая: если
текущая локация~--- набор, добавить ему потомка, а если нет, просто вернуть
локацию.

\begin{english}
  \begin{clojure}
(defn add-to-bundle [loc]
  (if (loc-bundle? loc)
    (zip/append-child loc node-headset)
    loc))
  \end{clojure}
\end{english}

Проверка на набор:

\begin{english}
  \begin{clojure}
(defn loc-bundle? [loc]
  (some-> loc zip/node :tag (= :bundle)))
  \end{clojure}
\end{english}

Функция \code{zip/append-child} добавляет значение в конец потомков локации. В данном
случае это узел \code{node-headset}, который вынесли в константу:

\begin{english}
  \begin{clojure}
(def node-headset
  {:tag :product
   :attrs {:type "headset"
           :price "199.99"}
   :content ["AirPods Pro"]})
  \end{clojure}
\end{english}

Итоговый XML, где в наборах появился новый товар:

\begin{english}
  \begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
  <organization name="re-Store">
    <product price="8.99" type="fiber">VIP Fiber Plus</product>
    <product price="899.99" type="iphone">iPhone 11 Pro</product>
  </organization>
  <organization name="DNS">
    <branch name="Office 2">
      <bundle>
        <product price="9.99" type="fiber">Premium iFiber</product>
        <product price="999.99" type="iphone">iPhone 11 Pro</product>
        <product price="199.99" type="headset">AirPods Pro</product>
      </bundle>
    </branch>
  </organization>
</catalog>
  \end{xml}
\end{english}

\textbf{Третья задача}~--- упразднить все наборы. Возможно, руководство решило, что
продавать товары в наборах невыгодно. Что ж, бывает. Для программиста это
значит, что из XML уходят все теги \code{<bundle>}, однако их товары должны перейти в
организацию.

И в третий раз решение отличается лишь целевой функцией:

\begin{english}
  \begin{clojure}
(-> "products-price.xml"
    ->xml-zipper
    (alter-loc disband-bundle)
    zip/node
    xml/emit)
  \end{clojure}
\end{english}

Опишем алгоритм \code{disband-bundle}. Если текущий узел~--- набор, сохраним его
потомков (товары) в переменную, чтобы не потерять их. Затем удалим
набор. Функция удаления вернёт предка локации, в нашем случае
организацию. Присоединим к ней товары и вернем её.

\begin{english}
  \begin{clojure}
(defn disband-bundle [loc]
  (if (loc-bundle? loc)
    (let [products (zip/children loc)
          loc-org (zip/remove loc)]
      (append-childs loc-org products))
    loc))
  \end{clojure}
\end{english}

Функция \code{append-childs}~--- это обёртка над встроенной
\code{zip/append-child}. Последняя присоединяет только один элемент, что
неудобно. Чтобы присоединить их список, напишем свёртку:

\begin{english}
  \begin{clojure}
(defn append-childs [loc items]
  (reduce (fn [loc item]
            (zip/append-child loc item))
          loc
          items))
  \end{clojure}
\end{english}

Финальный XML без наборов, но с теми же товарами:

\begin{english}
  \begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
  <organization name="re-Store">
    <product price="8.99" type="fiber">VIP Fiber Plus</product>
    <product price="899.99" type="iphone">iPhone 11 Pro</product>
  </organization>
  <organization name="DNS">
    <branch name="Office 2">
      <product price="9.99" type="fiber">Premium iFiber</product>
      <product price="999.99" type="iphone">iPhone 11 Pro</product>
    </branch>
  </organization>
</catalog>
  \end{xml}
\end{english}

Надеемся, этих примеров достаточно, чтобы читатель понял, как редактировать
зипперы. Обратите внимание, что кода получилось немного: для каждой задачи мы
писали в среднем три функции. Другое преимущество в том, что нет состояния. Все
функции чистые, и их вызов не сказывается на данных. Если на середине выскочит
исключение, дерево XML не будет частично изменённым.
