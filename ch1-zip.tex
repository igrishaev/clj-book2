\chapter{Зипперы}

\begin{teaser}
В этой главе мы рассмотрим зипперы в языке Clojure. Это необычный способ работы
с коллекциями. С помощью зиппера можно обойти произвольные данные, изменить их и
выполнить поиск. Зиппер~--- мощный инструмент, и вложения в него окупаются со
временем. Вместе с тем это довольно сложная абстракция, которая требует
подготовки.
\end{teaser}

\section{Азы навигации}

Объясним зиппер простыми словами. Это обёртка над данными с набором
действий. Вот некоторые из них:

\begin{itemize}

\item
  перемещение по вертикали: вниз к потомкам или вверх к родителю;

\item
  перемещение по горизонтали: влево или вправо среди потомков;

\item
обход всех элементов;

\item
добавление, редактирование и удаление узлов.

\end{itemize}

Это неполный список того, на что способны зипперы. Другие их свойства мы
рассмотрим по ходу главы. Важно, что указанные действия относятся к любым
данным, будь то комбинация векторов и словарей, дерево узлов или XML. Из-за
этого зипперы становятся мощным инструментом. Разобраться с ними означает
повысить свои навыки и открыть новые двери.

\def\huet{https://en.wikipedia.org/wiki/Gerard\_Huet}
\def\huetzipper{https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf}

Термин <<зиппер>> ввел французкий ученый \footurl{Жерар Юэ}{\huet}[G\'{e}rard Huet]
(G\'{e}rard Huet) в 1996 году. Юэ занимался деревьями и искал универсальный
способ работы с ними. В знаменитой работе \footurl{<<Functional Pearl: The Zipper>>}{\huetzipper}[The Zipper]
Юэ привел концепцию зиппера на языке OCaml. Документ
привлек внимание простотой и ясностью: описание зиппера, включая код и
комментарии, уместились на четырех страницах. Современные зипперы почти не
отличаются от того изложения 1996 года.

Хотя Юэ отмечает, что зиппер можно создать на любом языке, лучше всего они
прижились в функциональных: Haskell, OCaml, Clojure. Зипперы поощряют
неизменяемые данные и чистые преобразования. Для упомянутых языков написаны
библиотеки зипперов, и разработчики хотя бы поверхностно знакомы с
ними. Наоборот, в императивной среде зипперы почти неизвестны.

Зипперы доступны в Clojure с первой версии. Их легко добавить в проект, не
опасаясь проблем лицензии или новых зависимостей.

Зипперы в Clojure используют мощь неизменяемых коллекций. Технически зиппер~---
это коллекция, которая хранит данные и позицию в них. Всё вместе это называется
локацией (location). Шаг в любую сторону вернёт новую локацию подобно тому, как
функции \code{assoc} или \code{update} производят новые данные из прежних.

Из текущей локации можно получить \emph{узел} (ноду)~--- данные, на которые ссылается
указатель. На этом моменте путаются новички, поэтому уточним различие. Локация~---
это исходные данные и положение в них. Передвижение по локации порождает
локацию. Из локации можно извлечь узел~--- данные, которые встретились на этом
участке.

Приведём пример с вектором \code{[1 2 3]}. Чтобы переместиться на \textbf{двойку}, обернем
данные в зиппер и выполним команды \code{zip/down} и \code{zip/right}. С первым шагом мы
провалимся в вектор и окажемся на единице. Шаг вправо сдвинет нас на
двойку. Выразим это в коде: подключим модуль \code{clojure.zip} и переместимся по
вектору:

\begin{english}
  \begin{clojure}
(require '[clojure.zip :as zip])

(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/right
    zip/node)
;; 2
  \end{clojure}
\end{english}

Функция \code{zip/vector-zip} зиппер из вектора. Вызовы \code{zip/down} и
\code{zip/right} передвинут указатель на двойку, как и ожидалось. Последний шаг
\code{zip/node} вернет значение (узел) из текущей локации. Если убрать \code{zip/node},
получим локацию, которая соответствует двойке. Вот как она выглядит:

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/right)

;; [2 {:l [1], :pnodes [[1 2 3]], :ppath nil, :r (3)}]
  \end{clojure}
\end{english}

Наверняка у вас возникли вопросы: откуда мы знаем путь к двойке, ведь она могла
быть в другом месте вектора? Что произойдет, если выйти за пределы коллекции?
Мы ответим на эти вопросы ниже. Пока что, если вам что-то непонятно, не впадайте
в панику: мы не раз обсудим всё, что происходит.

Итак, зиппер предлагает перемещение по данным. Несмотря на всю мощь, он не
знает, как делать это для конкретной коллекции, и нуждается в вашей помощи. Вот
что нужно знать зипперу:

\begin{itemize}

\item
  Является ли текущий элемент веткой или нет? Веткой называют элемент, из
  которого можно извлечь другие элементы.

\item
  Если это ветка, как именно получить её элементы?

\end{itemize}

Как только мы знаем ответы на эти вопросы, зиппер готов. Заметим, что для
изменения зиппера нужен ответ на третий вопрос~--- как присоединить потомков к
ветке. Однако сейчас мы рассматриваем только навигацию, и третий вопрос
подождет.

В техническом плане ответы на эти вопросы~--- функции. Первая принимает узел и
возвращает истину или ложь. Если получили истину, зиппер вызовет вторую функцию
с тем же узлом. От нее ожидают коллекцию дочерних узлов или \code{nil}, если их
нет. В терминах зиппера функции называют \code{branch?} и \code{children}
соответственно.

Чтобы получить зиппер, сообщите ему данные и эти две функции. Посколько мы
только читаем зиппер, третья функция будет \code{nil}.

\def\urlclojurezip{https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj}

Зипперы находятся в модуле \code{clojure.zip}. В свободное время исследуйте его код:
он занимает всего \footurl{280 строк}{\urlclojurezip}[zip.clj]!

\begin{english}
  \begin{clojure}
(ns my.project
  (:require [clojure.zip :as zip]))
  \end{clojure}
\end{english}

Функция \code{zip/zipper} порождает зиппер из исходных данных и функций. Это
центральная точка модуля, его строительный материал. Для особых случаев модуль
содержит вспомогательные функции, которые ожидают только данные. Примером служит
функция \code{vector-zip}. Она работает с вектором, элементы которого могут быть
вложенным вектором и так далее. Приведём ее код в сокращении:

\begin{english}
  \begin{clojure}
(defn vector-zip
  [root]
  (zipper vector?
          seq
          ...
          root))
  \end{clojure}
\end{english}

Третий параметр мы заменили на многоточие. Это функция, которая присоединяет к
ветке дочерные узлы при изменении (пока что обходим вопрос стороной).

Если передать в \code{vector-zip} данные \code{[1 2 3]}, произойдёт
следующее. Зиппер обернёт вектор и выставит на него указатель. Из начального
положения можно следовать только вниз, потому что у вершины нет родителя (вверх)
и соседей (влево и вправо). При смещении \textbf{вниз} зиппер сначала проверит,
что текущий узел~--- ветка. Сработает выражение \code{(vector? [1 2 3])}, что
вернёт истину. В этом случае зиппер выполнит \code{(seq [1 2 3])}, чтобы
получить потомков. Ими станет последовательность \code{(1 2 3)}. Как только
потомки найдены, зиппер установит указатель на крайний левый потомок~---
единицу.

Покажем это на схеме. Начальная позиция, указатель на исходном векторе:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-01}
  \caption{Начальная позиция}
  \label{fig:chart-zip-01}
\end{figure}

Шаг вниз, указатель на единице:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-02}
  \caption{Результат смещения вниз}
  \label{fig:chart-zip-02}
\end{figure}

Шаг вправо, указатель на двойке:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-03}
  \caption{Перемещение вправо}
  \label{fig:chart-zip-03}
\end{figure}

Итак, мы находимся на двойке и можем двигаться дальше по горизонтали. Шаг вправо
сдвинет нас на тройку, влево~--- на единицу. Вот как это выглядит в коде:

\begin{english}
  \begin{clojure}
(def loc2
  (-> [1 2 3]
      zip/vector-zip
      zip/down
      zip/right))

(-> loc2 zip/node)
;; 2

(-> loc2 zip/right zip/node)
;; 3

(-> loc2 zip/left zip/node)
;; 1
  \end{clojure}
\end{english}

При попытке сдвинуться вниз зиппер выполнит предикат \code{(vector? 2)}. Результат
будет ложью, что означает, что текущий элемент не ветка, и движение вниз
запрещено.

Во время движения каждый шаг порождает новую локацию, не изменяя старую. Если вы
сохранили очередную локацию в переменную, дальнейшие вызовы \code{zip/right} или
\code{zip/down} не изменят её. Выше мы объявили переменную \code{loc2}, которая
указывает на двойку. Проследуем от нее к исходному вектору:

\begin{english}
  \begin{clojure}
(-> loc2 zip/up zip/node)
;; [1 2 3]
  \end{clojure}
\end{english}

При ручном перемещении велики шансы выйти за пределы данных. Шаг в никуда вернёт
\code{nil} вместо локации:

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/left)
nil
  \end{clojure}
\end{english}

Это сигнал, что вы идёте по неверному пути. Из \code{nil} нельзя вернуться на
прежнее место, потому что у \code{nil} нет сведений о позиции. Для \code{nil}
функции \code{zip/up}, \code{zip/right} и другие тоже вернут \code{nil}. Если не
учесть это в цикле, вы будете топтаться на месте.

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/left
    zip/left
    zip/left
    ...)

;; nil
  \end{clojure}
\end{english}

К исключению относится функция \code{zip/down}: при попытке спуститься из \code{nil} вы
получите \code{NullPointerException}. Это недочёт, который, возможно, когда-нибудь
исправят.

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/left
    zip/down)

;; Execution error (NullPointerException)...
  \end{clojure}
\end{english}

Рассмотрим случай, когда у вектора вложенные элементы: \code{[1 [2 3] 4]}. Чтобы
переместиться на \textbf{тройку}, выполним шаги <<вниз>>, <<вправо>>, <<вниз>>,
<<вправо>>. Сохраним локацию в переменную \code{loc3}:

\begin{english}
  \begin{clojure}
(def loc3
  (-> [1 [2 3] 4]
      zip/vector-zip
      zip/down
      zip/right
      zip/down
      zip/right))

(zip/node loc3)
3
  \end{clojure}
\end{english}

Рисунки ниже показывают, что происходит на каждом шаге. Исходная позиция:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-04}
  \caption{Исходная позиция}
  \label{fig:chart-zip-04}
\end{figure}

Шаг вниз:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-05}
  \caption{Шаг вниз}
  \label{fig:chart-zip-05}
\end{figure}

Вправо:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-06}
  \caption{Шаг вправо}
  \label{fig:chart-zip-06}
\end{figure}

Вниз:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-07}
  \caption{Шаг вниз}
  \label{fig:chart-zip-07}
\end{figure}

Вправо. Мы у цели:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-08}
  \caption{Шаг вправо}
  \label{fig:chart-zip-08}
\end{figure}

Чтобы перейти на \textbf{четвёрку} из текущей позиции, сначала поднимемся
вверх. Указатель сдвинется на вектор \code{[2 3]}. Мы находимся среди потомков
исходного вектора и можем перемещаться по горизонтали. Сделаем шаг вправо и
окажемся на цифре 4.

То же самое графически. Текущая локация (тройка):

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-09}
  \caption{Текущая локация}
  \label{fig:chart-zip-09}
\end{figure}

Шаг вверх:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-10}
  \caption{Шаг вверх}
  \label{fig:chart-zip-10}
\end{figure}

Шаг вправо:

\begin{figure}[ht!]
  \centering
  \chart{chart-zip-11}
  \caption{Шаг вправо}
  \label{fig:chart-zip-11}
\end{figure}

Исходный вектор может быть любой вложенности. Ради интереса замените тройку на
\code{[5 [6 [7 [8] 9]]]} и проследуйте до девятки.

Что случится, если передать в \code{vector-zip} что-то отличное от вектора?
Предположим, \code{nil}, строку или число. Перед тем, как двигаться, зиппер проверит,
подходит ли узел на роль ветки. Сработает функция \code{vector?}, которая вернет
\code{nil} для всех отличных от вектора значений. В результате получим локацию, из
которой нельзя никуда шагнуть: ни вниз, ни в стороны. Это тупиковый случай, и
его нужно избегать.

\begin{english}
  \begin{clojure}
(-> "test"
    zip/vector-zip
    zip/down)
nil
  \end{clojure}
\end{english}

Модуль \code{clojure.zip} предлагает и другие встроенные зипперы. Особенно интересен
\code{xml-zip} для навигации по XML-дереву. Мы обсудим его отдельно, когда читатель
познакомится с другими свойствами зипперов.

\section{Автонавигация}

Мы разобрались с тем, как перемещаться по коллекции. Однако у читателя возникнет
вопрос: как мы узнаем заранее, куда двигаться? Откуда приходит путь?

Ответ покажется странным, но все же: ручная навигация по данным лишена всякого
смысла. Если путь известен заранее, вам не нужен зиппер~--- это лишнее
усложнение.

Clojure предлагает более простую работу с данными, структура которых
известна. Например, если мы точно знаем, что на вход поступил вектор, второй
элемент которого вектор, и нужно взять его второй элемент, воспользуемся
\code{get-in}:

\begin{english}
  \begin{clojure}
(def data [1 [2 3] 4])

(get-in data [1 1])
;; 3
  \end{clojure}
\end{english}

То же самое касается других типов данных. Неважно, какую какую комбинацию
образуют списки и словари: если структура известна заранее, до элемента легко
добраться с помощью \code{get-in} или стрелочного оператора. В данном случае зипперы
только усложнят код.

\begin{english}
  \begin{clojure}
(def data {:users [{:name "Ivan"}]})

(-> data :users first :name)
;; "Ivan"
  \end{clojure}
\end{english}

В чем же тогда преимущество зипперов? Свои сильные стороны они проявляют там,
где \code{get-in} не работает. Речь о данных с \textbf{неизвестной} структурой. Представьте,
что на вход поступил произвольный вектор, и нужно найти в нём строку. Она может
быть как на поверхности вектора, так и вложена на три уровня. В этом случае
\code{get-in} не поможет, потому что мы не знаем путь. Другой пример~---
XML-документ. Нужный тег может располагаться где угодно, и нужно как-то его
найти. Таким образом, идеальный случай для зиппера~--- нечёткая структура данных,
о которой у нас только предположения.

Функции \code{zip/up}, \code{zip/down} и другие образуют универсальную \code{zip/next}. Эта
функция передвигает указатель так, что рано или поздно мы обойдем всю
структуру. При обходе исключены повторы: мы побываем в каждом месте только
раз. Пример с вектором:

\begin{english}
  \begin{clojure}
(def vzip (zip/vector-zip [1 [2 3] 4]))

(-> vzip zip/node)
;; [1 [2 3] 4]

(-> vzip zip/next zip/node)
;; 1

(-> vzip zip/next zip/next zip/node)
;; [2 3]

(-> vzip zip/next zip/next zip/next zip/node)
;; 2
  \end{clojure}
\end{english}

Очевидно, мы не знаем, сколько раз вызывать \code{zip/next}, поэтому пойдём на
хитрость. Функция \code{iterate} принимает функцию \code{f} и значение \code{x}. Результатом
станет последовательность, где первый элемент \code{x}, а каждый следующий~--- \code{f(x)}
от предыдущего. Для зиппера мы получим исходную локацию, затем \code{zip/next} от
неё, затем \code{zip/next} от прошлого шага и так далее.

Переменная \code{loc-seq} ниже~--- это цепочка локаций исходного зиппера. Чтобы
получить узлы, мы берём шесть первых элементов (число взяли случайно) и вызываем
для каждого \code{zip/node}.

\begin{english}
  \begin{clojure}
(def loc-seq (iterate zip/next vzip))

(->> loc-seq
     (take 6)
     (map zip/node))

;; ([1 [2 3] 4]
;;   1
;;   [2 3]
;;   2
;;   3
;;   4)
  \end{clojure}
\end{english}

\code{Iterate} порождает \textbf{ленивую} и \textbf{бесконечную} последовательность. Обе
характеристики важны. Ленивость означает, что очередной сдвиг (вызов \code{zip/next})
не произойдёт до тех пор, пока вы не дойдёте до элемента в
цепочке. Бесконечность означает, что \code{zip/next} вызывается неограниченное число
раз. Понадобится признак, по которому мы остановим вызов \code{zip/next}, иначе поток
локаций никогда не закончится.

Если исследовать \code{loc-seq}, станет ясно, что в какой-то момент \code{zip/next} уже не
сдвигает указатель. Возьмём наугад сотый и тысячный элементы итерации. Их узел
будет исходным вектором:

\begin{english}
  \begin{clojure}
(-> loc-seq (nth 100) zip/node)
;; [1 [2 3] 4]

(-> loc-seq (nth 1000) zip/node)
;; [1 [2 3] 4]

  \end{clojure}
\end{english}

Причина кроется в устройстве зиппера. Функция \code{zip/next} работает по принципу
кольца. Когда она достигает исходной локации, цикл завершается. При этом локация
получит признак завершения, и дальнейший вызов \code{zip/next} вернёт её
же. Проверить признак можно функцией \code{zip/end?}:

\begin{english}
  \begin{clojure}
(def loc-end
  (-> [1 2 3]
      zip/vector-zip
      zip/next
      zip/next
      zip/next
      zip/next))

loc-end
;; [[1 2 3] :end]

(zip/end? loc-end)
;; true

  \end{clojure}
\end{english}

Чтобы получить конечную цепь локаций, будем сдвигать указатель до тех пор, пока
локация не последняя. Всё вместе даёт функцию \code{iter-zip}:

\begin{english}
  \begin{clojure}
(defn iter-zip [zipper]
  (->> zipper
       (iterate zip/next)
       (take-while (complement zip/end?))))
  \end{clojure}
\end{english}

Функция вернёт все локации от начальной до конечной не включая ее. Напомним, что
локация хранит узел (элемент данных), который можно извлечь с помощью
\code{zip/node}. Код ниже показывает, как превратить локации в данные:

\begin{english}
  \begin{clojure}
(->> [1 [2 3] 4]
     zip/vector-zip
     iter-zip
     (map zip/node))

;; ([1 [2 3] 4]
;;  1
;;  [2 3]
;;  2
;;  3
;;  4)
  \end{clojure}
\end{english}

Теперь когда мы получили цепочку локаций, напишем поиск. Предположим, нужно
проверить, есть ли в векторе кейворд \code{:error}. Сначала напишем предикат для
локации~--- равен ли её узел этому значению:

\begin{english}
  \begin{clojure}
(defn loc-error? [loc]
  (-> loc zip/node (= :error)))
  \end{clojure}
\end{english}

Проверим, если ли среди локаций та, что подходит нашему предикату.  Для этого
вызовем \code{some}:

\begin{english}
  \begin{clojure}
(def data [1 [2 3 [:test [:foo :error]]] 4])

(some loc-error?
      (-> data zip/vector-zip iter-zip))

;; true
  \end{clojure}
\end{english}

Из-за ленивости мы не сканируем вектор целиком. Если нужный узел нашелся на
середине, \code{iter-zip} прекращает итерацию, и дальнейшие вызовы \code{zip/next} не
произойдут.

Полезно знать, что \code{zip/next} обходит дерево в глубину. При движении он
стремится вниз и вправо, а наверх поднимается лишь когда шаги в эти стороны
невозможны. Как мы увидим дальше, в некоторых случаях порядок обхода
важен. Попадаются задачи, где мы должны двигаться вширь. По умолчанию в
\code{clojure.zip} нет других вариантов обхода, но мы напишем собственный. Также мы
рассмотрим задачу, где понадобится обход вширь.

Встроенный зиппер \code{vector-zip} служит для вложенных векторов. Но гораздо чаще
встречаются вложенные словари. Напишем зиппер для обхода подобных данных:

\begin{english}
  \begin{clojure}
(def map-data
  {:foo 1
   :bar 2
   :baz {:test "hello"
         :word {:nested true}}})
  \end{clojure}
\end{english}

За основу возьмём знакомый нам \code{vector-zip}. Зипперы похожи, разница лишь в типе
коллекции. Подумаем, как задать функции \code{branch?} и \code{children}. Сам по себе
словарь~--- это ветка, чью потомки~--- элементы \code{MapEntry}. Тип \code{MapEntry} выражает
пару ключа и значения. Если значение~--- словарь, получим из него цепочку
вложенных \code{MapEntry} и так далее.

Для разминки напишем проверку на тип \code{MapEntry}:

\begin{english}
  \begin{clojure}
(def entry?
  (partial instance? clojure.lang.MapEntry))
  \end{clojure}
\end{english}

Зиппер \code{map-zip} выглядит так:

\begin{english}
  \begin{clojure}
(defn map-zip [mapping]
  (zip/zipper
   (some-fn entry? map?)
   (fn [x]
     (cond
       (map? x)
       (seq x)
       (and (entry? x) (-> x val map?))
       (-> x val seq)))
   nil
   mapping))
  \end{clojure}
\end{english}

Поясним основные моменты. Композиция \code{(some-fn ...)} вернёт истину, если хотя бы
один из предикатов сработает положительно. Иными словами, на роль ветки мы
рассматриваем только словарь или его узел (пару ключ-значение).

Во второй функции, которая ищет потомков, приходится делать перебор. Для словаря
(проверка \code{map?}) получим потомков функцией \code{seq}~--- она вернёт цепочку
элементов \code{MapEntry}. Если текущий элемент~--- \code{MapEntry}, проверим, является ли
его значение вложенным словарём (функция \code{var} вернет второй элемент
\code{MapEntry}). Если да, получим потомков той же функцией \code{seq}.

Обход зиппера вернет все пары ключей и значений. Если значение~--- вложенный
словарь, мы провалимся в него при обходе. Пример:

\begin{english}
  \begin{clojure}
(->> {:foo 42
      :bar {:baz 11
            :user/name "Ivan"}}
     map-zip
     iter-zip
     rest
     (map zip/node))

;; ([:foo 42]
;;  [:bar {:baz 11, :user/name "Ivan"}]
;;  [:baz 11]
;;  [:user/name "Ivan"])
  \end{clojure}
\end{english}

Обратите внимание на функцию \code{rest} после \code{iter-zip}. Мы отбросили первую
локацию, в которой находятся исходные данные. Поскольку они известны, нет смысла
печатать их.

С помощью нашего \code{map-zip} легко проверить, есть ли в словаре ключ \code{:error} со
значением \code{:auth}. По отдельности эти кейворды могут быть где угодно~--- и в
ключах, и в значениях на любом уровне. Однако нас интересует их комбинация. Для
этого напишем предикат:

\begin{english}
  \begin{clojure}
(defn loc-err-auth? [loc]
  (-> loc zip/node (= [:error :auth])))
  \end{clojure}
\end{english}

Убедимся, что в первом словаре нет пары, даже не смотря на то, что значения
встречаются по отдельности:

\begin{english}
  \begin{clojure}
(->> {:response {:error :expired
                 :auth :failed}}
     map-zip
     iter-zip
     (some loc-err-auth?))

;; nil
  \end{clojure}
\end{english}

Но даже если пара вложена глубоко, мы найдём её:

\begin{english}
  \begin{clojure}
(def data
  {:response {:info {:message "Auth error"
                     :error :auth
                     :code 1005}}})

(->> data
     map-zip
     iter-zip
     (some loc-err-auth?))

;; true
  \end{clojure}
\end{english}

Предлагаем читателю несколько заданий для самостоятельной работы.

\begin{enumerate}

\item
  Зиппер \code{map-zip} не учитывает случай, когда ключ словаря~--- другой словарь,
  например:

\begin{english}
  \begin{clojure}
{{:alg "MD5" :salt "..."} "deprecated"
 {:alg "SHA2" :salt "..."} "deprecated"
 {:alg "HMAC-SHA256" :key "..."} "ok"}
  \end{clojure}
\end{english}

Такие коллекции хоть и редко, но встречаются в практике. Доработайте \code{map-zip},
чтобы он проверял не только значение \code{MapEntry}, но и ключ (вместо \code{val}
используйте \code{key}).

\item
  Мы рассмотрели зипперы для векторов и словарей по отдельности. На практике мы
  работаем со смешанными данными, когда словари и векторы вложены друг в
  друга. Напишите универсальный зиппер, который учитывает обе коллекции при
  обходе.

\end{enumerate}

\section{XML-зипперы}

Мощь зипперов раскрывается в полной мере при работе с XML. От других форматов он
отличается тем, что задан рекурсивно. Например, JSON, YAML и другие форматы
предлагают типы~--- числа, строки, коллекции,~--- у которых разный синтаксис и
структура. В XML, где бы мы ни находились, текущий узел состоит из трёх
элементов: тега, атрибутов и содержимого.

Тег~--- это короткое имя узла, например \code{name} или \code{description}. Атрибуты~---
словарь свойств и их значений. Наиболее интересно содержимое: это набор строк
или других узлов. Вот как выглядит XML на псевдокоде:

\begin{english}
  \begin{text}
XML = [Tag, Attrs, [String|XML]]
  \end{text}
\end{english}

Чтобы убедиться в однородности XML, рассмотрим файл с товарами поставщиков:

\begin{english}
  \begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
  <organization name="re-Store">
    <product type="iphone">iPhone 11 Pro</product>
    <product type="iphone">iPhone SE</product>
  </organization>
  <organization name="DNS">
    <product type="tablet">iPad 3</product>
    <product type="notebook">Macbook Pro</product>
  </organization>
</catalog>
  \end{xml}
\end{english}

На вершине XML находится узел \code{catalog}. Это группировочный тег: он необходим,
потому что на вершине не может быть несколько тегов. Потомки каталога~---
организации. В атрибуте \code{name} организации указано её имя. Под организацией идут
товары~--- узлы с тегом \code{product} и атрибутом \code{type}. Вместо потомков товар
содержит текст~--- подробное описание. Ниже него спуститься уже нельзя.

Clojure предлагает XML-парсер, который вернет структуру, похожую на схему
\code{[Tag, Attrs, Content]} выше. Каждый узел станет словарем с ключами
\code{:tag}, \code{:attrs} и \code{:content}. Последний хранит вектор, где
элемент либо строка, либо вложенный словарь.

Поместим XML с товарами в файл \code{resources/products.xml}. Напишем функцию, чтобы
считать файл в XML-зиппер. Добавьте модули \code{xml} и \code{io}:

\begin{english}
  \begin{clojure}
(:require
 [clojure.java.io :as io]
 [clojure.xml :as xml])
  \end{clojure}
\end{english}

Оба входят в поставку Clojure и не требуют зависимостей. Чтобы получить зиппер,
пропустим параметр \code{path} через серию функций:

\begin{english}
  \begin{clojure}
(defn ->xml-zipper [path]
  (-> path
      io/resource
      io/file
      xml/parse
      zip/xml-zip))
  \end{clojure}
\end{english}

Функция \code{xml/parse} вернёт структуру словарей с ключами \code{:tag}, \code{:attrs} и
\code{:content}. Обратите внимание, что текстовое содержимое, например, название
товара, это тоже вектор с одной строкой. Тем самым достигается однородность
каждого узла.

Вот что получим после вызова \code{xml/parse}:

\begin{english}
  \begin{clojure}
{:tag :catalog
 :attrs nil
 :content
 [{:tag :organization
   :attrs {:name "re-Store"}
   :content
   [{:tag :product
     :attrs {:type "iphone"}
     :content ["iPhone 11 Pro"]}
    {:tag :product :attrs {:type "iphone"} :content ["iPhone SE"]}]}
  {:tag :organization
   :attrs {:name "DNS"}
   :content
   [{:tag :product :attrs {:type "tablet"} :content ["iPad 3"]}
    {:tag :product
     :attrs {:type "notebook"}
     :content ["Macbook Pro"]}]}]}
  \end{clojure}
\end{english}

Вызов \code{(->xml-zipper "products.xml")} вернет первую локацию зиппера XML. Прежде
чем работать с ним, заглянем в определение \code{xml-zip}, чтобы понять, что
происходит. Приведём код из \code{clojure.zip} в сокращении:

\begin{english}
  \begin{clojure}
(defn xml-zip
  [root]
  (zipper (complement string?)
          (comp seq :content)
          ...
          root))
  \end{clojure}
\end{english}

Очевидно, потомки узла~--- это его содержимое \code{:content}, дополнительно обёрнутое
в \code{seq}. У строки не может быть потомков, поэтому \code{(complement string?)}
означает: искать потомков в узлах, отличных от строки.

Рассмотрим, как бы мы нашли все товары из заданного XML. Для начала получим
ленивую итерацию по зипперу. Напомним, что на каждом шаге мы получим не словарь
с полями \code{:tag} и другими, а локацию с указателем на него. Останется
отфильтровать локации, чьи узлы содержат тег \code{product}. Для этого напишем
предикат:

\begin{english}
  \begin{clojure}
(defn loc-product? [loc]
  (-> loc zip/node :tag (= :product)))
  \end{clojure}
\end{english}

и выборку с преобразованием:

\begin{english}
  \begin{clojure}
(->> "products.xml"
     ->xml-zipper
     iter-zip
     (filter loc-product?)
     (map loc->product))

;; ("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro")
  \end{clojure}
\end{english}

На первый взгляд здесь ничего особенного. Структура XML известна заранее,
поэтому можно обойтись без зиппера. Для этого выберем потомков каталога и
получим организации; из потомков организаций получим товары. Вместе получится
простой код:

\begin{english}
  \begin{clojure}
(def xml-data
  (-> "products.xml"
      io/resource
      io/file
      xml/parse))

(def orgs
  (:content xml-data))

(def products
  (mapcat :content orgs))

(def product-names
  (mapcat :content products))
  \end{clojure}
\end{english}

Для краткости уберем переменные и сведем код к одной форме:

\begin{english}
  \begin{clojure}
(->> "products.xml"
     io/resource
     io/file
     xml/parse
     :content
     (mapcat :content)
     (mapcat :content))

;; ("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro")
  \end{clojure}
\end{english}

На практике структура XML неоднородна. Предположим, крупный поставщик разбивает
товары по филиалам. В его случае XML выглядит так (фрагмент):

\begin{english}
  \begin{xml}
<organization name="DNS">
  <branch name="Office 1">
    <product type="tablet">iPad 3</product>
    <product type="notebook">Macbook Pro</product>
  </branch>
  <branch name="Office 2">
    <product type="tablet">iPad 4</product>
    <product type="phone">Samsung A6+</product>
  </branch>
</organization>
  \end{xml}
\end{english}

Код выше, где мы слепо выбираем данные по уровню, сработает неверно. В списке
товаров окажется филиал:

\begin{english}
  \begin{clojure}
("iPhone 11 Pro"
 "iPhone SE"
 {:tag :product, :attrs {:type "tablet"}, :content ["iPad 3"]} ...)
  \end{clojure}
\end{english}

В то время как зиппер вернёт \textbf{только} товары, в том числе из филиала:

\begin{english}
  \begin{clojure}
(->> "products-branch.xml"
     ->xml-zipper
     iter-zip
     (filter loc-product?)
     (map loc->product))

("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro" "iPad 4" "Samsung A6+")
  \end{clojure}
\end{english}

Очевидно, выгодно пользоваться кодом, который работает с обоими XML, а не
поддерживать отдельную версию для крупного поставщика. В противном случае нужно
где-то хранить признак и делать по нему \code{if/else}, что усложнит проект.

Однако и этот пример не раскрывает всю мощь зипперов. Для обхода XML служит
функция \code{xml-seq} из главного модуля Clojure. Она возвращает ленивую цепочку
XML-узлов в том же виде (словарь с ключами \code{:tag}, \code{:attr} и
\code{:content}). \code{Xml-seq}~--- это частный случай более абстрактной функции
\code{tree-seq}. Последняя похожа на зиппер тем, что принимает функции \code{branch?} и
\code{children}, чтобы определить, подходит ли узел на роль ветки и как извлечь
потомков. Определение \code{xml-seq} напоминает \code{xml-zip}:

\begin{english}
  \begin{clojure}
(defn xml-seq
  [root]
  (tree-seq
    (complement string?)
    (comp seq :content)
    root))
  \end{clojure}
\end{english}

Разница между зиппером и \code{tree-seq} в том, что при итерации зиппер возвращает
локацию~--- элемент, который несёт больше сведений. Кроме данных он содержит
ссылки на элементы по всем четырем направлениям. Наоборот, \code{tree-seq} итерирует
данные без обёрток. Для обычного поиска \code{tree-seq} даже предпочтительней,
поскольку не порождает лишних абстракций. Вот как выглядит сбор товаров с учётом
филиалов:

\begin{english}
  \begin{clojure}
(defn node-product? [node]
  (some-> node :tag (= :product)))

(->> "products-branch.xml"
     io/resource
     io/file
     xml/parse
     xml-seq
     (filter node-product?)
     (mapcat :content))

("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro" "iPad 4" "Samsung A6+")
  \end{clojure}
\end{english}

Чтобы показать мощь зипперов, подберём такую задачу, где возможностей \code{tree-seq}
не хватает. На эту роль подойдёт поиск с переходом между локациями.

\section{Поиск в XML}

Предположим, нам поставили задачу: выбрать из XML магазины, где продаются
айфоны. Обратите внимание: мы впервые коснулись связи между узлами, и это
важно. По отдельности выбрать данные легко. Магазины~--- это локации, у которых
тег \code{organization}. Айфоны~--- локации, в которых узел с тегом \code{product} и
атрибутом \code{type="tablet"}. Но как найти связь между ними?

В прошлый раз мы разложили XML в последовательность с помощью
\code{xml-seq}. Проблема в том, что функция порождает коллекцию узлов без какой-либо
связи, что не даёт нам решить задачу. Покажем это на примере. Для начала получим
цепочку узлов:

\begin{english}
  \begin{clojure}
(def xml-nodes
  (->> "products-branch.xml"
     io/resource
     io/file
     xml/parse
     xml-seq))
  \end{clojure}
\end{english}

Вообразим, что в одном из элементов находится нужный товар. Например, мы
встретим айфон в третьем (втором от нуля) узле:

\begin{english}
  \begin{clojure}
(-> xml-nodes (nth 2))
;; {:tag :product :attrs {:type "iphone"} :content ["iPhone 11 Pro"]}
  \end{clojure}
\end{english}

Однако трудно найти магазин, которому он принадлежит. Можно догадаться, что
магазин находится слева от товара, потому что предшествует ему в обходе
дерева. Это станет ясно, если напечатать теги узлов:

\begin{english}
  \begin{clojure}
(->> xml-nodes (mapv :tag) (remove nil?) (run! print))
;; :catalog :organization :product :product :organization ...
  \end{clojure}
\end{english}

Идея верная, но в целом слабая, потому что зависит от порядка обхода. Кроме
того, задача усложняется: при обходе нужно не просто выбрать нужные товары, но и
переместиться назад в поисках магазина. Затем продолжить вперед и при этом
пропустить найденный товар, чтобы не попасть в вечный цикл. Схема подразумевает
состояние и хорошо смотрелась бы на императивных языках, но не в Clojure.

Здесь и приходит на помощь зиппер. Локация, которую он возвращает на каждом
шаге, помнит положение в структуре. От локации можно пройти в нужное место с
помощью функций \code{zip/up}, \code{zip/right} и других, что мы рассмотрели в первой
части. Это тот случай, когда ручная навигация оправдана.

Вернемся к XML со структурой <<каталог~--- организация~--- товары>>. Освежим его в
памяти:

\begin{english}
  \begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
  <organization name="re-Store">
    <product type="iphone">iPhone 11 Pro</product>
    <product type="iphone">iPhone SE</product>
  </organization>
  <organization name="DNS">
    <product type="tablet">iPad 3</product>
    <product type="notebook">Macbook Pro</product>
  </organization>
</catalog>
  \end{xml}
\end{english}

Прежде всего найдём локации-айфоны. Напишем предикат на айфон:

\begin{english}
  \begin{clojure}
(defn loc-iphone? [loc]
  (let [node (zip/node loc)]
    (and (-> node :tag (= :product))
         (-> node :attrs :type (= "iphone")))))
  \end{clojure}
\end{english}

Получим локации с айфонами:

\begin{english}
  \begin{clojure}
(def loc-iphones
  (->> "products.xml"
       ->xml-zipper
       iter-zip
       (filter loc-iphone?)))

(count loc-iphones)
2
  \end{clojure}
\end{english}

Теперь, чтобы найти организацию по товару, поднимемся на уровень выше с помощью
\code{zip/up}. Это верно, потому что организация~--- родитель товара:

\begin{english}
  \begin{clojure}
(def loc-orgs
  (->> loc-iphones
       (map zip/up)
       (map (comp :attrs zip/node))))

({:name "re-Store"} {:name "re-Store"})
  \end{clojure}
\end{english}

Для каждого айфона мы получим организацию, где его продают. Получились дубли,
потому что оба айфона продаются в re-Store. Чтобы избавиться от повторов,
оберните результат в \code{set}.

\begin{english}
  \begin{clojure}
{% raw %}
(set loc-orgs)
#{{:name "re-Store"}}
{% endraw %}
  \end{clojure}
\end{english}

Это и есть ответ на вопрос: айфоны можно купить в магазине re-Store. Если
добавить айфон в организацию DNS, она тоже появится в \code{loc-orgs}.

Решим ту же задачу для XML с филиалами. Мы не можем вызвать \code{zip/up} для товара,
чтобы получить организацию, потому что в некоторых случаях получим филиал, и
понадобится еще один шаг вверх. Чтобы не гадать, сколько раз подниматься,
напишем функцию \code{loc->org}. Она вызывает \code{zip/ах} до тех пор, пока не выйдет на
нужный тег:

\begin{english}
  \begin{clojure}
(defn loc-org? [loc]
  (-> loc zip/node :tag (= :organization)))

(defn loc->org [loc]
  (->> loc
       (iterate zip/up)
       (find-first loc-org?)))
  \end{clojure}
\end{english}

Функция \code{find-first} находит первый элемент коллекции, который подошёл
предикату. Она ещё не раз пригодится нам.

\begin{english}
  \begin{clojure}
(defn find-first [pred coll]
  (some (fn [x]
          (when (pred x)
            x))
        coll))
  \end{clojure}
\end{english}

Чтобы сократить код, не будем объявлять переменные \code{loc-iphones} и
другие. Выразим поиск одной формой:

\begin{english}
  \begin{clojure}
(->> "products-branch.xml"
     ->xml-zipper
     iter-zip
     (filter loc-iphone?)
     (map loc->org)
     (map (comp :attrs zip/node))
     (set))
  \end{clojure}
\end{english}

Новое решение отличается лишь тем, что мы заменили \code{zip/up} на функцию с более
сложным восхождением. В остальном ничего не изменилось.

Обратите внимание, насколько удобен XML в плане поиска и навигации. Если бы мы
хранили данные в JSON, их структура и обход сильно бы отличались. Сравните
товары без филиалов:

\begin{english}
  \begin{json}
[{"name": "re-Store",
  "products": [{"type": "iphone", "name": "iPhone 11 Pro"},
               {"type": "iphone", "name": "iPhone SE"}]},
 {"name": "DNS",
  "products": [{"type": "tablet", "name": "iPad 3"},
               {"type": "notebook", "name": "Macbook Pro"}]}]
  \end{json}
\end{english}

и с ними:

\begin{english}
  \begin{json}
[{"name": "re-Store",
  "products": [{"type": "iphone", "name": "iPhone 11 Pro"},
               {"type": "iphone", "name": "iPhone SE"}]},
 {"name": "DNS",
  "branches": [{"name": "Office 1",
                "products": [{"type": "tablet", "name": "iPad 3"},
                             {"type": "notebook", "name": "Macbook Pro"}]},
               {"name": "Office 2",
                "products": [{"type": "tablet", "name": "iPad 3"},
                             {"type": "notebook", "name": "Macbook Pro"}]}]}]
  \end{json}
\end{english}

Очевидно, для работы с этими данными нужен разный код. В случае с XML его
структура однородна: добавление филиала меняет лишь глубину товаров, но не
правило обхода.

Усложним задачу: среди обычных товаров встречаются наборы из них (bundle). Товар
из набора нельзя купить отдельно. Например, тряпочка для протирки экрана
продаётся чаще всего с устройством. Нас просят найти магазин, где тряпочку можно
купить отдельно.

Пример XML с наборами:

\begin{english}
  \begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
  <organization name="re-Store">
    <product type="fiber">VIP Fiber Plus</product>
    <product type="iphone">iPhone 11 Pro</product>
  </organization>
  <organization name="DNS">
    <branch name="Office 2">
      <bundle>
        <product type="fiber">Premium iFiber</product>
        <product type="iphone">iPhone 11 Pro</product>
      </bundle>
    </branch>
  </organization>
</catalog>
  \end{xml}
\end{english}

Сначала найдём все тряпочки. В них окажутся как отдельные товары, так и из
набора:

\begin{english}
  \begin{clojure}
(defn loc-fiber? [loc]
  (some-> loc zip/node :attrs :type (= "fiber")))

(->> "products-bundle.xml"
     ->xml-zipper
     iter-zip
     (filter loc-fiber?)
     (map (comp first :content zip/node)))

("VIP Fiber Plus" "Premium iFiber")
  \end{clojure}
\end{english}

Теперь решим задачу. Из найденных тряпочек отсекаем те, что входят в набор. С
точки зрения зиппера это значит, что у родителя этой локации тег не равен
\code{:bundle}. От оставшихся тряпочек переходим к магазинам.

Введём предикат \code{loc-in-bundle?}~--- входит ли локация в набор или нет:

\begin{english}
  \begin{clojure}
(defn loc-in-bundle? [loc]
  (some-> loc zip/up zip/node :tag (= :bundle)))
  \end{clojure}
\end{english}

Решение:

\begin{english}
  \begin{clojure}
(->> "products-bundle.xml"
     ->xml-zipper
     iter-zip
     (filter loc-fiber?)
     (remove loc-in-bundle?)
     (map loc->org)
     (map (comp :attrs zip/node))
     (set))

#{{:name "re-Store"}}
  \end{clojure}
\end{english}

Магазин DNS не попал в результат, потому что в нём тряпочка продаётся в наборе.

Новое усложнение: мы хотим купить айфон, \emph{но только в наборе} с тряпочкой. В
какой магазин направить покупателя?

Решение: сначала ищем все айфоны. Оставляем те, что входят в набор. Среди
соседей айфона ищем тряпочку. Если нашли, переходим от айфона или тряпочки к
магазину. Основные функции уже готовы: это предикаты на проверку набора, тип
товара и другие мелочи. Но мы не рассмотрели, как получить соседей локации.

Функции \code{zip/lefts} и \code{zip/rights} вернут узлы по левую и правую стороны от
текущей локации. Совместим их через \code{concat}, чтобы получить всех соседей:

\begin{english}
  \begin{clojure}
(defn node-neighbors [loc]
  (concat (zip/lefts loc)
          (zip/rights loc)))
  \end{clojure}
\end{english}

Уточним, что это будут именно узлы, а не локации. Покажем это на примере
вектора:

\begin{english}
  \begin{clojure}
(-> [1 2 3]
    zip/vector-zip
    zip/down
    zip/right
    node-neighbors)

;; (1 3)
  \end{clojure}
\end{english}

Зиппер устроен так, что получить правые и левые узлы проще, чем передвигать
локацию влево или вправо. Поэтому при поиске соседей выгодно работать с узлами
(данными), а не локациями.

Добавим функции, чтобы проверить, если в соседях локации тряпочка:

\begin{english}
  \begin{clojure}
(defn node-fiber? [node]
  (some-> node :attrs :type (= "fiber")))

(defn with-fiber? [loc]
  (let [nodes (node-neighbors loc)]
    (find-first node-fiber? nodes)))
  \end{clojure}
\end{english}

Финальное выражение:

\begin{english}
  \begin{clojure}
(->> "products-bundle.xml"
     ->xml-zipper
     iter-zip
     (filter loc-iphone?)
     (filter loc-in-bundle?)
     (filter with-fiber?)
     (map loc->org)
     (map (comp :name :attrs zip/node))
     (set))

;; #{"DNS"}
  \end{clojure}
\end{english}

В результате получим магазин DNS, потому что именно в нём айфон продается в
комплекте с тряпкой. Оба этих товара продаются и в re-Store, но по отдельности,
что не подходит. Если заменить в наборе тряпочку на гарнитуру, мы не получим ни
один магазин.

Можно добавить больше ограничений. Например, из найденных магазинов выбрать те,
что расположены в радиусе 300 метров от покупателя. Для этого понадобится
расположение магазинов на карте и функция попадания точки в окружность. Можно
выбрать только открытые магазины или те, что предлагают доставку. Запишем эти
признаки в атрибуты организаций и добавим функции отбора.

Легко увидеть, что XML-зиппер стал настоящей базой данных. Он даёт ответы на
сложные запросы, и при этом код растет медленней, чем их смысловая
нагрузка. Из-за рекурсивной структуры XML хорошо поддается обходу, и зипперы
усиливают это преимущество. Обратите внимание, как удобно работают переходы и
связи между узлами. Представьте, каких усилий стоило бы разбить данные на
таблицы и строить SQL-запросы со многими JOIN.

Конечно, по сравнению с настоящей базой у XML недостаток~--- в нём нет индексов, и
поиск работает линейным перебором, а не как в бинарных деревьях. Кроме того, наш
подход требует, чтобы все находились в памяти целиком. Он не сработает для очень
больших документов с миллионами записей, но пока что не будем волноваться об
этом.
