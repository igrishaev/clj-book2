

%% \section{Редактирование}

%% До сих пор мы игнорировали другую возможность зипперов. Во время обхода можно не
%% только читать, но и менять локации. В широком плане нам доступны все операции
%% CRUD (Create, Read, Update, Delete), знакомые из веб-разработки. Ниже мы
%% разберем, как они работают в зипперах.

%% Напомним, зиппер принимает третью функцию `make-node`, в которую до сих пор мы
%% передавали `nil`. В ней не было нужды, потому что мы только читали
%% данные. Зиппер вызовет функцию в момент, когда мы просим вернуть данные с учётом
%% изменений, которые внесли в локации. Функция принимает два параметра: ветку и
%% потомков. Ее задача — соединить их должным образом.

%% <!-- more -->

%% Для простых коллекций вроде вектора функция проста — нужно только обернуть
%% потомков в `vec`, чтобы получить из последовательности вектор. В `vector-zip`
%% функция чуть сложнее, потому что учитывает метаданные. Приведём код этого
%% зиппера без сокращений:

%% ~~~clojure
%% (defn vector-zip
%%   [root]
%%   (zipper vector?
%%           seq
%%           (fn [node children]
%%             (with-meta (vec children) (meta node)))
%%           root))
%% ~~~

%% Видим, что новый вектор (форма `(vec children)`) копирует метаданные прежнего
%% вектора (переменная `node`). Если вы дополняете оригинал через `assoc` или
%% `conj`, метаданные сохраняются. В случае с `vector-zip` мы строим новый вектор,
%% поэтому оборачиваем его в `with-meta`. Если убрать `with-meta`, на выходе
%% получим вектор без метаданных, что может повлиять на логику программы.

%% У XML-зиппера сборка иная: потомков помещают в поле `:content`.

%% ~~~clojure
%% (fn [node children]
%%   (assoc node :content (and children (apply vector children))))
%% ~~~

%% Для нашего `map-zip`, который работает со словарями, функция сборки выглядела бы
%% как `assoc` или `into` с набором пар `MapEntry`.

%% Зиппер неявно вызывает эту функцию, если находит изменённые узлы. Для изменения
%% служат функции `zip/edit`, `zip/replace` и другие. Но перед тем, как рассмотреть
%% их, объясним, как именно протекают изменения в зиппере.

%% Особенность в том, что изменения сказываются не на исходных данных, а на
%% локациях. Если изменить текущую локацию, она помечается флагом `:changed?`. Это
%% сигнал к пересборке данных с помощью функции `zip/root`, о которой скажем чуть
%% позже.

%% Рассмотрим пример с вектором `[1 2 3]`. Переместимся на двойку и удвоим её с
%% помощью функции `zip/edit`. Она принимает локацию, функцию и остаточные
%% аргументы -- подход, знакомый вам из атомов (`swap!`) и коллекций (`update`). По
%% аналогии с ними, локация получит новое значение, которое вернула функция на базе
%% прежнего.

%% Локация до изменений:

%% ~~~clojure
%% (-> [1 2 3]
%%     zip/vector-zip
%%     zip/down
%%     zip/right)

%% [2 {:l [1] :pnodes [[1 2 3]] :ppath nil :r (3)}]
%% ~~~

%% и после. Обратите внимание ключ `:changed?`:

%% ~~~clojure
%% (def loc-2
%%   (-> [1 2 3]
%%       zip/vector-zip
%%       zip/down
%%       zip/right
%%       (zip/edit * 2)))

%% [4 {:l [1] :pnodes [[1 2 3]] :ppath nil :r (3)
%%     :changed? true}]
%% ~~~

%% Далее нам бы хотелось получить изменённый вектор `[1 4 3]`. Сделаем это вручную:

%% ~~~clojure
%% (-> loc-2
%%     zip/up
%%     zip/node)
%% ;; [1 4 3]
%% ~~~

%% То же самое делает функция `zip/root`, которая принимает локацию с
%% изменениями. Её алгоритм следующий:

%% - подняться до первичной локации, повторно вызывая `zip/up`;
%% - вернуть узел.

%% Чтобы получить результат за один проход, добавим `zip/root` на конец стрелочного
%% оператора:

%% ~~~clojure
%% (-> [1 2 3]
%%     zip/vector-zip
%%     zip/down
%%     zip/right
%%     (zip/edit * 2)
%%     zip/root)
%% ;; [1 4 3]
%% ~~~

%% Основная работа происходит в функции `zip/up`, которую мы вызвали вручную или
%% неявно в `zip/root`. При подъёме вверх она проверяет, была ли изменена локация,
%% и если да, перестраивает её с помощью `make-node`. Приведём её код в сокращении:

%% ~~~clojure
%% (defn up
%%   [loc]
%%   (let [[node {... changed? :changed? :as path}] loc]
%%     (when pnodes
%%       (let [pnode (peek pnodes)]
%%         (with-meta (if changed?
%%                      [(make-node loc pnode (concat l ...))
%%                       (and ppath (assoc ...))]
%%                      [pnode ppath])
%%                    (meta loc))))))
%% ~~~

%% ## Множественное изменени

%% При изменении одной локации проблем не возникает. Однако мы редко изменяем одну
%% локацию -- на практике это делают по признаку, то есть пакетно.

%% Ранее мы раскладывали зиппер в цепочку локаций с помощью `iter-zip`, а затем
%% пропускали через серию `map`, `filter` и других функций. Для редактирования этот
%% метод не подходит. Предположим, мы выбрали второй элемент из результата
%% `zip-iter` и исправили его:

%% ~~~clojure
%% (def loc-seq
%%   (-> [1 2 3]
%%       zip/vector-zip
%%       iter-zip))

%% (-> loc-seq (nth 2) (zip/edit * 2))
%% ;; [4 {:l [1] :pnodes [[1 2 3]] :ppath nil :r (3)
%% ;;    :changed? true}]
%% ~~~

%% Функция `zip-iter` устроена так, что каждая следующая локация получается из
%% предыдущей. Вызов `zip/edit` на одном из элементов не повлияет на
%% последующие. Если подняться вверх от последней локации, получим вектор без
%% изменений.

%% ~~~clojure
%% (-> loc-seq last zip/up zip/node)
%% ;; [1 2 3]
%% ~~~

%% Как видно из примера, выражение с `zip/edit` не повлияло на результат.

%% При редактировании зипперов применяют следующие паттерны.

%% **Изменяется один элемент.** В этом случае мы итерируем зиппер до тех пор, пока
%% не встретим нужную локацию в цепочке. Затем меняем её и вызываем `zip/root`.

%% **Изменяются многие элементы.** С помощью `loop` и `zip/next` мы вручную
%% итерируем зиппер. При этом задана функция, которая либо меняет локацию, любо
%% оставляет нетронутой. В форму `recur` попадает `zip/next` от её результата. Если
%% изменения были, `zip/next` оттолкнётся от новой, а не исходной локации.

%% Для изменения локаций служат функции:

%% - `zip/replace` — буквальная замена текущего узла на другой.
%% - `zip/edit` — Редактирование узла. По аналогии с `update` и `swap!` принимает
%%   функцию и добавочные аргументы. Первым аргументом функция получит текущей
%%   узел. Результат заменит содержимое локации.
%% - `zip/remove` — Удаляет локацию и перемещает указатель на родителя.

%% Функции для вставки соседей и потомков:

%% - `zip/insert-left` — добавить соседа слева от текущей локации;
%% - `zip/insert-right` — добавить соседа справа;
%% - `zip/insert-child` — добавить текущей локации потомка в начало;
%% - `zip/append-child` — добавить потомка в конец.

%% Разница между соседом и потомком в иерархии. Сосед находится на одном уровне с
%% локацией, а потомок ниже. В центре диаграммы находится локация с вектором `[2
%% 3]`.  Её соседи -- числа 1 и 4, а потомки -- 2 и 3.


%% {: .asciichart}
%% ~~~


%%                 ┌─────────────┐
%%                 │ [1 [2 3] 4] │
%%                 └─────────────┘
%%                        ▲
%%                        │
%%     ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
%%     │   1   │◀───┃   [2 3]   ┃───▶│   4   │
%%     └───────┘    ┗━━━━━━━━━━━┛    └───────┘
%%                        │
%%                  ┌─────┴─────┐
%%                  ▼           ▼
%%              ┌───────┐   ┌───────┐
%%              │   2   │   │   3   │
%%              └───────┘   └───────┘

%% ~~~

%% Рассмотрим функции на простых примерах. Предположим, в глубине вложенных
%% векторов находится ключ `:error`, и нужно исправить его на `:ok`. Сперва добавим
%% предикат для поиска:

%% ~~~clojure
%% (defn loc-error? [loc]
%%   (some-> loc zip/node (= :error)))
%% ~~~

%% Теперь ищем локацию, исправляем её и поднимаемся к корню:

%% ~~~clojure
%% (def data [1 2 [3 4 [5 :error]]])

%% (def loc-error
%%   (->> data
%%        zip/vector-zip
%%        iter-zip
%%        (find-first loc-error?)))

%% (-> loc-error
%%     (zip/replace :ok)
%%     zip/root)

%% ;; [1 2 [3 4 [5 :ok]]]
%% ~~~

%% Другой пример — поменять во вложеном векторе все `nil` на 0, чтобы обезопасить
%% математические расчеты. На этот раз локация может быть не одна, поэтому
%% понадобится обход через `loop`. На каждом шаге мы проверяем, подходит ли
%% локация, и если да, передаём в `recur` вызов `zip/next` от изменённой версии:

%% ~~~clojure
%% (def data [1 2 [5 nil 2 [3 nil]] nil 1])

%% (loop [loc (zip/vector-zip data)]
%%   (if (zip/end? loc)
%%     (zip/node loc)
%%     (if (-> loc zip/node nil?)
%%       (recur (zip/next (zip/replace loc 0)))
%%       (recur (zip/next loc)))))

%% ;; [1 2 [5 0 2 [3 0]] 0 1]
%% ~~~

%% То же самое, но заменить все отрицательные числа по модулю. Для начала объявим
%% функцию `abs` (с версии 1.11 она встроена в Clojure):

%% ~~~clojure
%% (defn abs [num]
%%   (if (neg? num)
%%     (- num)
%%     num))
%% ~~~

%% Обход похож на предыдущий, но теперь вместо `zip/replace` мы вызываем
%% `zip/edit`, который обновляет содержимое локации, отталкиваясь от прежнего
%% значения:

%% ~~~clojure
%% (def data [-1 2 [5 -2 2 [-3 2]] -1 5])

%% (loop [loc (zip/vector-zip data)]
%%   (if (zip/end? loc)
%%     (zip/node loc)
%%     (if (and (-> loc zip/node number?)
%%              (-> loc zip/node neg?))
%%       (recur (zip/next (zip/edit loc abs)))
%%       (recur (zip/next loc)))))
%% ~~~

%% В обоих случаях цикл выглядит одинаково. Если это конечная локация, вернём её
%% узел. В противном случае, если локация подходит предикату, меняем ее содержимое
%% с помощью `zip/edit`. От изменённой локации переходим к следующей. Это ключевой
%% момент: в предпоследней строке вызов `zip/next` принимает результат `zip/edit`,
%% а не исходную локацию. Поэтому изменения будут переданы в следующий шаг `loop`.

%% Примеры выше образуют паттерны — повторяющиеся приёмы. Поместим их в отдельные
%% функции, чтобы не тратить на них внимание в будущем.

%% **Поиск локации по предикату.** Принимает начальную локацию и предикат, начинает
%% итерацию. Вернёт первую же локацию, которая подошла предикату:

%% ~~~clojure
%% (defn find-loc [loc loc-pred]
%%   (->> loc
%%        iter-zip
%%        (find-first loc-pred)))
%% ~~~

%% **Обход локаций с изменениями.** Перебирает локации с помощью `zip/next` и
%% `loop/recur`. При переходе на следующий шаг оборачивает локацию в
%% функцию. Ожидается, что функция либо изменит локацию, либо вернёт её без
%% изменений. Это обобщённая версия цикла, что мы написали выше.

%% ~~~clojure
%% (defn alter-loc [loc loc-fn]
%%   (loop [loc loc]
%%     (if (zip/end? loc)
%%       loc
%%       (-> loc loc-fn zip/next recur))))
%% ~~~

%% Перепишем примеры с новыми функциями. Найдём в векторе локацию, чей узел равен
%% двойке:

%% ~~~clojure
%% (defn loc-2? [loc]
%%   (-> loc zip/node (= 2)))

%% (def loc-2
%%   (-> [1 2 3]
%%       zip/vector-zip
%%       (find-loc loc-2?)))
%% ~~~

%% Удвоим её и выйдем на конечный вектор:

%% ~~~clojure
%% (-> loc-2 (zip/edit * 2) zip/root)
%% ;; [1 4 2]
%% ~~~

%% Изменим отрицательные числа по модулю. Для этого заведём функцию `loc-abs`. Если
%% в узле отрицательное число, вернём исправленную локацию, а иначе — исходную:

%% ~~~clojure
%% (defn loc-abs [loc]
%%   (if (and (-> loc zip/node number?)
%%            (-> loc zip/node neg?))
%%     (zip/edit loc abs)
%%     loc))
%% ~~~

%% Осталось передать её в `alter-loc`:

%% ~~~clojure
%% (-> [-1 2 [5 -2 2 [-3 2]] -1 5]
%%     zip/vector-zip
%%     (alter-loc loc-abs)
%%     zip/node)

%% ;; [1 2 [5 2 2 [3 2]] 1 5]
%% ~~~

%% Как только мы вынесли часть кода в функции, преобразования стали короче и
%% понятней. Как правило, любое действие над зиппером можно обобщить и поместить в
%% функцию, тем самым упростив логику.

%% ## Цены в XML

%% Перейдём к практическим примерам с XML и товарами. Подготовим следующий файл
%% `products-price.xml`:

%% ~~~xml
%% <?xml version="1.0" encoding="UTF-8"?>
%% <catalog>
%%   <organization name="re-Store">
%%     <product type="fiber" price="8.99">VIP Fiber Plus</product>
%%     <product type="iphone" price="899.99">iPhone 11 Pro</product>
%%   </organization>
%%   <organization name="DNS">
%%     <branch name="Office 2">
%%       <bundle>
%%         <product type="fiber" price="9.99">Premium iFiber</product>
%%         <product type="iphone" price="999.99">iPhone 11 Pro</product>
%%       </bundle>
%%     </branch>
%%   </organization>
%% </catalog>
%% ~~~

%% Обратите внимание, что у товаров появились цены -- характеристика, которая часто
%% меняется.

%% Напомним, что с точки зрения Clojure XML -- это вложенные словари с ключами
%% `:tag`, `:attrs` и `:content`. После изменений мы бы хотели видеть его в
%% привычном, текстовом виде. Понадобится обратное действие — из структуры данных
%% получить XML в виде текста. Для этого импортируем модуль `clojure.xml`. Его
%% функция `emit` выводит XML на печать.

%% Часто `emit` оборачивают в `with-out-str` — макрос для перехвата печати в
%% строку. В примерах ниже мы просто выводим XML в консоль. `Emit` не поддерживает
%% отступы, поэтому мы добавили их вручную для ясности.

%% **Первая задача** — сделать скидку 10% на все айфоны. У нас готовы почти все
%% абстракции, так что опишем решение сверху вниз:

%% ~~~clojure
%% (require '[clojure.xml :as xml])

%% (-> "products-price.xml"
%%     ->xml-zipper
%%     (alter-loc alter-iphone-price)
%%     zip/node
%%     xml/emit)
%% ~~~

%% Этих пяти строк достаточно для нашей задачи. Под вопросом только функция
%% `alter-iphone-price`. Ожидается, что для локации-айфона она вернёт её же, но с
%% другим атрибутом `price`. Локация другого типа останется без изменений. Опишем
%% функцию:

%% ~~~clojure
%% (defn alter-iphone-price [loc]
%%   (if (loc-iphone? loc)
%%     (zip/edit loc alter-attr-price 0.9)
%%     loc))
%% ~~~

%% Предикат `loc-iphone?` проверяет локацию на "айфонность". Мы уже писали его в
%% прошлом разделе:

%% ~~~clojure
%% (defn loc-iphone? [loc]
%%   (let [node (zip/node loc)]
%%     (and (-> node :tag (= :product))
%%          (-> node :attrs :type (= "iphone")))))
%% ~~~

%% Осталась функция `alter-attr-price`. Она принимает узел (содержимое локации) и
%% должна изменить его атрибут `:price`. Второй аргумент функции — коэффициент, на
%% который нужно умножить текущую цену. Небольшая трудность в том, что атрибуты в
%% XML — строки. Чтобы выполнить умножение, нужно вывести число из строки, умножить
%% на коэффициент, а результат привести в строку с округлением до двух цифр. Все
%% вместе даёт нам функцию:

%% ~~~clojure
%% (defn alter-attr-price [node ratio]
%%   (update-in node [:attrs :price]
%%              (fn [price]
%%                (->> price
%%                     read-string
%%                     (* ratio)
%%                     (format "%.2f")))))
%% ~~~

%% Быстрая проверка этой функции:

%% ~~~clojure
%% (alter-attr-price {:attrs {:price "10"}} 1.1)
%% ;; {:attrs {:price "11.00"}}
%% ~~~

%% Теперь когда известны все компоненты, запустим первое выражение и получим XML:

%% ~~~xml
%% <?xml version="1.0" encoding="UTF-8"?>
%% <catalog>
%%   <organization name="re-Store">
%%     <product price="8.99" type="fiber">VIP Fiber Plus</product>
%%     <product price="809.99" type="iphone">iPhone 11 Pro</product>
%%   </organization>
%%   <organization name="DNS">
%%     <branch name="Office 2">
%%       <bundle>
%%         <product price="9.99" type="fiber">Premium iFiber</product>
%%         <product price="899.99" type="iphone">iPhone 11 Pro</product>
%%       </bundle>
%%     </branch>
%%   </organization>
%% </catalog>
%% ~~~

%% Видим, что цена на айфоны изменилась на 10%, а у остальных товаров осталась
%% прежней.

%% **Более сложная задача** -- во все наборы (бандлы) добавить новый товар —
%% гарнитуру. Опять же, опишем решение сверху вниз:

%% ~~~clojure
%% (-> "products-price.xml"
%%     ->xml-zipper
%%     (alter-loc add-to-bundle)
%%     zip/node
%%     xml/emit)
%% ~~~

%% Решение отличается только функций `add-to-bundle`. Её логика следующая: если
%% текущая локация — набор, добавить ему потомка, а если нет, просто вернуть
%% локацию.

%% ~~~clojure
%% (defn add-to-bundle [loc]
%%   (if (loc-bundle? loc)
%%     (zip/append-child loc node-headset)
%%     loc))
%% ~~~

%% Проверка на набор:

%% ~~~clojure
%% (defn loc-bundle? [loc]
%%   (some-> loc zip/node :tag (= :bundle)))
%% ~~~

%% Функция `zip/append-child` добавляет значение в конец потомков локации. В данном
%% случае это узел `node-headset`, который вынесли в константу:

%% ~~~clojure
%% (def node-headset
%%   {:tag :product
%%    :attrs {:type "headset"
%%            :price "199.99"}
%%    :content ["AirPods Pro"]})
%% ~~~

%% Итоговый XML, где в наборах появился новый товар:

%% ~~~xml
%% <?xml version="1.0" encoding="UTF-8"?>
%% <catalog>
%%   <organization name="re-Store">
%%     <product price="8.99" type="fiber">VIP Fiber Plus</product>
%%     <product price="899.99" type="iphone">iPhone 11 Pro</product>
%%   </organization>
%%   <organization name="DNS">
%%     <branch name="Office 2">
%%       <bundle>
%%         <product price="9.99" type="fiber">Premium iFiber</product>
%%         <product price="999.99" type="iphone">iPhone 11 Pro</product>
%%         <product price="199.99" type="headset">AirPods Pro</product>
%%       </bundle>
%%     </branch>
%%   </organization>
%% </catalog>
%% ~~~

%% **Третья задача** — упразднить все наборы. Возможно, руководство решило, что
%% продавать товары в наборах невыгодно. Что ж, бывает. Для программиста это
%% значит, что из XML уходят все теги `<bundle>`, однако их товары должны перейти в
%% организацию.

%% И в третий раз решение отличается лишь целевой функцией:

%% ~~~clojure
%% (-> "products-price.xml"
%%     ->xml-zipper
%%     (alter-loc disband-bundle)
%%     zip/node
%%     xml/emit)
%% ~~~

%% Опишем алгоритм `disband-bundle`. Если текущий узел — набор, сохраним его
%% потомков (товары) в переменную, чтобы не потерять их. Затем удалим
%% набор. Функция удаления вернёт предка локации, в нашем случае
%% организацию. Присоединим к ней товары и вернем её.

%% ~~~clojure
%% (defn disband-bundle [loc]
%%   (if (loc-bundle? loc)
%%     (let [products (zip/children loc)
%%           loc-org (zip/remove loc)]
%%       (append-childs loc-org products))
%%     loc))
%% ~~~

%% Функция `append-childs` -- это обёртка над встроенной
%% `zip/append-child`. Последняя присоединяет только один элемент, что
%% неудобно. Чтобы присоединить их список, напишем свёртку:

%% ~~~clojure
%% (defn append-childs [loc items]
%%   (reduce (fn [loc item]
%%             (zip/append-child loc item))
%%           loc
%%           items))
%% ~~~

%% Финальный XML без наборов, но с теми же товарами:

%% ~~~xml
%% <?xml version="1.0" encoding="UTF-8"?>
%% <catalog>
%%   <organization name="re-Store">
%%     <product price="8.99" type="fiber">VIP Fiber Plus</product>
%%     <product price="899.99" type="iphone">iPhone 11 Pro</product>
%%   </organization>
%%   <organization name="DNS">
%%     <branch name="Office 2">
%%       <product price="9.99" type="fiber">Premium iFiber</product>
%%       <product price="999.99" type="iphone">iPhone 11 Pro</product>
%%     </branch>
%%   </organization>
%% </catalog>
%% ~~~

%% Надеемся, этих примеров достаточно, чтобы читатель понял, как редактировать
%% зипперы. Обратите внимание, что кода получилось немного: для каждой задачи мы
%% писали в среднем три функции. Другое преимущество в том, что нет состояния. Все
%% функции чистые, и их вызов не сказывается на данных. Если на середине выскочит
%% исключение, дерево XML не будет частично изменённым.

%% %% -------------

%% \section{Виртуальные деревья. Обмен валют}

%% Предыдущих занятий было достаточно, чтобы перейти к экспериментам над
%% зипперами. Предлагаем читателю подумать над необычным примером.

%% До сих пор вторая функция, которую мы передавали в зиппер, возвращала потомков
%% из ветки. Для вектора это была просто `seq`, для XML — более сложная комбинация
%% `(comp seq :content)`. Оба варианта отталкиваются от родительского узла, и если
%% потомков нет, функция вернёт `nil`.

%% Но что если функция вернёт постоянный набор потомков:

%% ~~~clojure
%% (fn [_]
%%   (seq [1 2 3]))
%% ~~~

%% Как поведёт себя такой зиппер? Напишем его:

%% ~~~clojure
%% (def zip-123
%%   (zip/zipper any?
%%               (constantly (seq [1 2 3]))
%%               nil
%%               1))
%% ~~~

%% <!-- more -->

%% Из-за того, что у каждого элемента три потомка, зиппер станет бесконечным. Обойти
%% его с помощью `iter-zip` не получится — `zip/next` будет всё глубже погружаться
%% в зиппер, но не достигнет его конца.

%% Ради интереса сделаем несколько шагов по новому зипперу. Спустимся вниз и
%% вправо. Мы окажемся на двойке в середине вектора `[1 2 3]`:

%% ~~~clojure
%% (def loc-2
%%   (-> zip-123
%%       zip/down
%%       zip/right))

%% (zip/node loc-2)
%% ;; 2
%% ~~~

%% Покажем наше положение не схеме. Шаги влево и право сдвинут нас на единицу и
%% тройку:

%% {: .asciichart}
%% ~~~
%%               ┌───────────┐
%%               │     1     │
%%               └───────────┘
%%                     ▲
%%                     │
%%  ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
%%  │   1   │◀───┃     2     ┃───▶│   3   │
%%  └───────┘    ┗━━━━━━━━━━━┛    └───────┘
%%                     │
%%                     ▼
%%                 ┌───────┐
%%                 │[1 2 3]│
%%                 └───────┘
%% ~~~

%% С шагом вниз мы провалимся в очередной вектор `[1 2 3]` и так далее. Ради
%% интереса спустимся вниз и вправо пять раз, и всё равно окажемся в двойке:

%% ~~~clojure
%% (def down-right (comp zip/right zip/down))

%% (-> loc-2
%%     down-right
%%     down-right
%%     down-right
%%     down-right
%%     down-right
%%     zip/node)
%% ;; 2
%% ~~~

%% Зиппер можно назвать виртуальным, потому что данных, по которым мы путешествуем,
%% на самом деле не существует — они появляются в полёте.

%% Пока что неясно, в чём польза от этого зиппера. Но он подтверждает важный тезис
%% — можно получать потомков в процессе обхода дерева. Это не нарушает правила
%% зипперов и даёт новые возможности.

%% Явно заданный вектор `[1 2 3]` не раскрывает их. Если потомки известны заранее,
%% нужда в зиппере отпадает — коллекцию можно обойти более простым
%% способом. Интересен случай, когда потомки зависят от каких-то внешних факторов,
%% например, приходят из сторонних источников. В терминах функционального
%% программирования зиппер становится "грязным": поскольку мы не контролируем
%% внешний источник, повторный обход может дать разный результат. Однако это не
%% значит, что грязный зиппер не имеет права на жизнь. Рассматривайте его как
%% абстракцию над источником, которая делает его удобней.

%% На роль примера отлично подходит файловая система. Ее элементы -- файлы и
%% директории -- отвечают всем условиям зиппера. Директория -- это узел, который
%% содержит ссылки на другие элементы. Когда вы просматриваете файлы в любом
%% менеджере, курсор ведет себя как локация. Он знает текущий файл, его соседей по
%% директории и пути вверх и вглубь (если текущий файл -- директория). Если
%% правильно подобрать функции `branch?` и `children`, обычный файл становится
%% зиппером.

%% Код оказывается на удивление коротким. Добавьте в пространство модуль
%% `clojure.zip` и класс `java.io.File`:

%% ~~~clojure
%% (ns zipper-demo
%%   (:import java.io.File)
%%   (:require
%%    [clojure.zip :as zip]))
%% ~~~

%% Функция `file-zip` принимает строковый путь и возвращает зиппер. Проверка
%% `branch?` сводится к вызову метода `.isDirectory` файла. Очевидно, если это
%% обычный файл, а не папка, двигаться ниже нельзя. Функция `children` опирается на
%% метод `.listFiles`, который вернет массив файлов в директории. Обертка в `seq`
%% необходима, чтобы привести пустой массив к `nil`.

%% ~~~clojure
%% (defn file-zip [^String path]
%%   (zip/zipper
%%    (fn [^File f] (.isDirectory f))
%%    (fn [^File f] (seq (.listFiles f)))
%%    nil
%%    (new File path)))
%% ~~~

%% Получим зиппер проведем с ним эксперименты. Первая локация указывает на
%% корневую папку:

%% ~~~clojure
%% (def fz
%%   (file-zip "/Users/ivan"))

%% (-> fz zip/node)
%% ;; #object[java.io.File 0xe413375 "/Users/ivan"]
%% ~~~

%% Вызов `zip/next` сдвигает указатель на вложенные папки и файлы. В случае автора
%% это скрытая папка `.eclipse`:

%% ~~~clojure
%% (-> fz zip/next zip/node)
%% ;; #object[java.io.File 0x23e1b67 "/Users/ivan/.eclipse"]
%% ~~~

%% Через три сдвига получим файл `secure_storage` в ее недрах:

%% ~~~clojure
%% (-> fz zip/next zip/next zip/next zip/node)
%% ;; #object[java.io.File 0x138b3172 "/Users/ivan/.eclipse/org.eclipse.equinox.security/secure_storage"]
%% ~~~

%% Сохраним локацию в переменную и вызовем `zip/path`. Получим вектор папок,
%% ведущих к файлу из локации:

%% ~~~clojure
%% (def file-loc
%%   (-> fz zip/next zip/next zip/next))

%% (zip/path file-loc)

%% [#object[java.io.File 0xe413375 "/Users/ivan"]
%%  #object[java.io.File 0x2067c8ff "/Users/ivan/.eclipse"]
%%  #object[java.io.File 0x69304325 "/Users/ivan/.eclipse/org.eclipse.equinox.security"]]
%% ~~~

%% Файловый зиппер поддерживает `iter-zip`, поиск, переходы и прочие техники, что
%% мы рассмотрели. Признаем, в случае с файлами это не самое оптимальное решение:
%% за долгие годы для них созданы инструменты намного быстрее. Но пример
%% подтверждает, что зиппером может выступить объект, который на первый взгляд не
%% подходит на эту роль.

%% Наверное, каждый программист сталкивался с неуклюжим API, который возвращает
%% сущности и ее потомков по одной. Например, древняя CRM по запросу `GET
%% /api/entity/<id>` вернет JSON вида:

%% ~~~json
%% {
%%   "id": 3,
%%   "name": "Gizmo",
%%   "description": "Does something",
%%   "children": [6, 9, 11, 23]
%% }
%% ~~~

%% Если у сущности нет потомков, в поле `children` пустой массив или оно
%% отсутствует.

%% Чтобы обойти сущности, построим зиппер, замкнутый на API. Предположим, функция
%% `entity-by-id` принимает HTTP-клиент с активным соединением и номер сущности и
%% возвращает прочитанный JSON из тела ответа.

%% ~~~clojure
%% (defn entity-by-id [http-client entity-id]
%%   ...)
%% ~~~

%% В этом случае зиппер выглядит как в примере ниже. Он принимает HTTP-клиент и
%% номер корневой сущности. Функция `branch?` проверяет, что поле `children` не
%% пустое. Функция потомков извлекает их в цикле `for`:

%% ~~~clojure
%% (defn entity-zip [http-client entity-id]
%%   (zip/zipper (fn [{:keys [children]}]
%%                 (pos? (count children)))
%%               (fn [{:keys [children]}]
%%                 (for [child children]
%%                   (entity-by-id http-client child)))
%%               nil
%%               (entity-by-id http-client entity-id)))
%% ~~~

%% Вызывая `zip/next`, мы будем шагать по сущностям, извлекая их по сети по мере
%% необходимости. Ради оптимизации можно заменить цикл `for` на частично
%% параллельный `pmap` или применить библиотеки Aleph и Manifold для удобной
%% многопоточности.

%% Когда сведения о потомках приходят по сети, важно оценить частоту запросов и
%% нагрузку на источник данных. Если это CRM в банковской системе, ее замедление
%% скажется на других частях компании. В этом случае данные полезно кэшировать в
%% памяти или в key-value хранилищах типа Memcached или Redis. Зиппер, построенный
%% на базе подобного хранилища, выглядит похоже за исключением функции
%% `entity-by-id`. Изменится только его конструктор, но не принцип работы.

%% Еще один интересный пример -- когда функции `branch?` и `children` замкнуты на
%% некоторых данных. Это тоже обход, но по другим правилам.

%% Рассмотрим следующую задачу. Банк разменивает валюты, например доллары на евро,
%% рубли на лиры и так далее. Для краткости обозначим их парами: `(usd, eur)`,
%% `(rub, lir)`. Размен действует в одном направлении: чтобы поменять евро на
%% доллары или лиры на рубли, у банка должны быть отдельные правила `(eur, usd)` и
%% `(lir, rub)`.

%% В банк обращается клиент, чтобы разменять валюту `X` на `Y`. Если в правилах
%% есть пара `(X, Y)`, проблемы не возникает. Но если пары нет, банк строит цепочку
%% обменов. Например, клиент хочет поменять доллары на лиры, но в банке нет прямой
%% пары `(usd, lir)`. Однако есть пары `(usd, eur)` и `(eur, lir)`. В этом случае
%% клиенту предложат обмен `usd` &rarr; `eur` &rarr; `lir`.

%% Ваша задача — написать программу, которая принимает правила обмена, входную и
%% выходную валюты. Вы должны найти цепочки обмена. Чем короче цепочка, тем
%% лучше. Если возможны несколько цепочек одинаковой длины, вернуть их все, чтобы
%% клиент мог выбирать. Учесть, что решений может не быть и адекватно реагировать
%% на этот случай: не уйти в вечный цикл, не занимать все ресурсы компьютера.

%% Опишем входные данные в терминах Clojure. Каждое правило будет парой кейвордов —
%% с какой валюты на какую происходит обмен. Вектор правил назовем `rules`. Кроме
%% правил, мы принимаем параметры `from` и `to` с какой и на какую валюту менять.

%% ~~~clojure
%% ;; rules
%% [[:usd :rub] [:rub :eur] [:eur :lir]]

%% :usd ;; from
%% :rub ;; to
%% ~~~

%% На выходе ожидаем набор цепочек от `from` к `to` или `nil`. Для случая выше
%% цепочка от доллара к евро выглядит так:

%% ~~~clojure
%% [:usd :rub :eur]
%% ~~~

%% Всё вместе даёт функцию `exchanges`, тело которой нам предстоит заполнить:

%% ~~~clojure
%% (defn exchanges [rules from to]
%%   ...)
%% ~~~

%% Для начала напишем несколько тестов. Они помогут размяться, и заодно мы лучше
%% поймем задачу. Первый тест — простой обмен, который есть среди правил:

%% ~~~clojure
%% (deftest test-simple
%%   (is (= [[:usd :rub]]
%%          (exchanges [[:usd :rub]] :usd :rub))))
%% ~~~

%% Обмен в обратную сторону невозможен, если нет отдельного правила:

%% ~~~clojure
%% (deftest test-reverse-err
%%   (is (nil? (exchanges [[:rub :usd]] :usd :rub))))
%% ~~~

%% Случай, когда цепочки обмена не существует:

%% ~~~clojure
%% (deftest test-no-solution
%%   (is (nil? (exchanges [[:rub :usd] [:lir :eur]] :usd :eur))))
%% ~~~

%% Наиболее важный сценарий: множественный обмен. От долларов к рублям ведут два
%% пути с евро и лирами в середине:

%% ~~~clojure
%% (deftest test-two-ways
%%   (is (= [[:usd :eur :rub]
%%           [:usd :lir :rub]]
%%          (exchanges [[:usd :eur]
%%                      [:eur :rub]
%%                      [:usd :lir]
%%                      [:lir :rub]] :usd :rub))))
%% ~~~

%% Ещё один тест проверяет, что вы вернём только самые короткие цепочки. Обмен с
%% четырьмя валютами (в данном случае `[:usd :yen :eur :rub]`) не попадёт в
%% результат:

%% ~~~clojure
%% (deftest test-short-ways-only
%%   (is (= [[:usd :eur :rub]
%%           [:usd :lir :rub]]
%%          (exchanges [[:usd :eur]
%%                      [:eur :rub]
%%                      [:usd :lir]
%%                      [:lir :rub]
%%                      [:usd :yen]
%%                      [:yen :eur]] :usd :rub))))
%% ~~~

%% В терминах олимпиадного программирования можно сказать, что задача содержит
%% отдельные рёбра графа. Требуется проверить, можно ли составить из рёбер маршрут
%% от вершины А к B. Поскольку эта глава о зипперах, мы не будем использовать
%% термины "граф" и "рёбра". Мы не гарантируем, что решение будет оптимальным, и
%% возможно, алгоритм на графах справится лучше. Однако надеемся, что пример ещё
%% больше раскроет мощь зипперов.

%% Как вы помните, зипперы удобны там, где встречается иерархия. На первый взгляд у
%% валют нет иерархии, но ее легко построить. Представим, что на вершине дерева
%% стоит валюта `from`, которую мы хотим разменять. Пусть это будет
%% доллар. Очевидно, что потомки этой валюты — все те, что размениваются на
%% доллар. Для этого выберем второй элемент из каждой пары, где первый элемент
%% равен `from`:

%% ~~~clojure
%% (def rules
%%   [[:usd :rub]
%%    [:usd :lir]
%%    [:rub :eur]
%%    [:rub :yen]
%%    [:eur :lir]
%%    [:lir :tug]])

%% (def from :usd)

%% (def usd-children
%%   (for [[v1 v2] rules
%%         :when (= v1 from)]
%%     v2))
%% ;; (:rub :lir)
%% ~~~

%% Таким образом, потомки доллара -- рубль и лира. Изобразим мнимое дерево и
%% обозначим уровни:

%% {: .asciichart}
%% ~~~
%%                   ┌───────┐
%%      1            │  usd  │
%%                   └───────┘
%%                       │
%%           ┌───────┐   │   ┌───────┐
%%      2    │  rub  │◀──┴──▶│  lir  │
%%           └───────┘       └───────┘
%% ~~~

%% Для каждой валюты второго уровня найдём потомков по такому же правилу. Для
%% удобства напишем функцию `get-children`:

%% ~~~clojure
%% (defn get-children [value]
%%   (for [[v1 v2] rules
%%         :when (= v1 value)]
%%     v2))

%% (get-children :rub)
%% ;; (:eur :yen)
%% ~~~

%% Новое дерево:

%% {: .asciichart}
%% ~~~
%%                       ┌───────┐
%%     1                 │  usd  │
%%                       └───────┘
%%                           │
%%               ┌───────┐   │   ┌───────┐
%%     2         │  rub  │◀──┴──▶│  lir  │
%%               └───────┘       └───────┘
%%                   │               │
%%        ┌───────┐  │  ┌───────┐    │  ┌───────┐
%%     3  │  eur  │◀─┴─▶│  yen  │    └─▶│  tug  │
%%        └───────┘     └───────┘       └───────┘
%% ~~~

%% Заметим, что это виртуальное дерево, о котором мы говорили недавно. У нас нет
%% этого дерева на руках -- оно получается в процессе. Функция `make-children`
%% замкнута на исходных парах обмена. Это пример того, как обходить данные, которые
%% получаем в полёте из других данных.

%% Структура дерева валют известна, и его можно обойти. Вопрос, до каких пор его
%% обходить? Очевидно, мы остановимся, как только встретим локацию, чей узел равен
%% валюте `to`. Пусть это будут йены. Это значит, мы соединили `from` и `to` с
%% помощью других валют. Обозначим решение на схеме:

%% {: .asciichart}
%% ~~~
%%                       ┌───────┐
%%     1                 │  usd  │
%%                       └───────┘
%%                           │
%%               ┌───────┐   │   ┌ ─ ─ ─ ┐
%%     2         │  rub  │◀──┘
%%               └───────┘       └ ─ ─ ─ ┘
%%                   │
%%        ┌ ─ ─ ─ ┐  │  ┌───────┐       ┌ ─ ─ ─ ┐
%%     3             └─▶│  yen  │
%%        └ ─ ─ ─ ┘     └───────┘       └ ─ ─ ─ ┘

%% ~~~

%% Чтобы получить цепочку обмена, локацию `to` передают в функцию `zip/path`. Она
%% вернёт вектор родителей локации, не включая ее саму. Путь к локации и её узел
%% образуют цепочку обмена.

%% На базе этих рассуждений напишем код. Подготовим зиппер:

%% ~~~clojure
%% (def zip-val
%%   (zip/zipper keyword?      ;; это валюта?
%%               get-children  ;; на что её можно разменять?
%%               nil
%%               from))        ;; исходная валюта
%% ~~~

%% Ищем в зиппере локацию с целевой валютой:

%% ~~~clojure
%% (defn loc-to? [loc]
%%   (-> loc zip/node (= to)))

%% (def loc-to
%%   (->> zip-val
%%        iter-zip
%%        (find-first loc-to?)))
%% ~~~

%% Если нашли, получим из неё цепочку обмена. Для этого к пути присоединим значение
%% `to`:

%% ~~~clojure
%% (conj (zip/path loc-to) (zip/node loc-to))
%% ;; [:usd :rub :yen]
%% ~~~

%% Задача решена, но с недостатком: для любых данных мы получим только одну
%% цепочку, даже если их несколько. Чтобы исправиться, ищем не только первую
%% локацию с валютой `to`, а их все с помощью `filter`.

%% Расширим исходные данные:

%% ~~~clojure
%% (def rules
%%   [[:usd :rub]
%%    [:usd :lir]
%%    [:rub :eur]
%%    [:lir :yen]
%%    [:rub :yen]
%%    [:eur :lir]
%%    [:lir :tug]])

%% (def from :usd)
%% (def to :yen)
%% ~~~

%% и найдём цепочки. Для этого заменим `find-first` на `filter`, который вернёт все
%% элементы, подходящие предикату, а не только первый.

%% ~~~clojure
%% (def locs-to
%%   (->> zip-val
%%        iter-zip
%%        (filter loc-to?)))
%% ~~~

%% Для каждой найденной локации постоим путь:

%% ~~~clojure
%% (for [loc locs-to]
%%   (conj (zip/path loc) (zip/node loc)))

%% ([:usd :rub :eur :lir :yen]
%%  [:usd :rub :yen]
%%  [:usd :lir :yen])
%% ~~~

%% Теперь мы нашли цепочки всех длин, что может быть избыточно. По условию задачи
%% нам не нужен обмен из четырёх операций, если найден с двумя. Напишем функцию,
%% которая вернёт самые короткие списки из результата выше. Она группирует обмены
%% по длине, находит меньшую длину и выбирает из словаря.

%% ~~~clojure
%% (defn get-shortest-chains
%%   [chains]
%%   (when (seq chains)
%%     (let [count->chains (group-by count chains)
%%           min-count (apply min (keys count->chains))]
%%       (get count->chains min-count))))
%% ~~~

%% Для последнего результата получим два вектора по три валюты в каждом. Этот
%% случай покрывает последний тест `test-short-ways-only`, где длинные цепочки
%% отбрасываются:

%% ~~~clojure
%% [[:usd :rub :yen] [:usd :lir :yen]]
%% ~~~

%% Составьте функцию `exchanges` из фрагментов кода. Убедитесь, что тесты
%% проходят. Добавьте в них больше случаев.

%% Кажется, что задача решена, однако её можно улучшить. Дело в том, что при особых
%% входных данных дерево станет бесконечным. Программа либо уйдёт в вечный цикл,
%% либо, если число шагов ограничить, не найдет решения. Не заглядывая вперед,
%% подумайте, что может быть тому причиной и как это исправить. На эти вопросы мы
%% ответим в следующем разделе.

%% %% -----------

%% \section{Обход в ширину. Улучшенный обмен валют}

%% В прошлый раз мы работали с деревом валют, чтобы построить цепочку обмена. Мы
%% нашли решение задачи, но упомянули, что в особых случаях дерево может получиться
%% бесконечным. Объясним, как это возможно. Для этого вспомним, как `zip/next`
%% обходит дерево.

%% [depth-first]: https://en.wikipedia.org/wiki/Depth-first_search

%% Алгоритм называется [depth first search][depth-first] или обход в глубину. При
%% таком обходе код стремится в первую очередь вниз, а уже потом — в сторону (в
%% нашем случае вправо). В этом легко убедиться, если разложить данные на части с
%% помощью зиппера:

%% ~~~clojure
%% (->> [1 [2 [3] 4] 5]
%%      zip/vector-zip
%%      iter-zip
%%      (map zip/node)
%%      (map println))

%% ;; 1
%% ;; [2 [3] 4]
%% ;; 2
%% ;; [3]
%% ;; 3
%% ;; 4
%% ;; 5
%% ~~~

%% <!-- more -->

%% Цифра `3`, идущая перед `4`, говорит о том, что зиппер следует вглубь (внутрь
%% вектора `[3]`) и только потом право.

%% Ещё более интересен случай с деревом, где у каждого узла потомки `[1 2 3]`. При
%% обходе такого дерева зиппер будет стремиться вниз, каждый раз спускаясь в
%% очередной вектор `[1 2 3]` и становясь на единицу. Покажем это на схеме:

%% ~~~clojure
%% (def zip-123
%%   (zip/zipper any?
%%               (constantly (seq [1 2 3]))
%%               nil
%%               1))
%% ~~~

%% {: .asciichart}
%% ~~~
%%                        ┌───────┐
%%                        │[1 2 3]│
%%                        └───────┘
%%                            │
%%                ┌───────┐   │
%%                │[1 2 3]│◀──┘
%%                └───────┘
%%                    │
%%         ┌───────┐  │
%%         │[1 2 3]│◀─┘
%%         └───────┘
%%             │
%%             │
%%     ...   ◀─┘

%% ~~~

%% Поскольку в зиппере нет условия, по которому производство потомков
%% останавливается, их вложенность неограничена. Функция `iter-zip` вернёт
%% бесконечную цепочку локаций, в каждой из которых единица. Неважно, сколько
%% единиц мы возьмём от неё -- сто или тысячу -- получим столько же единиц.

%% ~~~clojure
%% (->> zip-123
%%      iter-zip
%%      (take 10)
%%      (map zip/node))

%% ;; (1 1 1 1 1 1 1 1 1 1)
%% ~~~

%% Вернёмся к обмену валют. Предположим, банк меняет рубли на доллары, доллары на
%% евро и евро на рубли. Выразим это в коде:

%% ~~~clojure
%% (def rules
%%   [[:rub :usd]
%%    [:usd :eur]
%%    [:eur :rub]])
%% ~~~

%% Читатель заметит, что получился замкнутый круг:

%% {: .asciichart}
%% ~~~
%%              ┌───────┐
%%         ┌───▶│  rub  │────┐
%%         │    └───────┘    │
%%         │                 ▼
%%     ┌───────┐         ┌───────┐
%%     │  eur  │◀────────│  usd  │
%%     └───────┘         └───────┘
%% ~~~

%% Недостаток прошлого решения в том, что оно не учитывает цикличность
%% правил. Предположим, клиент хочет обменять рубли на лиры. Начнём строить дерево
%% от рубля. Начало цепочки:

%% {: .asciichart}
%% ~~~
%%                        ┌───────┐
%%                        │  rub  │
%%                        └───────┘
%%                            │
%%                ┌───────┐   │
%%                │  usd  │◀──┘
%%                └───────┘
%%                    │
%%         ┌───────┐  │
%%         │  eur  │◀─┘
%%         └───────┘
%%             │
%%  ┌───────┐  │
%%  │  rub  │◀─┘
%%  └───────┘
%% ~~~

%% Мы снова пришли к рублю. Для него мы получим доллар, для доллара евро, затем
%% рубль. Если продолжить итерацию, будем бесконечно погружаться в эту цепочку.

%% Логика подсказывает, что нужно пресечь обход вглубь, если очередная валюта равна
%% исходной. Проще говоря, у элемента `:rub`, который стоит *не на вершине*, не
%% может быть потомков. Но функции `branch?` и `make-children` не знают, какое
%% место в дереве занимает элемент. Они принимают значения, а не локации, и не
%% могут ответить на вопрос, вершина это или нет.

%% Проблему можно исправить с помощью состояния, например атома, который хранил бы
%% список валют, которые мы обошли. Другой вариант – проверять, в какой раз мы
%% обращаемся к валюте `from` для поиска потомков. Если в первый раз, мы на вершине
%% дерева. Найдём потомков и изменим атом, на котором замкнута функция
%% `children`. Если это последующий раз (атом изменён), мы наткнулись на цикл, и
%% для него потомков нет.

%% Оба способа имеют право на жизнь, но хотелось бы решить задачу без состояния и
%% изменяемых средств.

%% Если посмотреть на дерево, станет ясно: проблема в порядке обхода. Поскольку мы
%% стремимся вглубь, велика вероятность попасть в кротовую нору, из которой нельзя
%% выбраться. Нам может повезти, когда мы удачно шагнули в ветку с решением
%% (слева), а бесконечная ветка (справа) осталась нетронутой:

%% {: .asciichart}
%% ~~~
%%                  ┌───────┐
%%                  │  rub  │
%%                  └───────┘
%%                      │
%%          ┌───────┐   │   ┌───────┐
%%          │  yen  │◀──┴──▶│  usd  │
%%          └───────┘       └───────┘
%%              │               │
%%  ┏━━━━━━━┓   │               │   ┌───────┐
%%  ┃  lir  ┃◀──┘               └──▶│  eur  │
%%  ┗━━━━━━━┛                       └───────┘
%%                                      │
%%                                      │   ┌───────┐
%%                                      └──▶│  rub  │
%%                                          └───────┘
%%                                              │
%%                                              │
%%                                              └──▶  ...

%% ~~~

%% Однако это везение, и на него нельзя полагаться в решении задач.

%% Предположим теперь, зиппер обходит локации не вглубь, а вширь и вправо. С таким
%% порядком нам не страшны бесконечные ветки. Если таковая закралась в дерево, она
%% не оттянет на себя обход. Вместо этого мы спускаемся по этажам и читаем все
%% элементы этого уровня. Даже если один из них относится к бесконечной ветви, это
%% не помешает исследовать остальные. Рисунок ниже показывает, как горизонтальный
%% обход поможет добраться до цели. Вертикальный обход ушёл бы вы бесконечность,
%% потому что обе ветви цикличны.

%% {: .asciichart}
%% ~~~

%%                            ┌───────┐
%%                          ┌─│  rub  │
%%                          │ └───────┘
%%                          ▼
%%                      ┌───────┐   ┌───────┐
%%                      │  yen  │──▶│  usd  │
%%                      └───────┘   └───────┘
%%                                      │
%%                    ┌─────────────────┘
%%                    ▼
%%                ┏━━━━━━━┓                ┌───────┐
%%                ┃  lir  ┃───────────────▶│  eur  │
%%                ┗━━━━━━━┛                └───────┘
%%                                             │
%%           ┌─────────────────────────────────┘
%%           ▼
%%       ┌───────┐   ┌───────┐         ┌───────┐   ┌───────┐
%%       │  rub  │──▶│  tug  │────────▶│  yen  │──▶│  rub  │
%%       └───────┘   └───────┘         └───────┘   └───────┘
%%           │                                         │
%%           │                                         │
%%    ...  ◀─┘                                         └─▶  ...

%% ~~~

%% Проблема в том, что модуль `clojure.zip` предлагает только один способ обхода —
%% в глубину с помощью `zip/next`. Другого алгоритма не предусмотрено. Мы напишем
%% свою функцию, чтобы обойти зиппер "послойно". Говоря иначе, для дерева как на
%% рисунке:

%% {: .asciichart}
%% ~~~
%%                             ┌───────┐
%%   1                         │   1   │
%%                             └───────┘
%%                                 │
%%               ┌───────┐         │         ┌───────┐
%%   2           │   2   │◀────────┴────────▶│   3   │
%%               └───────┘                   └───────┘
%%                   │                           │
%%       ┌───────┐   │   ┌───────┐   ┌───────┐   │   ┌───────┐
%%   3   │   4   │◀──┴──▶│   5   │   │   6   │◀──┴──▶│   7   │
%%       └───────┘       └───────┘   └───────┘       └───────┘
%% ~~~

%% мы получим слои:

%% ~~~clojure
%% [1]
%% [2 3]
%% [4 5 6 7]
%% ~~~

%% , при этом каждый элемент будет не примитивом, а локацией. Это значит, элемент
%% помнит свое положение в дереве, от него можно переходить к другим элементам,
%% получить его путь и так далее.

%% Для начала нужна функция, которая вернёт дочерние локации исходной. Её логика
%% проста: погружаемся вниз, и если результат не пуст, двигаемся вправо.

%% ~~~clojure
%% (defn loc-children [loc]
%%   (when-let [loc-child (zip/down loc)]
%%     (->> loc-child
%%          (iterate zip/right)
%%          (take-while some?))))
%% ~~~

%% Обратите внимание, что это не то же самое, что `zip/children`. Последняя вернёт
%% значения, а не локации, а нам нужны именно локации. Сравните выражения:

%% ~~~clojure
%% (-> [1 2 3]
%%     zip/vector-zip
%%     zip/children)

%% (1 2 3)
%% ~~~

%% и

%% ~~~clojure
%% (-> [1 2 3]
%%     zip/vector-zip
%%     loc-children)

%% ([1 {:l [] :pnodes [[1 2 3]] :ppath nil :r (2 3)}]
%%  [2 {:l [1] :pnodes [[1 2 3]] :ppath nil :r (3)}]
%%  [3 {:l [1 2] :pnodes [[1 2 3]] :ppath nil :r nil}])
%% ~~~

%% Во втором случае получили локации, в то время как `zip/children` просто
%% обращается к функции для нахождения потомков, которую передали в зиппер.

%% Предположим, что для некоторой локации `loc-children` вернула список её
%% потомков. Чтобы спуститься на уровень ниже, нужно найти потомков для них и
%% объединить результат. Проще всего это это сделать выражением:

%% ~~~clojure
%% (mapcat loc-children locs)
%% ~~~

%% , где `locs` — локации текущего уровня. Если передать в `locs` результат
%% `mapcat`, продвинемся ещё дальше, и так до тех пор, пока не получим пустую
%% последовательность. Всё вместе даёт нам функцию `loc-layers`:

%% ~~~clojure
%% (defn loc-layers [loc]
%%   (->> [loc]
%%        (iterate (fn [locs]
%%                   (mapcat loc-children locs)))
%%        (take-while seq)))
%% ~~~

%% Она принимает корневую локацию, от которой начинается итерация по слоям. Первый
%% слой мы задали явно как вектор одной локации. Затем идут его потомки, затем
%% потомки потомков и так далее. Мы остановимся лишь когда получим пустой
%% слой. Быстрая проверка:

%% ~~~clojure
%% (def data [[[[1]]] 2 [[[3]]] 3])

%% (let [layers (-> data
%%                  zip/vector-zip
%%                  loc-layers)]
%%   (for [layer layers]
%%     (->> layer
%%          (map zip/node)
%%          println)))

%% ;; ([[[[1]]] 2 [[[3]]] 3])
%% ;; ([[[1]]] 2 [[[3]]] 3)
%% ;; ([[1]] [[3]])
%% ;; ([1] [3])
%% ;; (1 3)
%% ~~~

%% Чтобы соединить слои в цепь, воспользуемся `apply` и `concat`. Эта функция не
%% понадобится в решении задачи, но может оказаться полезной:

%% ~~~clojure
%% (defn loc-seq-layers [loc]
%%   (apply concat (loc-layers loc)))
%% ~~~

%% Вернёмся к обмену валют. Подберём правила обмена так, чтобы в них были
%% циклические зависимости:

%% ~~~clojure
%% (def rules2
%%   [[:rub :usd]
%%    [:usd :eur]
%%    [:eur :rub]

%%    [:rub :lir]
%%    [:lir :eur]
%%    [:eur :din]
%%    [:din :tug]])
%% ~~~

%% Зиппер не изменится, но теперь мы обходим его по-другому: не с помощью
%% `zip/next`, а функцией `loc-layers`. На каждом шаге получим слои обмена. Наша
%% задача — найти в очередном слое локации, чей узел равен конечной валюте. Если
%% нашли хотя бы одну, задача решена. Останется вычислить до них путь.

%% ~~~clojure
%% (defn exchange2 [rules from to]

%%   (letfn [(get-children [value]
%%             (seq (for [[v1 v2] rules
%%                        :when (= v1 value)]
%%                    v2)))

%%           (loc-to? [loc]
%%             (-> loc zip/node (= to)))

%%           (find-locs-to [layer]
%%             (seq (filter loc-to? layer)))

%%           (->exchange [loc]
%%             (conj (zip/path loc) (zip/node loc)))]

%%     (let [zipper (zip/zipper keyword?
%%                              get-children
%%                              nil
%%                              from)]

%%       (->> zipper
%%            loc-layers
%%            (some find-locs-to)
%%            (map ->exchange)))))
%% ~~~

%% Заметим, что теперь не нужно сравнивать длины цепочек: если локации относятся к
%% одному уровню, число шагов до них одинаково. По условию задачи мы заинтересованы
%% в самых коротких вариантах обмена. Если на третьем уровне нашлась одна цепочка,
%% а на четвертом их три, последние нам не интересны — обход завершится на третьем
%% слое.

%% Примеры обмена с правилами, заданными в `rules2`:

%% ~~~clojure
%% (exchange2 rules2 :rub :eur)
%% ([:rub :usd :eur] [:rub :lir :eur])

%% (exchange2 rules2 :rub :tug)
%% ([:rub :usd :eur :din :tug] [:rub :lir :eur :din :tug])

%% (exchange2 rules2 :lir :din)
%% ([:lir :eur :din])
%% ~~~

%% Решение все ещё не идеально. Если указать пару валют, для которых нет цепочки,
%% получим бесконечный цикл. Чтобы пресечь его, ограничьте число слоев каким-то
%% разумным числом, например пятью. С точки зрения финансов обмен с таким числом
%% операций будет невыгодным, а потому лишен смысла. Технически это значит добавить
%% форму `(take N)` сразу после `loc-layers`:

%% ~~~clojure
%% (->> zipper
%%      loc-layers
%%      (take 5)
%%      (some find-locs-to)
%%      (map ->exchange))
%% ~~~

%% Теперь для неверной пары получим пустой результат:

%% ~~~clojure
%% (exchange2 rules2 :tug :yen)
%% ()
%% ~~~

%% Задачу можно развить еще дальше. Скажем, для каждой цепочки считать издержки и
%% комиссию за операцию. Для этого в вектор `[:from :to]` добавим обменный курс и
%% вознаграждение. В зависимости от того, на чьей мы стороне — клиента или банка —
%% будем искать самые затратные или оптимальные обмены. Предлагаем читателю
%% придумать свои вариации к этой задаче.

%% На этом мы закончим с валютами и двинемся дальше. Мы рассмотрели, как порядок
%% обхода влияет на решение задачи. В разных случаях применяют методы в глубину и в
%% ширину. Это важно для бесконечных деревьев, когда алгоритм может зациклиться при
%% обходе. В поставке `clojure.zip` нет обхода вширь, но легко написать функцию
%% деления зиппера на слои. Возможно, `loc-layers` пригодится вам в других случаях,
%% связанных с графами и вершинами.

%% %% -----------

%% \section{Заключение}

%% В заключение рассмотрим другие возможности зипперов, которые могут быть вам
%% полезны.

%% ## HTML

%% Из прошлых примеров видно, что зипперы подходят для XML. В том числе их можно
%% применить для HTML. Синтаксис форматов отличается: некоторые HTML-элементы вроде
%% `<br>` или `<img>` не имеют закрывающих тегов. Проблему решают парсеры, которые
%% учитывают эти особенности. На выходе получим дерево, которое поддается обходу
%% как XML.

%% <!-- more -->

%% [hickory]:https://github.com/davidsantiago/hickory
%% [jsoup]:https://jsoup.org/

%% Библиотека [Hickory][hickory] предлагает парсер разметки HTML. Разбор основан на
%% Java-библиотеке [JSoup][jsoup], которая строит дерево элементов. Hickory
%% содержит функцию, чтобы перестроить Java-дерево в Clojure-подобное и получить
%% зиппер. Добавьте в проект зависимость:

%% ~~~clojure
%% [hickory "0.7.1"]
%% ~~~

%% и выполните пример:

%% ~~~clojure
%% (ns zipper-manual.core
%%   (:require
%%    [hickory.core :as h]
%%    [hickory.zip :as hz]
%%    [clojure.zip :as zip]))

%% (def html (-> "https://grishaev.me/"
%%               java.net.URL.
%%               slurp))

%% (def doc-src (h/parse html))
%% (def doc-clj (h/as-hiccup doc-src))
%% (def doc-zip (hz/hiccup-zip doc-clj))
%% ~~~

%% Объясним эти преобразованиия. В переменную `html` загружается разметка сайта в
%% виде строки. В переменной `doc-src` оказалось дерево, полученное из HTML. Это
%% объект класса `Document` из пакета `org.jsoup.nodes`. С точки зрения Clojure это
%% чёрный ящик: чтобы работать с ним, нужно читать документацию к классу
%% `Document`.

%% Функция `as-hiccup` переводит документ в набор вложенных векторов вида:

%% ~~~clojure
%% [:tag {:attr "value"} & [...]],
%% ~~~

%% На первом месте тег, затем словарь атрибутов, а за ним -- любое число таких же
%% векторов или строк. Это стандартное представление HTML в Clojure, и многие
%% библиотеки используют такой же формат.

%% Функция `hiccup-zip` возвращает зиппер этой структуры. С ним можно сделать всё
%% то, в чём мы упражнялись ранее, например:

%% - удалить нежелательные теги вроде `<script>`, `<iframe>`;
%% - оставить эти теги, но обезопасить их атрибуты;
%% - оставить, только если источник указывает на доверенные сайты;
%% - искать интересующие нас элементы.

%% Вот как найти все картинки страницы:

%% ~~~clojure
%% (defn loc-img? [loc]
%%   (some-> loc zip/node first (= :img)))

%% (defn loc->src [loc]
%%   (some-> loc zip/node second :src))

%% (->> doc-zip
%%      iter-zip
%%      (filter loc-img?)
%%      (map loc->src))

%% ("/assets/static/photo-round-small.png" ...)
%% ~~~

%% Первая функция проверяет, что локация указывает на узел с тегом `<img>`, вторая
%% извлекает из него атрибут `src`. Третья форма вернёт список ссылок на
%% изображения.

%% На этой базе можно построить фильтрацию HTML, что особенно важно, если разметка
%% приходит от пользователя. Другой сценарий — найти в HTML подходящее изображение
%% для обложки в соцсети. Для этого нужно выбрать все изображения, оценить их
%% ширину и высоту и выбрать наибольшее по площади (если заполнены атрибуты `width`
%% и `height`).

%% Hickory предлагает селекторы для поиска по тегу и атрибуту. Для этого даже не
%% обязательно приводить дерево JSoup к зипперу. Однако в редких случаях нужно
%% найти теги со сложной взаимосвязью как в примере с товаром и набором (только в
%% наборе или строго не в нём). Эти задачи изящно ложатся на зипперы.

%% ## Данные и сериализация

%% Плюс зипперов в том, что они остаются данными — комбинацией списков и
%% словарей. Локацию можно записать в EDN или JSON. При чтении мы получим ее же и
%% продолжим обход с того места, где остановились. Это отличает Clojure от
%% объектных языков, где в общем случае нельзя записать объект в файл без
%% определенных усилий.

%% При восстановлении зиппера помните о его метаданных. Функции `branch?`,
%% `children` и `make-node`, которые мы передали в конструктор, хранятся в
%% метаданных зиппера. Это сделано для того, чтобы отделить данные от действий над
%% ними. Проверим метаданные зиппера, который получили из HTML:

%% ~~~clojure
%% (meta doc-zip)

%% #:zip{:branch? #function[clojure.core/sequential?],
%%       :children #function[hickory.zip/children],
%%       :make-node #function[hickory.zip/make]}
%% ~~~

%% Напишем функции для сброса и чтения EDN:

%% ~~~clojure
%% (defn edn-save [data path]
%%   (spit path (pr-str data)))

%% (defn edn-load [path]
%%   (-> path slurp edn/read-string))
%% ~~~

%% Предположим, мы дошли со середины зиппера и сохранили его в файл:

%% ~~~clojure
%% (-> doc-zip
%%     zip/next
%%     zip/next
%%     zip/next
%%     (edn-save "zipper.edn"))
%% ~~~

%% Если считать EDN и передать результат в `zip/next`, получим ошибку. Функция
%% вызовет `branch?` и `children` из метаданных, которые не сохранились, что
%% приведёт к исключению. Чтобы зиппер из файла заработал, добавьте ему
%% метаданные. Скопируйте их из зиппера или объявите вручную:

%% ~~~clojure
%% (def zip-meta (meta doc-zip))

%% ;; or

%% (def zip-meta
%%   #:zip{:branch? sequential?
%%         :children #'hickory.zip/children
%%         :make-node #'hickory.zip/make})
%% ~~~

%% Во втором случае нам прошлось указать ссылки на функции `children` и
%% `make-node`, потому что они приватные. После вызова `with-meta` локация из файла
%% окажется в том же состоянии, что и при сохранении.

%% ~~~clojure
%% (def doc-zip-new
%%   (-> "zipper.edn"
%%       edn-load
%%       (with-meta zip-meta)))

%% (-> doc-zip-new zip/node first)
%% :head
%% ~~~

%% Хранение зиппера в долговременной памяти дает новые возможности. Например, обход
%% каких-то данных занимает время, и программа выполняет задачу порциями, сохраняя
%% промежуточный результат. Так работают сложные бизнес-сценарии. Если клиент
%% отказывается от услуг фирмы, мы должны удалить его записи в базе, файлы, ссылки
%% в документах и много другое. Этот процесс можно представить как набор шагов. На
%% каждом шаге код читает из базы зиппер в формате EDN и добавляет
%% метаданные. Затем сдвигает его на один шаг при помощи `zip/next`, выполняет
%% задачу текущего узла и сохраняет в базу новую версию зиппера.

%% ## Другое

%% Пример с разменом показывает, как найти решение задачи перебором. Если вы ищете
%% оптимальную цепочку шагов, максимальную цену, короткий маршрут — возможно, вам
%% помогут зипперы. Необходимо лишь одно условие: чтобы сущности строились в
%% иерархию. Как только вы знаете принцип подчинения, не составит труда написать
%% зиппер и обойти его.

%% Скажем, согласно таблице доллар (текущее значение) можно разменять на евро и
%% рубль (дочерние значения). Из точки A (текущее) можно проехать в пункты B и C
%% (дочерние). В HTML один тег может включать в себя другие. Все три случая
%% подходят зипперу, нужно только описать функции `branch?` — может ли элемент
%% иметь потомков -- и `children` — как конкретно их найти.

%% ## Сторонние библиотеки

%% [data.zip]:https://github.com/clojure/data.zip/

%% [zippo]: https://github.com/igrishaev/zippo

%% Модуль `clojure.zip` предлагает достаточно функций для навигации, однако по ходу
%% главы мы создали немало своих инструментов. Автор собрал их в библиотеке
%% [Zippo][zippo]. Похожий проект [data.zip][data.zip] содержит различные
%% дополнения к зипперами. Возможно, эти две библиотеки окажутся вам полезны.

%% ## Заключение

%% Зиппер — это способ навигации по структуре данных. Он предлагает движение по
%% четырём сторонам: вниз, вверх, влево, вправо. Элемент в центре называется
%% текущим.

%% Зиппер работает с самыми разными структурами. Ему нужно знать только две вещи:
%% является ли текущий элемент веткой дерева и если да, то как найти потомков. Для
%% этого зиппер принимает функции `branch?` и `children`, которые хранит в
%% метаданных.

%% Обычно потомков находят из родительского узла, но в некоторых случаях получают
%% динамически. Например, чтобы узнать, на какие валюты можно разменять текущую,
%% обращаются к словарю обмена. Для этого словарь должен быть виден функции
%% `children` как глобальная переменная или замыкание.

%% Текущий элемент зиппера называют локацией. Он хранит не только значение, но и
%% данные для перехода во все стороны, а также путь. Это выгодно отличает зиппер от
%% `tree-seq` и аналогов, которые раскладывают дерево в цепь без учета пути к
%% элементу. Некоторые задачи состоят именно в поиске нужного пути.

%% Зиппер предлагает функции для правки и удаления текущего узла. Правка может
%% отталкиваться от текущего значения (`zip/edit`) или нового (`zip/replace`).

%% По умолчанию обход зиппера происходит в глубину (depth first). При переходе в
%% конец локация получит отметку о том, что цикл пройден. Используйте функцию
%% `zip/end?` как признак конца итерации. В наших примерах мы написали функцию
%% `zip-iter`, которая завершает обход на предпоследнем элементе.

%% Для некоторых задач необходим обход в ширину. Это может случиться, когда одна из
%% ветвей дерева потенциально бесконечна. Для обхода в ширину мы написали свои
%% функции, которых нет в поставке Clojure.zip.

%% Зипперы полезны в работе с XML, поиском решений, фильтрации HTML. Потратьте на
%% них время, чтобы в будущем решать такие задачи коротко и изящно.
