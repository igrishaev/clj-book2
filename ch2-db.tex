\chapter{Реляционные базы данных}

\begin{teaser}
В этой главе мы поговорим о реляционных базах данных в Clojure. Б\'{о}льшую часть описания займет библиотека clojure.java.jdbc и дополнения к ней. Вы узнаете, какие проблемы встречаются в этой области и как их решают в Clojure.
\end{teaser}

В разработке бекенда базы данных занимают центральное место. Если говорить упрощенно, любая программа сводится к обработке данных. Конечно, они поступают не только из баз, но и сети и файлов. Однако в целом за доступ к информации отвечают именно базы данных~--- специальные программы, сложные, но с богатыми возможностями.

Базы данных, или сокращенно БД, бывают разных видов. Они различаются в архитектуре и способе хранения информации. Некоторые базы работают только на клиенте, то есть в рамках одного компьютера. Другие хранят только текст и оставляют вывод типов на ваше усмотрение. Встречаются базы, где данные хранятся в оперативной памяти и пропадают после выключения.

Мы не ставим цель охватить как можно больше баз и способов работы с ними. Наоборот, сфокусируем внимание на том, что встретит вас в реальном проекте. Скорей всего это будет классическая реляционная база данных вроде PostgreSQL или MySQL. О них мы и будем говорить.

\def\urlrelalg{https://en.wikipedia.org/wiki/Relational\_algebra}
\def\urlnormform{https://en.wikipedia.org/wiki/Database\_normalization}

Реляционные базы данных называют так из за модели \footurl{реляционной алгебры}{\urlrelalg}[Ре\-ля\-ци\-он\-ная ал\-геб\-ра]. Это изящная математическая модель с набором операций: выборкой, проекцией, декартовым произведением и другими. Из модели следуют правила о том, как работает та или иная операция. В свою очередь, из правил следуют \footurl{нормальные формы}{\urlnormform}[Нор\-маль\-ные фор\-мы] (первая, вторая и третья), доказать которые можно аналитически, а не на глаз.

Мы будем учить реляционную алгебру с самых азов. Обратитесь к статье в Википедии или книгам, где она описана без привязки к конкретной БД.

Перейдем к понятиям, более привычным программисту. Базы хранят содержимое в таблицах. Запись в таблице называется кортежем и состоит из отдельных полей. Поля могут быть разного типа. Состав полей и их порядок одинаков в рамках таблицы. Не может быть так, что в первой записи два поля, а во второй три. Если нужно указать, что в поле нет значения, в него пишут специальное пустое, чаще всего NULL.

У записи есть особое поле, которое называют первичным ключом, Primary key. Ключ однозначно указывает на запись в таблице. Не может быть двух записей с одинаковым ключом. Чаще всего роль ключа играет число с автонумерацией, но иногда это строка, например электронная почта или артикул товара.

В редких случаях ключ может быть составным, то есть определяться парой полей, например тип платежной системы и номер платежа. В этом случае мы допускаем, что в таблице могут быть несколько платежей Stripe с разными номерами или платежи Stripe и AppStore с одинаковым номером, но не то и другое вместе.

\begin{english}
  \begin{text}
 gateway   | trx_no |
-----------+---------
 stripe    | 1      | ;; ok
 stripe    | 2      | ;; ok
 appstore  | 2      | ;; ok
 appstore  | 2      | ;; error!
  \end{text}
\end{english}

Внешним ключом называется поле, которые ссылается на первичный ключ другой таблицы. Для краткости его называют ссылкой (ref). Примером может быть поле \code{user\_id} таблицы профилей, которое указывает на поле \code{id} таблицы пользователей \coderef(7).

\begin{english}
  \begin{sql/lines}
CREATE TABLE users(
    id   serial primary key,
    name text not null
);
CREATE TABLE profiles(
    id      serial primary key,
    user_id integer not null references users(id),
    avatar  text
);
  \end{sql/lines}
\end{english}

Ссылка отличается от числа особыми свойствами: она гарантирует, что указанный пользователь действительно существует. Обычное число этой гарантии не дает. Говорят, что ссылки поддерживают целостность базы. Целостность означает, в базе нет ссылок на несуществующие записи.

Кроме целостности, внешний ключ поддерживает реакцию на удаление. По умолчанию нельзя удалить сущность, на которую кто-то ссылается. Однако можно задать правило, что связанная сущность тоже удаляется. Так, при удалении пользователя удалится и его профиль, ведь он не нужен в отрыве от пользователя. В другом случае ссылка на удаленную сущность станет NULL, если это разрешено в свойствах поля.

Из университета мы знаем, что связи бывают разных типов: один к одному или многим, многие ко многим. Профиль, который ссылается на пользователя~--- это связь один к одному. Несколько заказов у пользователя~--- один ко многим. Тип связи легко задать ограничением на поле ссылки. Если в таблице профилей сделать поле \code{user\_id} уникальным, не получится создать два профиля одному пользователю.

Связь <<многие ко многим>> строят через таблицу-мост со ссылками на другие таблицы. Чтобы сущности нельзя было соединить несколько раз, применяют составной первичный ключ из ссылок.

\section{Запросы}

\def\urlsql{https://en.wikipedia.org/wiki/SQL}

База данных обращается с миром через \footurl{SQL}{\urlsql}[SQL] (Structured Query Language)~--- структурированный язык запросов. Это текст, который описывает наши намерения~--- прочитать таблицу, добавить запись, обновить поле. Запросы имеют четкую структуру, которая чаще всего зависит от главного оператора. К ним относятся \code{SELECT}, \code{INSERT}, \code{UPDATE}, \code{DELETE} и другие команды.

Существуют несколько стандартов SQL, обозначенных годами, когда они были приняты: SQL'92, '99, '2003 и другие. Каждая база данных поддерживает стандарт определенного года, включая предыдущие. Кроме стандарта, базы предлагают расширения~--- возможности, которые не входят в него. При чтении документации обращайте внимание на то, относится ли конкретная возможность к стандарту или это частное решение.

В аббревиатуре SQL последняя буква означает language, язык. Однако это не язык программирования, потому что на нем нельзя выразить алгоритм задачи. Говоря точнее, SQL не полон по Тьюрингу: вы не сможете построить SQL-выражение на нем самом. Сложные запросы строят при помощи полноценных (полных по Тьюрингу) языков: Java, Python, Clojure.

\def\urlsqldo{https://www.postgresql.org/docs/current/sql-do.html}

Некоторые базы данных предлагают встроенные языки и операторы, чтобы это исправить. Так, в PostgreSQL доступен \footurl{блок DO}{\urlsqldo}[SQL DO], где работают переменные, циклы и даже перехват исключений. Однако это частное решение, которое не входит в стандарт.

\section{Доступ из Clojure}

Теперь когда мы освежили теорию, перейдем к практике. По умолчанию Clojure не предлагает доступа к базам данных. Чтобы работать с ними, подключают библиотеку clojure.java.jdbc~--- тонкую обертку над JDBC. Так называется встроенный в Java пакет для реляционных баз данных.

\def\urljdbc{https://docs.oracle.com/javase/tutorial/jdbc/basics/index.html}

\footurl{JDBC}{\urljdbc}[JDBC] (Java Database Connectivity) отсчитывает свой возраст с 1997 года. Главная задача JDBC~--- предоставить общий API для разных баз. Для этого JDBC устроен из нескольких слоев. Потребители используют общий API, который, в зависимости от типа базы, вызывает разные драйверы.

Драйверы служат для связи JDBC с бекендом. Каждый из них реализует бинарный протокол, по которому работает база. На сегодняшний день JDBC поддерживает все известные реляционные СУБД: PostgreSQL, MySQL, Oracle, SQLite и другие. Существуют драйверы для файловых хранилищ, например Excel, DBF, CSV.

Для работы с какой-либо базой вам понадобится драйвер к ней. Драйверы поставляются отдельно и должны быть объявлены в зависимостях проекта. JDBC автоматически находит и подключает драйвер; программисту не нужно заботиться об этом.

Перечислим основные сущности JDBC:

\begin{itemize}

\item
  \code{DriverManager}~--- класс для управления драйвером конкретной БД. Получает соединение с базой, по которому в дальнейшем идет обмен данными.

\item
  \code{PreparedStatement}~--- подготовленное выражение. Так называется запрос, который прошел стадию подготовки и теперь может быть вызван с разными параметрами.

\item
  \code{ResultSet}~--- источник, из которого читают результат запроса. Обычно приходит из метода \code{executeQuery} подготовленного выражения.

\end{itemize}

Код на следующем развороте показывает, как выбрать записи из таблицы и напечатать их силами Java \lis{fig:java-jdbc}. Из-за многословности Java мы уменьшили шрифт и сократили некоторые конструкции, например заменили \code{System.out.println} на \code{S.o.println}.

\begin{figure}[ht!]

\begin{english}
  \begin{java*}{fontsize=\small}
import java.sql.*;

public class JDBCExample {

  static String DB_URL = "jdbc:postgresql://127.0.0.1/test";
  static String USER = "book";
  static String PASS = "book";
  static String QUERY = "SELECT * FROM users";

  public static void main(String[] args) {

    try {

      Connection conn =
        DriverManager.getConnection(DB_URL, USER, PASS);
      Statement stmt = conn.createStatement();
      ResultSet rs = stmt.executeQuery(QUERY);

      while (rs.next()) {
        S.o.println("ID: " + rs.getInt("id"));
        S.o.println("First name: " + rs.getString("fname"));
        S.o.println("Last name: " + rs.getString("lname"));
        S.o.println("Email: " + rs.getString("email"));
        S.o.println("Age: " + rs.getInt("age"));
      }

    } catch (SQLException e) {
      e.printStackTrace();
    }
  }
}
  \end{java*}
\end{english}

\caption{Запрос и печать результата в Java}
\label{fig:java-jdbc}

\end{figure}

В идеале при смене базы код останется прежним, а изменится только синтаксис SQL. И хотя это верно лишь отчасти, JDBC решает основную задачу~--- предлагает единый доступ к разным бекендам.

\def\urlpep{https://www.python.org/dev/peps/pep-0249/}

Похожий стандарт существует в других языках, например Python. Там он называется \footurl{DB API}{\urlpep}[DB API]. Его задача~--- обозначить минимальный набор правил, которым должен следовать драйвер. С этим требованием легче писать код для разных баз.

\section{Знакомство с clojure.java.jdbc}

\def\urljavajdbc{https://github.com/clojure/java.jdbc}

Из примера на Java видно, что даже простой запрос требует многих усилий. В Clojure принято упрощать рутину, и библиотека \footurl{clojure.java.jdbc}{\urljavajdbc}[java.jdbc] создана именно для этого. Она создает тонкую обертку вокруг классов \code{DriverManager}, \code{PreparedStatement} и других, чтобы получить результат буквально парой строк. Добавьте библиотеку и драйвер PostgreSQL в проект:

\begin{english}
  \begin{clojure}
;; project.clj
[org.clojure/java.jdbc "0.7.8"]
[org.postgresql/postgresql "42.1.3"]
  \end{clojure}
\end{english}

Предположим, сервер PostgreSQL развернут локально. Вот как выполнить в нему запрос:

\begin{english}
  \begin{clojure/lines}
(def db {:dbtype "postgresql"
         :dbname "test"
         :host "127.0.0.1"
         :user "book"
         :password "book"})

(jdbc/query db "select 1 as value")

;; ({:value 1})
  \end{clojure/lines}
\end{english}

Мы объявили параметры подключения словарем и передали его в функцию \code{jdbc/query}. Запрос возвращает постоянное число, поэтому он сработает, даже если в базе нет таблиц.

Пока мы не ушли вперед, разберем, что произошло. Переменная \code{db} называется JDBC-спекой \coderef{1}. Это словарь с различными полями: хостом, портом, пользователем и другими. Из него библиотека получает соединение с базой. По завершении запроса соединение закрывается. JDBC-спека принимает разные формы, и позже мы рассмотрим их.

\def\urlpgpro{https://postgrespro.ru}

Зависимость \code{[org.postgresql/postgresql "42.1.3"]} нужна для работы с PostgreSQL. Ее драйвер находится в репозитории Maven. Тот факт, что мы используем именно PostgreSQL, JDBC поймет из поля \code{dbtype} со значением <<postgresql>>. Он автоматически загрузит драйвер, так что импортировать его в Clojure не нужно.

Чтобы не распылять внимание на разные базы, остановим выбор на PostgreSQL до конца главы. В пользу PostgreSQL говорит зрелость и мощь проекта, его открытый код и бесплатный доступ. В России действует официальный вендор \footurl{PostgresPro}{\urlpgpro}[Postgres Pro]. Их силами созданы полезные расширения, переведена документация на русский язык.

Чтобы запрос выполнился, должен работать локальный сервер PostgreSQL. Наиболее быстрый способ запустить его с нужными настройками~--- вызывать одноименный образ Docker. Следующая команда:

\begin{english}
  \begin{bash}
> docker run --rm -it -e POSTGRES_PASSWORD=pass postgres
  \end{bash}
\end{english}

\def\urlcljbook{https://grishaev.me/clojure-in-prod/}

\noindent
запустит сервер на локальном порту 5432. Имя базы, пользователь и пароль определяются переменными окружения; в примере выше пароль к базе будет <<pass>>. Запуск образа мы обсуждали в \footurl{прошлой книге о Clojure}{\urlcljbook}[Clojure на производстве], а именно в четвертой и седьмой главах. В случае трудностей изучите примеры оттуда.

Если все настроено правильно и вы увидели результат запроса, примите поздравления. Первый этап пройден, и вы готовы двигаться дальше.

\section{Основы clojure.java.jdbc}

Библиотека предлагает несколько функций для работы с базой. Рассмотрим наиболее важные из них.

\subsection{Чтение}

Чаще всего в коде используют \code{query}~--- функцию, которая выполняет запрос и возвращает результат. Она принимает jdbc-спеку и запрос. Последний может быть либо строкой:

\begin{english}
  \begin{clojure}
(jdbc/query db "select * from users")
  \end{clojure}
\end{english}

\noindent
, либо вектором, где первый элемент~--- запрос с подстановками, а остальные элементы~--- параметры. Подобную запись называют SQL-вектором.

\begin{english}
  \begin{clojure}
(jdbc/query db
            ["select * from users where id = ?" 1])
  \end{clojure}
\end{english}

Знаки вопроса означают подстановку; позже параметры становятся на их место. Ниже мы узнаем, в чем разница между значением в запросе и параметром. Кроме запроса, \code{query} принимает необязательный параметр, который указывает, как обработать результат. Эти тонкости мы тоже обсудим позже.

Функция \code{get-by-id} предлагает доступ к записи по первичному ключу. Она ожидает имя таблицы и значение ключа. Если в таблице \code{users} первичный ключ называется \code{id}, то, чтобы получить первого пользователя, выполним:

\begin{english}
  \begin{clojure}
(jdbc/get-by-id db :users 1)

{:id 1 :fname "John" :lname "Smith"
 :email "test@test.com" :age 25}
  \end{clojure}
\end{english}

Функция вернет либо одну запись, либо \code{nil}. Это важное отличие от \code{query}, результат которой всегда коллекция, в том числе для одной записи.

По умолчанию \code{get-by-id} считает, что первичный ключ называется \code{id}. Если это не так, укажите  его имя после значения:

\begin{english}
  \begin{clojure}
(jdbc/get-by-id db :users 1 "account_id")
  \end{clojure}
\end{english}

Функция \code{find-by-keys} выполняет отбор по нескольким полям. Предположим, мы хотим выбрать пользователей с именем John и возрастом 25 лет. Для этого укажем в \code{find-by-keys} имя таблицы и словарь вида \{поле \arr значение\}:

\begin{english}
  \begin{clojure}
(jdbc/find-by-keys db :users {:fname "John" :age 25})
  \end{clojure}
\end{english}

База выполнит запрос:

\begin{english}
  \begin{sql}
SELECT * FROM users WHERE fname = $1 AND age = $2
parameters: $1 = 'John', $2 = '25'
  \end{sql}
\end{english}

Функция принимает любое число полей в словаре. Они соединяются оператором \code{AND}, потому что это наиболее частый случай. Для более тонкого отбора, например с помощью \code{OR}, функция не подойдет. Позже мы рассмотрим, как строить такие запросы.

Заметим, что \code{find-by-keys} вернет список, даже если нашлась только одна запись. В некоторых случаях мы намеренно ищем только первую. Заведем функцию \code{find-first} с теми же аргументами, которая оборачивает результат в \code{first}.

\begin{english}
  \begin{clojure}
(defn find-first [db table filters]
  (first (jdbc/find-by-keys db table filters)))
  \end{clojure}
\end{english}

В этом случае результат будет либо первой записью, либо \code{nil}:

\begin{english}
  \begin{clojure}
(find-first db :users {:fname "John" :age 25})

{:id 1 :fname "John" :lname "Smith"
 :email "test@test.com" :age 25}
  \end{clojure}
\end{english}

Это не оптимальное решение, потому что запрос к базе не содержит оператора \code{limit 1}. Без него база вернет все записи, лишние из которых отбрасываются на стороне Clojure. Измените \code{find-first} так, чтобы база возвращала одну запись силами SQL.

\subsection{Вставка}

Функция \code{insert!} добавляет запись в таблицу. Восклицательный знак на конце означает, что вызов влечет побочный эффект. \code{Insert!} принимает таблицу, в которую происходит запись. Значения могут быть переданы в разном виде. Наиболее частый сценарий~--- словарь вида \{поле \arr значение\}, например:

\begin{english}
  \begin{clojure}
(jdbc/insert! db :users
              {:fname "Ivan"
               :lname "Petrov"
               :email "ivan@test.com"
               :age 87})
  \end{clojure}
\end{english}

Во втором варианте функция принимает списки полей и значений по отдельности. Их длины должны быть равны:

\begin{english}
  \begin{clojure}
(jdbc/insert! db :users
              [:fname :lname :email :age]
              ["Andy" "Stone" "andy@test.com" 33])
  \end{clojure}
\end{english}

Оба вызова сводятся к подобному запросу:

\begin{english}
  \begin{sql}
INSERT INTO users ( fname, lname, email, age )
VALUES ( $1, $2, $3, $4 )
parameters:
  $1 = 'Andy', $2 = 'Stone',
  $3 = 'andy@test.com', $4 = '33'
  \end{sql}
\end{english}

Результат \code{insert!} отличается от типа базы. Большинство баз отвечает на \code{INSERT} списком первичных ключей, которые появились в результате вставки. Имена ключей тоже отличаются. MySQL вернет набор записей с полем \code{generated\_key}. PostgreSQL вернет запись целиком из-за оператора \code{RETURNING *}. Драйвер JDBC добавит его в конец запроса автоматически.

Хотя \code{insert!} работает только с одной записью, он не оборачивает результат в \code{first}. В итоге вы получите список с одним словарем. Если новый ключ нужен для дальнейших действий, добраться до него можно так:

\begin{english}
  \begin{clojure}
(let [get-pk
      (some-fn :id :generated_key)

      fields
      {:fname "Ivan"
       :lname "Petrov"
       :email "ivan@test.com"
       :age 87}

      db-result
      (jdbc/insert! db :users fields)]

  (-> db-result first get-pk))

;; 199
  \end{clojure}
\end{english}

\subsection{Обновление}

Функция \code{update!} обновляет таблицу. Она принимает JDBC-спеку, имя таблицы, словарь полей и выражение \code{WHERE}. Рассмотрим пример:

\begin{english}
  \begin{clojure}
(jdbc/update! db :users {:age 50} ["id = ?" 7])
  \end{clojure}
\end{english}

Словарь \code{\{:age 50\}} означает новые значения полей. Их может быть больше одного, например, вместе с возрастом мы обновляем имя и почту. Последний параметр функции~--- SQL-вектор, который будет добавлен к запросу после оператора \code{WHERE}. В примере выше \code{update!} порождает следующий запрос:

\begin{english}
  \begin{sql}
UPDATE users SET age = $1 WHERE id = $2
parameters: $1 = '50', $2 = '7'
  \end{sql}
\end{english}

В векторе может быть несколько условий, соединенных с помощью \code{AND} или \code{OR}:

\begin{english}
  \begin{clojure}
(jdbc/update! db :users
              {:email "test@test.com"}
              ["id = ? OR id = ?" 1 3])
  \end{clojure}
\end{english}

\noindent
Что равнозначно:

\begin{english}
  \begin{sql}
UPDATE users SET email = $1
WHERE id = $2 OR id = $3
parameters:
  $1 = 'test@test.com', $2 = '1', $3 = '3'
  \end{sql}
\end{english}

SQL-вектор для \code{WHERE} обязательный: функцию нельзя вызвать без условия. Возникает вопрос, как выполнить \code{UPDATE} для всей таблицы? Для этого передают вектор \code{["true"]}, что означает истину для каждой записи.

Предположим, в таблице пользователей создали колонку с признаком активности:

\begin{english}
  \begin{sql}
ALTER TABLE users
ADD COLUMN is_active BOOLEAN DEFAULT false;
  \end{sql}
\end{english}

Чтобы выставить истину всем пользователям, выполним:

\begin{english}
  \begin{clojure}
(jdbc/update! db
              :users
              {:is_active true}
              ["true"])
  \end{clojure}
\end{english}

Что равносильно:

\begin{english}
  \begin{sql}
UPDATE users SET is_active = $1 WHERE true
parameters: $1 = 't'
  \end{sql}
\end{english}

Функция \code{update!} возвращает список с одним числом. Оно означает число записей, которые были обновлены. Полезно добавить это число в лог:

\begin{english}
  \begin{clojure}
(let [[num-updated]
      (jdbc/update! db :users
                    {:is_active true} ["true"])]
  (log/infof "%s record(s) updated" num-updated))

;; ... 09:47:19 INFO  my.module - 11 record(s) updated
  \end{clojure}
\end{english}

\subsection{Удаление}

Функция \code{delete!} удаляет записи из таблицы. Ее сигнатура похожа на \code{update!}: параметры подключения, имя таблицы и часть \code{WHERE}. Вот как удалить пользователей старше 50 лет:

\begin{english}
  \begin{clojure}
(jdbc/delete! db :users ["age >= ?" 50])
  \end{clojure}
\end{english}

Итоговый запрос:

\begin{english}
  \begin{sql}
DELETE FROM users WHERE age >= $1
parameters: $1 = '50'
  \end{sql}
\end{english}

По аналогии с \code{update!}, в \code{WHERE} могут быть сложные условия с \code{AND} или \code{OR}. Результат функции~--- число удаленных записей.

\subsection{Выполнение}

Еще одна важная функция называется \code{execute!}. Она выполняет любой запрос, отличный от \code{SELECT}. Особенность \code{SELECT} в том, что он возвращает результат, который нужно прочитать и обработать. Функция \code{execute!}, напротив, выполняет команду без чтения результата.

На роль команды без результата подходит создание индекса. Добавим индекс в таблицу пользователей по имени:

\begin{english}
  \begin{clojure}
(jdbc/execute! db
  "CREATE INDEX users_fname ON users(fname);")
  \end{clojure}
\end{english}

Затем удалим его:

\begin{english}
  \begin{clojure}
(jdbc/execute! db "DROP INDEX users_fname;")
  \end{clojure}
\end{english}

Другой пример~--- очистить таблицы после прогона тестов. Специальная команда \code{TRUNCATE} делает это эффективней \code{DELETE}. Она принимает несколько таблиц за раз и поддерживает каскадную очистку: все таблицы, что ссылаются на указанные, тоже очищаются.

\begin{english}
  \begin{clojure}
(jdbc/execute! db "TRUNCATE users CASCADE;")
  \end{clojure}
\end{english}

Еще один сценарий для \code{execute!}~--- временно отключить триггеры на время тестов или миграций. Предположим, мы добавили триггер на обновление пользователей. Чтобы не вызывать его в тестах, напишем фикстуру \code{:once}, которая отключит триггер перед прогоном:

\begin{english}
  \begin{clojure}
(jdbc/execute! db
  "ALTER TABLE users DISABLE TRIGGER on_users_update")
  \end{clojure}
\end{english}

Позже триггер включают такой же командой с параметром \code{ENABLE}.

\subsection{Практика}

Выше мы разобрали базовые CRUD-операции (Create, Read, Update, Delete) и служебную функцию \code{execute!}. Вместе они покрывают б\'{о}льшую часть задач, которые ждут вас на производстве. Перед тем как идти вперед, отложите книгу и позанимайтесь, чтобы закрепить знания.

Создайте проект и подключите к нему библиотеку \code{clojure.java.jdbc}. Настройте локальную базу данных (в Docker или нативно) и подключитесь к ней. Создайте простую таблицу и опробуйте изученные действия: вставку, выборку, поиск, обновление, удаление. Добавьте индекс на некоторые поля. Проделайте все из Clojure, не прибегая к утилитам вроде DBeaver или другими.

\section{Подробнее о запросах}

Выше мы упоминали, что функция \code{query} принимает либо строку запроса, либо вектор с параметрами. Разберемся, в чем разница между ними.

Представим, нужно найти пользователя по известному \code{id}, например 13. Приведем варианты со строкой и вектором. В первом выражении значение 13 <<вшито>> в запрос, а во втором выступает параметром.

\begin{english}
  \begin{clojure}
(jdbc/query db "select * from users where id = 13")

(jdbc/query db ["select * from users where id = ?" 13])
  \end{clojure}
\end{english}

\textbf{Строгое правило:} если запрос зависит от внешних условий, используйте второй вариант с параметром. Подставлять значение в строку функциями \code{format} или \code{str} считается грубой ошибкой и влечет риски. На это есть две причины: SQL-инъекции и подготовленные выражения. Обе важны и нуждаются в объяснении.

\subsection{SQL-инъекции}

Инъекцией называют случай, когда в запрос попадает вредоносный текст. Это возможно при ручной подстановке параметров. Пик инъекций пришелся на середину нулевых годов в эпоху расцвета PHP. Язык резко сократил порог входа в веб-разработку, и ей занялись в том числе те, кто не имел представлений о безопасности. В PHP типичный запрос выглядит так (пример взят из реального проекта):

\begin{english}
  \begin{php}
$user_id = 13;
$query = sprintf(
  "SELECT * FROM users WHERE id = %s", $user_id
);
$result = mysql_query($query);
  \end{php}
\end{english}

Разберемся, в чем проблема с выражением выше. Для начала перепишем его на Clojure:

\begin{english}
  \begin{clojure}
(def user-id 13)

(jdbc/query db
  (format "select * from users where id = %s" user-id))
  \end{clojure}
\end{english}

До тех пор, пока в \code{user-id} находится число, запрос работает без ошибок. Но что если параметр приходит из адресной строки браузера? Предположим, кто-то исправил URL следующим образом:

\begin{english}
  \begin{text}
http://site.com/users?user-id=13+OR+TRUE
  \end{text}
\end{english}

Хакер понимает, что перед 13 идет выражение \code{WHERE id = ...}. Идея в том, чтобы через оператор \code{OR} добавить условие, которое истинно всегда, например TRUE или 1=1. Из-за этого, даже если первое выражение ложно, второе будет истиной. Оператор OR сделает выбор в пользу второго, и запись попадет в выборку. В результате база вернет все записи таблицы без фильтра по \code{id}. Так вы раскроете чужие данные.

Изменим \code{user-id} на вредоносную строку и выполним запрос с форматированием. Получим все записи таблицы \code{users}:

\begin{english}
  \begin{clojure}
(def user-id "13 OR TRUE")

(jdbc/query db
  (format "select * from users where id = %s" user-id))

;; ({:id 1, ...}, {:id 2, ...}, ...)
  \end{clojure}
\end{english}

\def\urlxkcdsql{https://xkcd.com/327/}

В интернете популярен \footurl{комикс Xkcd}{\urlxkcdsql}[Exploits of a Mom] об SQL-инъекциях. Учитель спрашивает родителя, почему они назвали сына \code{Robert'; DROP TABLE students;}. Легко догадаться, что на сервере был следующий код:

\begin{english}
  \begin{clojure}
(let [fname
      (get params :name) ;; "Robert"

      query
      (str "SELECT * FROM users WHERE fname = '"
           fname
           "'")]

  (jdbc/query db query))

;; SELECT * FROM users WHERE fname = 'Robert';
  \end{clojure}
\end{english}

Если задать переменной \code{fname} то, что вписал в поле Роберт:

\begin{english}
  \begin{clojure}
(let [fname "Robert'; DROP TABLE users;--"]
  ...)
  \end{clojure}
\end{english}

\noindent
, запрос примет вид:

\begin{english}
  \begin{sql}
SELECT ... WHERE fname = 'Robert'; DROP TABLE users;--'
  \end{sql}
\end{english}

Обратите внимание на двойной минус в конце. Он нужен для того, чтобы закомментировать последнюю одинарную кавычку. База данных отбросит ее и получит два запроса через точку с запятой. Если выполнить их, сработает поиск по имени Robert, а затем таблица \code{users} будет удалена. Опробуйте трюк на локальной базе.

\subsection{Атаки UNION}

Задача хакера не в том, чтобы удалить данные~--- их легко восстановить из резервной копии. Его цель~--- заполучить данные, к которым нет доступа. Рассмотрим тот же пример с поиском пользователя. На этот раз вместо \code{DROP TABLE} мы напишем другой вредоносный SQL, а именно объединение запроса с таким же, но без отбора. Для этого служит оператор \code{UNION}:

\begin{english}
  \begin{clojure}
(let [fname
      "Robert' UNION select * from users--"
      query
      (str "SELECT * FROM users WHERE fname = '"
           fname
           "'")]
  (jdbc/query db query))
  \end{clojure}
\end{english}

Результат:

\begin{english}
  \begin{sql}
SELECT * FROM users WHERE fname = 'Robert'
UNION
SELECT * FROM users--'
  \end{sql}
\end{english}

Этот запрос вернет всех пользователей независимо от того, сколько их нашлось в первой части. Конечно, для подобных атак нужно знать структуру таблицы. Но даже структуру можно получить SQL-инъекцией, добавив \code{UNION} с таблицами \code{information\_schema.tables}, \code{pg\_user} и другими. Таблицы из схемы \code{information\_schema} хранят метаданные о других таблицах: их имена, состав и типы колонок. Если хакер доберется до них через инъекции, он узнает о базе все.

\subsection{Кавычки}

Даже если переменная приходит от надежного источника, вы не застрахованы от проблем с кавычками. Предположим, библиотекарь вносит в программу книгу <<Д’Артаньян и три мушкетёра>>. На клавиатуре нет знака апострофа, поэтому после буквы Д сотрудник поставит верхнюю одинарную кавычку. В большинстве баз данных она служит для строковых литералов. При форматировании такой строки вы получите ошибку синтаксиса:

%% \begin{english}
  \begin{clojure}
(def book "Д'Артаньян и три мушкетёра")

(def sql
  (format "insert into books (title) values ('%s')"
          book))

;; insert into books (title) values
;; ('Д'Артаньян и три мушкетёра')
  \end{clojure}
%% \end{english}

С точки зрения SQL название книги кончается после <<Д>>, и дальше идет что-то ошибочное.

Подстановка параметров нивелирует эти угрозы. Прежде всего JDBC следит за их типом. Если мы ожидаем поиск по числовому ID, то при передаче строки получим ошибку, даже если строка содержит цифру. При этом ошибка возникнет до того, как запрос уйдет в базу:

\begin{english}
  \begin{clojure}
(jdbc/query db ["select * from users where id = ?" "1"])
;; ERROR: operator does not exist: integer = character
  \end{clojure}
\end{english}

При подстановке строки драйвер экранирует опасные символы. В PostgreSQL для этого служит одинарная кавычка. Вот как безопасно выбрать из базы всех Д'Артаньянов (обратите внимание на двойную кавычку в параметре \code{\$1}, строка 5):

%% \begin{english}
  \begin{clojure/lines}
(jdbc/query db
  ["SELECT * FROM users WHERE fname = ?" "Д'Артаньян"])

;; SELECT * FROM users WHERE fname = $1
;; parameters: $1 = 'Д''Артаньян'
  \end{clojure/lines}
%% \end{english}

Параметры доступны не в любом месте запроса. Например, нельзя задать параметром имя таблицы или состав полей. Запрос ниже не сработает из-за ошибки синтаксиса:

\begin{english}
  \begin{clojure}
(jdbc/query db ["select * from ?" "users"])
  \end{clojure}
\end{english}

А если вы хотите задать имена полей параметрами, то вас ждет разочарование:

\begin{english}
  \begin{clojure}
(jdbc/query db
  ["select ?, ?, ? from users" "id" "fname" "email"])
  \end{clojure}
\end{english}

Запрос вернет строки <<id>>, <<fname>> и <<email>>, а не значения одноименных полей. Чтобы строить запросы, где таблицы и поля зависят от условий, прибегают к специальным библиотекам. Позже мы рассмотрим наиболее популярные из них.

\subsection{Подготовленные выражения}

Вторая причина в пользу параметров состоит в том, что база получит выигрыш в скорости. Следует помнить, что даже простой запрос выполняется поэтапно. Процесс напоминает компиляцию языков программирования: база разбирает выражение на лексемы и строит дерево. Так, строка \code{3 + 2 * 2} после разбора станет списком \code{(+ 3 (* 2 2))}, который проще выполнить благодаря структуре.

База данных тоже выполняет разбор и анализ запроса. На выходе получается так называемое Prepared Statement, подготовленное выражение. Это объектное представление запроса, который прошел анализ и теперь может быть выполнен. Предположим, поступил запрос на поиск пользователя по \code{id}:

\begin{english}
  \begin{sql}
SELECT * FROM users WHERE id = 1
  \end{sql}
\end{english}

Схематично представим его в виде дерева на Clojure:

\begin{english}
  \begin{clojure}
{:type :select
 :tables [:users]
 :fields [:id :fname :lname :email :age]
 :where [[:= :id ?]]
 :params [:integer]}
  \end{clojure}
\end{english}

Смысловые части запроса разложены по полям. Обратите внимание, что вместо звёздочки следует явный список полей. Известно число параметров и их тип. Осталось вызвать подготовленное выражение с конкретным ID, чтобы получить результат.

Из структуры выше понятно, почему таблица не может быть параметром. Если бы она менялась динамически, пришлось бы каждый раз вычислять набор полей и их тип, что рушит идею Prepared Statement~--- сделать это один раз. Наоборот, подстановка чисел 5, 15 или 99 на место \code{id} не влечет перестройку выражения.

Покажем, как работать с подготовленными выражениями в Clojure. Чтобы создать его, вызывают функцию \code{jdbc/prepare-statement}. Первым параметром она ожидает открытое TCP-соединение с базой. Соединение получают функцией \code{jdbc/get-connection} из JDBC-спеки:

\begin{english}
  \begin{clojure/lines}
(def conn
  (jdbc/get-connection db))

(def prep-stmt
  (jdbc/prepare-statement conn
    "SELECT * FROM users WHERE id = ?"))
  \end{clojure/lines}
\end{english}

Второй аргумент \code{jdbc/prepare-statement}~--- произвольный запрос со знаками вопроса на месте параметров. В переменной \code{prep-stmt} окажется объект с типом \code{PreparedStatement} \coderef{4}. Чтобы выполнить его, передайте в \code{jdbc/query} вектор, где первый элемент~--- подготовленное выражение:

\begin{english}
  \begin{clojure}
(jdbc/query db [prep-stmt 1])
  \end{clojure}
\end{english}

По аналогии напишем выражение для вставки пользователя. Выполним его через \code{execute!}:

\begin{english}
  \begin{clojure}
(def stmt-insert
  (jdbc/prepare-statement conn
    "INSERT INTO users (fname, lname, age, email)
     VALUES (?, ?, ?, ?)"))

(jdbc/execute! db
  [stmt-insert "John" "Smith" 20 "john@test.com"])
;; (1)
  \end{clojure}
\end{english}

Подготовленные выражения несут состояние, поэтому их нельзя объявлять на верхнем уровне модуля. Выражения адаптируют под систему, на которой основан проект. Если это Component, объявляют компонент, который зависит от базы. При запуске компонент создает выражения и записывает их в слоты, а в момент остановки закрывает их.

Напишем подобный компонент. Для экономии места подготовим только одно выражение для поиска пользователя по номеру:

\begin{english}
  \begin{clojure}
(defrecord UserManager
    [db
     conn
     stmt-get-by-id]

  component/Lifecycle

  (start [this]
    (let [conn
          (jdbc/get-connection db)

          stmt-get-by-id
          (jdbc/prepare-statement conn
            "SELECT * FROM users WHERE id = ?")]

      (assoc this
             :conn conn
             :stmt-get-by-id stmt-get-by-id)))

  (stop [this]
    (.close conn)
    (.close stmt-get-by-id)))
  \end{clojure}
\end{english}

Добавим протокол для действий с пользователями. Пока что в нем один метод поиска по ID:

\begin{english}
  \begin{clojure}
(defprotocol IUserManager

  (get-by-id [this id]))
  \end{clojure}
\end{english}

Расширим тип \code{UserManager} этим протоколом. В теле \code{get-by-id} вызываем функцию \code{jdbc/query}, при этом соединение и подготовленное выражение приходят из слотов записи.

\begin{english}
  \begin{clojure}
IUserManager

(get-by-id [this id]
  (first
    (jdbc/query conn [stmt-get-by-id id])))
  \end{clojure}
\end{english}

Компонент в действии:

\begin{english}
  \begin{clojure}
(def user-mgr
  (-> {:db db}
      map->UserManager
      component/start))

(get-by-id user-mgr 1) ;; {:id 1, ...}
(get-by-id user-mgr 2) ;; {:id 2, ...}
  \end{clojure}
\end{english}

Запросы, выполненные через подготовленные выражения, работают быстрее обычных, потому что не требуют разбора. В нагруженных проектах подход может оказаться полезным.

\section{Результат запроса}

Рассмотрим, что предлагает JDBC для работы с ответом. По умолчанию функция \code{query} возвращает последовательность словарей. Структура каждого словаря одинакова: его ключи~--- поля выборки, приведенные к типу \code{Keyword}, а значения~--- то, что пришло для этого поля из базы. Запрос пользователей:

\begin{english}
  \begin{clojure}
(jdbc/query db "select * from users")
  \end{clojure}
\end{english}

Результат:

\begin{english}
  \begin{clojure}
({:id 1
  :fname "Ivan"
  :lname "Petrov"
  :email "test@test.com"
  :age 42}

 {:id 2
  :fname "John"
  :lname "Smith"
  :email "john@test.com"
  :age 20})
  \end{clojure}
\end{english}

Напомним, в Java разультат запроса читают из объекта \code{ResultSet}. Функция \code{jdbc/query} делает это за нас: она приводит \code{ResultSet} к ленивой коллекции "кложурных" значений. Поскольку список словарей~--- наиболее удобная структура, именно этот способ задан по умолчанию. В особых случаях поведение \code{query} меняют так, чтобы получить данные в другом виде. Прежде чем мы узнаем, как это сделать, вспомним, как устроен объект \code{ResultSet}.

Он напоминает источник данных со внутренним указателем. По умолчанию указатель находится \emph{до} первого элемента. У \code{ResultSet} несколько методов, чтобы сдвигать его, но самый простой называется \code{.next()}. Результат означает, удался ли сдвиг или нет (если достигли конца, получим ложь). Обход \code{ResultSet} сводится к шаблону:

\begin{english}
  \begin{clojure}
(while (.next rs)
  (println (.getInt rs "id"))
  (println (.getString rs "fname")))
  \end{clojure}
\end{english}

Методы \code{getInt}, \code{getString} и другие вернут значения поля по его имени (если вызваны со строкой) или индексу (с числом).

Поскольку указатель стоит \emph{до} первого элемента, начальный вызов \code{.next} сдвигает его на первый. Это существенно упрощает код. Если бы указатель был на первом элементе, пришлось бы обработать его до входа в цикл, а затем скопировать тот же код в цикл, что выглядит неуклюже:

\begin{english}
  \begin{clojure}
(println (.getInt rs "id"))
(println (.getString rs "fname"))

(while (.next rs)
  (println (.getInt rs "id"))
  (println (.getString rs "fname")))
  \end{clojure}
\end{english}

Методы \code{getInt} и \code{getString} выше говорят о том, что мы знаем структуру ответа заранее. Это не всегда так. В случае с произвольным запросом нельзя утверждать, что поле \code{id} числовое (и есть ли оно вообще). Данные о полях получают из объекта \code{ResultSetMetaData}. Он возвращает состав полей, их имена и типы. На базе того устроена функция, которая принимает \code{ResultSet} и приводит его к списку словарей.

Модуль \code{clojure.core} содержит функцию \code{resultset-seq}, чтобы привести \code{ResultSet} к ленивой цепочке словарей. С ней обход выборки становится более <<кложурным>>:

\begin{english}
  \begin{clojure}
(doseq [row (resultset-seq ^ResultSet rs)]
  (let [{:keys [id email]} row]
    (println "id" id "email" email)))
  \end{clojure}
\end{english}

По умолчанию \code{query} прогоняет ленивую выборку через \code{doall}. В результате все элементы \code{ResultSet} будут прочитаны. В зависимости от логики его чтением можно управлять, например делать это отложено. При таком подходе требуется ручное закрытие объекта \code{ResultSet}. О ленивости и ее влиянии на результат мы скажем чуть позже.

Теперь когда мы знакомы с \code{ResultSet}, рассмотрим, в каком еще виде можно читать данные из базы.

\subsection{Массивы}

Список словарей удобен, но иногда требуется список векторов, например:

\begin{english}
  \begin{clojure}
[[1 "Ivan" "Petrov" "test@test.com"]
 [2 "Ivan" "Petrov" "ivan@test.com"]
 [3 "John" "Smith" "john@test.com"]]
  \end{clojure}
\end{english}

Такая структура полезна для CSV-файлов. Их формат известен заранее, поэтому заголовок указывают однажды в начале файла. Библиотеки для записи CSV ожидают именно такую структуру данных. Если мы выбрали из базы словари, нужно привести их к вектору, что означает лишнюю работу. Будет лучше, если функция \code{query} сделает это за нас.

Параметр \code{\{:as-arrays? true\}} в \code{query} означает, что элементы списка будут векторами. Первый ряд содержит имена колонок:

\begin{english}
  \begin{clojure}
(jdbc/query db "select * from users" {:as-arrays? true})

[[:id :fname :lname :email :age]
 [1 "Ivan" "Petrov" "test@test.com" 42]
 [2 "Ivan" "Petrov" "ivan@test.com" 87]
 [3 "John" "Smith" "john@test.com" 20]]
  \end{clojure}
\end{english}

Предположим, мы хотим выгрузить пользователей в файл CSV. Для этого используем библиотеку \code{clojure.data.csv} и стандартный модуль IO:

\begin{english}
  \begin{clojure}
;; [clojure.data.csv :as csv]
;; [clojure.java.io :as io]

(with-open [writer (io/writer "users.csv")]
  (->> (jdbc/query db
                   "SELECT * FROM users"
                   {:as-arrays? true})
       (csv/write-csv writer)))
  \end{clojure}
\end{english}

В папке проекта вы найдете файл \code{users.csv}. Проверьте содержимое в табличном редакторе. Напишите функцию для выгрузки любой таблицы. Она принимает ее имя, путь к CSV-файлу и, по желанию, набор полей на тот случай, если нужны только некоторые из них.

Список векторов полезен не только для CSV. Его применяют в работе с матрицами и статистикой.

\subsection{Ключи}

По умолчанию JDBC приводит имена полей к типу \code{Keyword}. Если в выборке было поле \code{user\_name}, в словаре окажется ключ \code{:user\_name}. Это именно то, что нужно в большинстве случаев, поскольку Clojure поощряет кейворды. Но и здесь порой нужна тонкая настройка.

Параметр \code{\{:keywordize? false\}} означает, нужно ли приводить поля к кейвордам. По умолчанию он истина, но если передать ложь, получим строки:

\begin{english}
  \begin{clojure}
(jdbc/query db "select * from users"
               {:keywordize? false})

({"id" 1
  "fname" "Ivan"
  "lname" "Petrov"
  "email" "test@test.com"
  "age" 42}
 {"id" 3
  "fname" "John"
  "lname" "Smith"
  "email" "john@test.com"
  "age" 20})
  \end{clojure}
\end{english}

Параметр удобно использовать в паре с \code{\{:as-arrays? true\}}. С ним имена таблиц станут строками, и в заголовке CSV-файла не будет двоеточий.

В поле \code{:identifiers} передают функцию для обработки имени поля. По умолчанию используется \code{clojure.string/lower-case}, то есть приведение к нижнему регистру. С ним поле \code{"VAL"} становится \code{:val}:

\begin{english}
  \begin{clojure}
(jdbc/query db "SELECT 1 AS VAL")
;; ({:val 1})
  \end{clojure}
\end{english}

Вы можете передать функцию, которая оставляет регистр прежним или заменяет подчеркивание на дефис, чтобы получить \code{:user-name} из \code{"user\_name"}.

Параметр \code{:qualifier} задает пространство полям выборки. Например, когда выбирают пользователей, удобно назначить им пространство \code{:user}, чтобы позже не перепутать с другими сущностями:

\begin{english}
  \begin{clojure}
(first (jdbc/query db "SELECT * FROM users"
                      {:qualifier "user"}))

{:user/id 2
 :user/fname "Ivan"
 :user/lname "Petrov"
 :user/email "ivan@test.com"
 :user/age 87}
  \end{clojure}
\end{english}

Из того, что JDBC преобразует ключи к кейвордам, можно извлечь пользу. Когда в запросе участвует несколько таблиц с оператором \code{JOIN}, в результат попадают разные сущности. Чтобы не перепутать поля, их наделяют префиксом, например \code{user\_} для пользователя и \code{profile\_} для профиля:

\begin{english}
  \begin{sql}
SELECT
  u.id     AS user_id,
  u.fname  AS user_fname,
  u.lname  AS user_lname,
  p.avatar AS profile_avatar
FROM users u
JOIN profiles p ON p.user_id = u.id;
  \end{sql}
\end{english}

Работать с такими ключами в Clojure неудобно. Вместо префикса и подчеркиваний мы ожидаем пространства и дефис. Если назначить полям псевдонимы <<сущность/поле>>, получим нужные ключи. Псевдоним с косой чертой нужно взять в двойные кавычки, чтобы не нарушить синтаксис SQL:

\begin{english}
  \begin{sql}
SELECT
  u.id     AS "user/id",
  u.fname  AS "user/fname",
  u.lname  AS "user/lname",
  p.avatar AS "profile/avatar"
FROM users u
JOIN profiles p ON p.user_id = u.id;
  \end{sql}
\end{english}

Вывод psql:

\begin{english}
  \begin{text}
 user/id | user/fname | user/lname | profile/avatar
---------+------------+------------+----------------
       1 | Ivan       | Petrov     | kitten.jpg
  \end{text}
\end{english}

Если передать запрос в \code{jdbc/query}, получим удобные ключи:

\begin{english}
  \begin{clojure}
({:user/id 1
  :user/fname "Ivan"
  :user/lname "Petrov"
  :profile/avatar "kitten.jpg"})
  \end{clojure}
\end{english}

Однако писать псевдонимы для каждого поля долго. К тому же приходится экранировать двойные кавычки, чтобы не вызвать ошибку синтаксиса. В результате запрос выглядит шумно и занимает много места:

\begin{english}
  \begin{clojure}
(jdbc/query db "
select
u.id as \"user/id\",
u.fname as \"user/fname\",
...
")
  \end{clojure}
\end{english}

Ниже мы узнаем, как исправить эти недостатки.

\subsection{Ленивость}

По умолчанию результат \code{jdbc/query} не ленив, то есть полностью вычислен (<<realized>> в терминах Clojure). Он не зависит от соединения с базой и объекта \code{ResultSet}. Говоря точнее, из \code{ResultSet} получают ленивую последовательность, которая позже вычисляется с помощью \code{doall} (для списка словарей) или \code{vec} (когда \code{:as-arrays?} истина).

Ключ \code{:result-set-fn} определяет, что именно будет предпринято с ленивой коллекцией до того, как она вычислена. По умолчанию это функция \code{doall} или \code{vec} в зависимости от параметров. Предположим теперь, мы хотим получить истинно ленивую выборку. Укажем в поле \code{:result-set-fn} функцию \code{identity}. Однако с ней запрос бросит исключение:

\begin{english}
  \begin{clojure}
(jdbc/query db "SELECT * FROM users"
               {:result-set-fn identity})

Error printing return value (PSQLException) at ...
This ResultSet is closed.
  \end{clojure}
\end{english}

Оно возникло потому, что после запроса объект \code{ResultSet} закрывается. При печати коллекции в REPL мы читаем данные из \code{ResultSet} после его закрытия, что приводит к ошибке.

Функция \code{:result-set-fn} полезна в случаях, когда нужно обработать элементы по одному, не дожидаясь всего ответа. Часто это связано с операциями ввода-вывода. Представим, нужно записать выборку в файл. Будет неэффективно выгружать данные в память и затем в файл~--- гораздо лучше читать записи по одной и сразу записывать. Даже если записей миллионы, мы не израсходуем память компьютера.

\begin{english}
  \begin{clojure}
(defn process-rows [rows]
  (with-open [writer (io/writer "users.csv")]
    (csv/write-csv writer rows)))

(jdbc/query db "SELECT * FROM users"
               {:as-arrays? true
               :keywordize? false
               :result-set-fn process-rows})
  \end{clojure}
\end{english}

Выше мы записываем ленивую коллекцию \code{rows} в файл, не дожидаясь чтения всего ответа. Подход оправдывает себя на больших выборках.

В редких случаях вам понадобится ручная работа с \code{ResultSet}. Доступ к нему предлагает функция \code{jdbc/db-query-with-re\-sult\-set}. Ее последний параметр~--- функция, которая принимает \code{ResultSet}. Делайте с ним что угодно, но помните: после выхода из функции он будет закрыт.

Работа с \code{ResultSet} сводится к итерации \code{(while (.next ...))} и чтению полей. Этот метод эффективней \code{result-set-fn}, потому что не производит ленивую коллекцию, которая потребляет ресурсы.

\begin{english}
  \begin{clojure}
(jdbc/db-query-with-resultset
 db "select * from users"
 (fn [^ResultSet rs]
   (while (.next rs)
     (let [id (.getInt rs "id")
           fname (.getString rs "fname")
           lname (.getString rs "lname")]
       (println id fname lname)))))
  \end{clojure}
\end{english}

Выше мы просто печатаем данные на экран. На практике мы бы отправили их в сеть, в файл или поток.

\section{Транзакции}

Чтобы изменения в базе были согласованы, нужны транзакции. Транзакция обещает, что в изменения не вмешается кто-то другой, и все они завершатся либо успехом, либо откатом к прежнему состоянию. Исключен нежелательный вариант, когда в базе остались частичные изменения.

Приведем типичные случаи, когда транзакции необходимы. Это может быть сбор денег на проект (краудфандинг). Каждый раз, когда кто-то совершил платеж, итоговая сумма пересчитывается. Если делать это не в транзакции, можно пропустить платеж, который случился при пересчете, и итог будет неверным.

Даже если с базой работает один человек, транзакции обязательны. Представим себе органайзер фотографий. Каждая из них находится в нескольких альбомах, имеет теги, ссылки на места и людей, запись в поисковом индексе. Теперь мы удаляем фотографию. Очистка должна произойти либо во всех таблицах, либо нигде. Представьте, что фотография исчезла из альбома, но осталась в поиске~--- это раздражает.

Технически транзакция означает, что два и более запроса окружены командами \code{BEGIN} и \code{COMMIT}. Приведем сеанс psql со вставкой данных в транзакции. В первый запрос мы добавили оператор \code{RETURNING}, чтобы получить созданный базой первичный ключ. Мы ссылаемся на него во втором запросе.

\begin{english}
  \begin{sql}
BEGIN;
INSERT INTO users (fname, email)
VALUES ('Ivan', 'ivan@test.com') RETURNING id;
-- 59
INSERT INTO profiles (user_id, avatar)
VALUES (59, 'me.jpg');
COMMIT;
  \end{sql}
\end{english}

Если хотя бы один запрос потерпит неудачу, \code{COMMIT} не сработает, и обе таблицы останутся нетронуты.

Рассмотрим, как управлять транзакциями в Clojure. Если выполнить два запроса в лоб:

\begin{english}
  \begin{clojure}
(jdbc/insert! db :users {:fname "Ivan"})
(jdbc/insert! db :users {:fname "Huan"})
  \end{clojure}
\end{english}

\noindent
, увидим в логах PostgreSQL следующие записи:

\begin{english}
  \begin{sql}
BEGIN
INSERT INTO users ( fname ) VALUES ( $1 )
parameters: $1 = 'Ivan'
COMMIT

BEGIN
INSERT INTO users ( fname ) VALUES ( $1 )
parameters: $1 = 'Huan'
COMMIT
  \end{sql}
\end{english}

Каждый запрос оказался в отдельной транзакции, что вовсе не то, что мы ожидали. Чтобы объединить несколько запросов в одну транзакцию, необходимы два условия. Первое~--- запросы должны протекать в рамках одного TCP-соединения. Второе~--- соединение временно меняет параметры и позже восстанавливает их. Рассмотрим сказанное подробней.

По умолчанию JDBC открывает новое соединение на запрос, что неэффективно и не дает управлять транзакциями. Мы должны открыть соединение, начать транзакцию и выполнить в нём все запросы. Код на Clojure должен быть обернут в \code{try/catch}, чтобы в случае исключения выполнить \code{ROLLBACK}. Если не было ошибок, зафиксировать изменения вызовом \code{COMMIT}. В конце закрыть соединение.

Если каждый раз писать всё это вручную, обязательно допустим ошибку. Должна быть единая точка (макрос или функция), которая управляет процессом. Clojure предлагает макрос \code{with-db-transaction}. Он принимает JDBC-спеку, параметры транзакции и произвольный код. Коротко его логику можно описать так:

\begin{itemize}

\item
  получить TCP-соединение из JDBC-спеки.

\item
  Запомнить его параметры \code{autocommit}, \code{readonly} и другие.

\item
  Выставить параметр \code{autocommit=false}.

\item
  Связать соединение с символом из макроса.

\item
  Выполнить тело макроса в блоке \code{let} с этой переменной. Запросы должны использовать новое соединение.

\item
  Если не было исключений, вызвать \code{COMMIT}.

\item
  В блоке \code{catch} вызвать \code{ROLLBACK} и повторно бросить исключение.

\item
  В блоке \code{finally} назначить соединению прежние параметры.

\end{itemize}

Быстрая проверка макроса:

\begin{english}
  \begin{clojure}
(jdbc/with-db-transaction [tx db]
  (jdbc/insert! tx :users {:fname "Ivan"})
  (jdbc/insert! tx :users {:fname "Huan"}))
  \end{clojure}
\end{english}

На этот раз оба запроса окажутся в одной транзакции:

\begin{english}
  \begin{sql}
BEGIN
INSERT INTO users ( fname ) VALUES ( $1 )
parameters: $1 = 'Ivan'

INSERT INTO users ( fname ) VALUES ( $1 )
parameters: $1 = 'Huan'
COMMIT
  \end{sql}
\end{english}

Макрос принимает вектор, от которого ожидают по крайней мере два элемента по принципу \code{let}. Первый символ~--- имя, с которым будет связано соединение с транзакцией. Второй символ указывает на текущую JDBC-спеку. Первым символом обычно указывают \code{tx} или \code{trx}~--- сокращение от <<transaction>>.

Типичная ошибка в работе с макросом~--- открыть транзакцию, но пользоваться прежним соединением \coderef{2}. В этом случае пользы от макроса нет.

\begin{english}
  \begin{clojure/lines}
(jdbc/with-db-transaction [tx db]
  (jdbc/insert! db :users {:fname "Ivan"})
  (jdbc/insert! tx :users {:fname "Huan"}))
  \end{clojure/lines}
\end{english}

Более сложный пример с записью в разные таблицы. Сперва создаем пользователя, затем профиль со ссылкой на него:

\begin{english}
  \begin{clojure}
(jdbc/with-db-transaction [tx db]

  (let [[{user-id :id}]
        (jdbc/insert! tx :users {:fname "Ivan"})

        [{profile-id :id}]
        (jdbc/insert! tx :profiles
                      {:user_id user-id
                       :avatar "cat.jpg"})]

    {:user/id user-id
     :profile/id profile-id}))
  \end{clojure}
\end{english}

Код вернет словарь с ключами новых сущностей. Для ясности мы добавили им пространства.

Третий элемент макроса принимает параметры транзакции. Он может отсутствовать, и тогда сработают параметры по умолчанию. Наиболее интересен ключ \code{:isolation}, уровень изоляции. Он определяет, как управлять данными в параллельных транзакциях, а именно на каком этапе каждой их них видны изменения другой.

Предположим, одновременно открыты две транзакции. Первая изменила запись, но еще не вызвала \code{COMMIT}. Вторая читает эту же запись. Получит ли она исходные данные или с изменениями? Что если первая транзакция вызвала \code{COMMIT}? Должна ли вторая увидеть изменения, ведь на момент \code{BEGIN} их не было?

Уровень изоляции управляет подобными случаями. Современные базы выделяют несколько уровней. Перечислим их по нарастанию безопасности в работе с данными:

\begin{itemize}

\item
  READ UNCOMMITTED

\item
  READ COMMITTED

\item
  REPEATABLE READ

\item
  SERIALIZABLE

\end{itemize}

Первый и нерекомендованный уровень называется READ UNCOMMITTED. С ним транзакции B доступны незавершенные изменения, сделанные в A. Возможно, они подлежат откату, потому полагаться на них будет ошибочно.

Уровень READ COMMITTED означает, что транзакция B получит изменения из А, если они зафиксированы. READ COMMITTED считается достаточным для большинства случаев и установлен по умолчанию в SQL Server и PostgreSQL.

Уровень REPEATABLE READ обеспечивает так называемое повторное чтение. С ним транзакция A запоминает состояние базы на момент BEGIN. Даже если другие транзакции внесли изменения, чтение данных в A вернет их прежнюю версию. Если А меняет записи, обновленные другими транзакциями, произойдет конфликт, и придется выполнить транзакцию повторно или отказаться от нее.

Уровень SERIALIZABLE обеспечивает максимальную безопасность с транзакциями. Когда он включен, база выполняет транзакции так, словно они следуют одна за другой, а не параллельно. Для этого база проверяет, что транзакции A и B дают одинаковый результат независимо от порядка их применения. Другими словами, состояние базы должно быть одинаковым при выполнении A, B и B, A. Если это не так (отличается число записей или их значения), одну из транзакций следует перезапустить.

Сказанное не значит, что нужно всегда выставлять уровень SERIALIZABLE. Хоть он и решает ряд проблем, но замедляет обработку данных. Меняйте уровень изоляции только если четко понимаете, чем вас не устраивает текущий.

\def\urlisolevel{https://en.wikipedia.org/wiki/Isolation\_(database\_systems)}
\def\urlpgproiso{https://postgrespro.ru/docs/postgrespro/13/transaction-iso}
\def\urlpginside{https://dmkpress.com/catalog/computer/databases/978-5-93700-122-2/}

В этой главе мы не рассматриваем изоляцию в деталях. Ее изучение требует примеров с таблицами и параллельными запросами. Тема не касается Clojure, потому что не зависит языка программирования. Для быстрого знакомства прочтите \footurl{статью в Википедии}{\urlisolevel}[Уровень изолированности транзакций]. Еще глубже материал изложен в документации PostgresPro, в том числе \footurl{на русском языке}{\urlpgproiso}[Postgres Pro][3mm]. Самое детальное описание вы найдете в книге Егора Рогова \footurl{<<PostgreSQL изнутри>>}{\urlpginside}[Post\-gre\-SQL изнутри]. Автор горячо рекомендует эту книгу к прочтению.

Разберем, как задать уровень изоляции в Clojure. Макрос \code{with-db-transaction} принимает ключ \code{:isolation}. Его возможные значения~--- следующие кейворды:

\begin{itemize}

\item
  \code{:none}

\item
  \code{:read-committed}

\item
  \code{:read-uncommitted}

\item
  \code{:repeatable-read}

\item
  \code{:serializable}

\end{itemize}

Внутри макроса они становятся константами Java. Пример с уровнем SERIALIZABLE, заданным явно:

\begin{english}
  \begin{clojure}
(jdbc/with-db-transaction
  [tx db {:isolation :serializable}]
  ...)
  \end{clojure}
\end{english}

Если выполнить код, в логах PostgreSQL появятся записи:

\begin{english}
  \begin{sql}
SHOW TRANSACTION ISOLATION LEVEL
SET SESSION CHARACTERISTICS
  AS TRANSACTION ISOLATION LEVEL SERIALIZABLE
BEGIN
...
COMMIT
SET SESSION CHARACTERISTICS
  AS TRANSACTION ISOLATION LEVEL READ COMMITTED
  \end{sql}
\end{english}

Макрос временно заменяет уровень изоляции на указанный. После фиксации транзакции или отката возвращается его прежнее значение. Уровень по умолчанию можно задать в настройках базы данных. В этом случае не придется передавать ключ \code{:isolation} каждый раз.

\section{JDBC-спека с состоянием}

До сих пор мы передавали в функции JDBC словарь без состояния. В этом случае не очевидно кто и когда им управляет. Чтобы код был эффективным, вы должны понимать, что происходит с состоянием на нижнем уровне JDBC.

Под состоянием понимают TCP-соединение, по которому клиент и база обмениваются данными. В словаре ниже соединения нет:

\begin{english}
  \begin{clojure}
(def db {:dbtype "postgresql"
         :dbname "test"
         ...})
  \end{clojure}
\end{english}

Если передать его в функцию \code{query}, произойдет следующее:

\begin{itemize}

\item
  из словаря библиотека построит JDBC URL~--- длинную строку, похожую на адрес страницы в интернете. Для конфигурации выше результат будет примерно таким:

\begin{english}
  \begin{text}
jdbc:postgresql://127.0.0.1:5432/test
  \end{text}
\end{english}

\item
  Из URL получают TCP-соединение. Через него функция \code{query} отправит и получит данные.

\item
  После выполнения \code{query} соединение закрывается.

\end{itemize}

Аналогично устроены функции \code{update!}, \code{delete!} и другие. Все они сводятся к единой точке, где создается соединение, происходит обмен данных, затем оно закрывается.

Открывать соединение на каждый запрос расточительно. Чтобы использовать его повторно, JDBC предлагает макрос \code{with-db-connection}. Он связывает символ с копией спеки, в одном из полей которой находится соединение.

\begin{english}
  \begin{clojure}
(jdbc/with-db-connection [conn db]
  (jdbc/query conn "SELECT 1"))
  \end{clojure}
\end{english}

Макрос добавляет соединение в спеку с ключом \code{:connection}. Функции проверяют этот ключ. Если в нем есть соединение, функция не станет открывать новое. Вместе это работает как кэш. Исследуем переменную \code{conn} и убедимся, что в ней заполнено поле \code{:connection} \coderef{7}:

\begin{english}
  \begin{clojure/lines}
(jdbc/with-db-connection [conn db]
  (print conn))

{:dbtype "postgresql"
 :dbname "test"
 ...
 :connection #object[o.p.jdbc.PgConnection ...]}
  \end{clojure/lines}
\end{english}

Чтобы оценить издержки на соединение с базой, проведем замеры. Выполним простой запрос многократно, в первом случае~--- каждый раз с новым соединением, во втором~--- с одним и тем же:

\begin{english}
  \begin{clojure}
(time (dotimes [_ 1000]
        (jdbc/query db "select 1")))
;; "Elapsed time: 19097 msecs"

(time
 (jdbc/with-db-connection [conn db]
   (dotimes [_ 1000]
     (jdbc/query conn "select 1"))))
;; "Elapsed time:  1680 msecs"
  \end{clojure}
\end{english}

Разница в одиннадцать раз в пользу постоянного соединения. Очевидно, что первый вариант~--- соединение на запрос~--- подойдет только разовым скриптам. Для долгоиграющих систем нужно постоянное соединение. Это подводит нас к JDBC-спеке с состоянием.

Чтобы управлять спекой с минимальными усилиями, обратимся к библиотеке \code{Mount}. Мы познакомились с ней в первой книге в главе про системы. Объявим компонент, который при запуске открывает TCP-соединение и дописывает его в поле \code{:connection} спеки:

\begin{english}
  \begin{clojure}
(require
  '[mount.core :as mount :refer [defstate]])

(defstate DB
  :start
  (assoc db :connection
         (jdbc/get-connection db))
  \end{clojure}
\end{english}

В фазе остановки закрываем соединение и возвращаем спеку без состояния:

\begin{english}
  \begin{clojure}
  :stop
  (let [{:keys [connection]} DB]
    (when connection
      (.close connection))
    db))
  \end{clojure}
\end{english}

Вызовем \code{(mount/start)}, чтобы включить компонент. Теперь каждый запрос к базе использует постоянное соединение, что быстрее:

\begin{english}
  \begin{clojure}
(jdbc/query DB "select 1")
  \end{clojure}
\end{english}

\subsection{Пул соединений}

У открытого соединения есть проблема: его легко потерять. Проведем эксперимент: когда компонент базы включен, перезапустите базу данных. Компонент придет в негодность: при попытке выполнить запрос получим ошибку, что соединение закрыто:

\begin{english}
  \begin{text}
Execution error (PSQLException) at ...
This connection has been closed.
  \end{text}
\end{english}

Чтобы исправить компонент, придется перезапустить его~--- вручную вызвать функции \code{stop} и \code{start}, которые откроют новое соединение.

Сбои в сети случаются часто, и перезапускать компонент при обрыве тяжело. Нужен механизм, который бы делал это за нас. Так работают пулы соединений, которые открывают сразу несколько соединений. Пул следит за ошибками связи и обновляет соединения. Он работает в отдельном потоке и не блокирует наши действия.

О пулах мы говорили в первой книге, поэтому приведем только пример. Подключите библиотеку HikariCP в проект:

\begin{english}
  \begin{clojure}
;; [hikari-cp "2.8.0"]
(require '[hikari-cp.core :as cp])
  \end{clojure}
\end{english}

Функция \code{cp/make-datasource} принимает конфигурацию пула и строит объект \code{DataSource}. Его записывают в словарь спеки с ключом \code{:datasource}. По аналогии с \code{:connection}, JDBC проверяет это поле, прежде чем открывать соединение. Если источник задан, библиотека занимает одно из его соединений. Оно открыто заранее, и запрос пройдет так же быстро, как в случае с \code{:connection}. Новый компонент:

\begin{english}
  \begin{clojure}
(def pool-config ;; truncated
  {:minimum-idle       10
   :maximum-pool-size  10
   :adapter            "postgresql"
   :username           "book"
   :server-name        "127.0.0.1"
   :port-number        5432})

(defstate DB
  :start
  (let [pool (cp/make-datasource pool-config)]
    {:datasource pool})
  :stop
  (-> DB :datasource cp/close-datasource))
  \end{clojure}
\end{english}

Повторите эксперимент с отключением базы. Вы увидите тревожные сообщения, но затем HikariCP создаст новое соединение, и система продолжит работу. Это крайне важно для веб-приложений, поэтому в боевом запуске всегда используют пул. Спеку без состояния применяют только для разработки или в тестах.

Состояние поддерживают не только с помощью Mount. Это может быть другой фреймворк, например Component. Вот как задать JDBC-спеку, которая реагирует на методы \code{start} и \code{stop}:

\begin{english}
  \begin{clojure}
(def db
  (with-meta
    {:dbtype "postgresql"
     :dbname "test"
     :host "127.0.0.1"
     :user "book"
     :password "book"}
    {'com.stuartsierra.component/start
     (fn [this]
       (assoc this :connection
              (jdbc/get-connection this)))
     'com.stuartsierra.component/stop
     (fn [{:as this :keys [connection]}]
       (when connection
         (.close connection))
       (dissoc this :connection))}))
  \end{clojure}
\end{english}

Компонент включают, работают с ним и отключают:

\begin{english}
  \begin{clojure}
(def db-started (component/start db))

(jdbc/query db-started "select ...")
(jdbc/execute! db-started "update ...")

(component/stop db-started)
  \end{clojure}
\end{english}

Мы запустили компонент вручную, но на практике им управляет система. Если вы не уверены в том, что происходит, обратитесь к главе о системах из первой книги. По аналогии напишите компонент для Integrant~--- еще одного фреймворка, который мы изучили там же.

\section{SQLite}

\def\urlsqlite{https://www.sqlite.org/index.html}

Особое место в обзоре занимает \footurl{SQLite}{\urlsqlite}[SQLite]. Это не серверная, а клиентская база данных. От PostgreSQL или MySQL она отличается тем, что в ней нет центрального сервера, который обслуживает клиентов. SQLite работает на вашем компьютере, а ее код встроен в проект.

SQLite хранит данные в файлах по принципу один файл~--- одна база, что удобно для обмена. Например, внутренняя система раз в сутки выгружает базу SQLite с абонентами и их последними платежами. Эти данные показывает веб-приложение, и ему не нужно обращаться ко внутренней системе.

SQLite подходит для настроек или историй действий пользователя. Браузеры и другие программы ведут несколько SQLite-баз. Ради интереса исследуйте папки профилей Chrome, Firefox или Telegram~--- в каждой их них вы найдете файлы с расширением .db или .sqlite.

С точки зрения запросов SQLite ведет себя как обычная реляционная база данных. Ее основные сущности~--- таблицы, первичные ключи и индексы. База поддерживает транзакции, когда изменяются записи либо в нескольких таблицах, либо ни в одной. При чтении нет ограничений на число клиентов, но для записи это не так: только один клиент может изменять данные. При попытке сделать это второй клиент получит ошибку, что база заблокирована на запись. Поэтому SQLite используют в основном в программах для одного пользователя, где параллельная запись случается редко.

\def\urlsqlitebackup{https://www.sqlite.org/backup.html}

Особенность SQLite в том, что она может хранить данные в памяти без обращения к диску. Это полезно, когда программа интенсивно читает данные. Если загрузить их в память целиком, доступ к данным будет быстрее. Иногда программа выполняет долгий расчет и использует базу в памяти как временное хранилище. Позже ее можно \footurl{сохранить на диск}{\urlsqlitebackup}[SQLite backup].

Работа с SQLite сводится к функциям \code{query}, \code{insert!}, \code{update!} и другим. Добавьте драйвер SQLite в проект:

\begin{english}
  \begin{clojure}
[org.xerial/sqlite-jdbc "3.36.0"]
  \end{clojure}
\end{english}

Скорее всего, на вашем компьютере установлен браузер Chrome или Firefox. Чтобы не создавать базу вручную, позаимствуем готовую из профиля браузера. Google Chrome хранит историю в файле History (без расширения). Путь к профилю отличается в зависимости от системы:

\begin{itemize}

\item{Windows 10:
\begin{english}
  \begin{text*}{breaklines}
C:\Users\<username>\AppData\Local\Google\Chrome\User Data\Default
  \end{text*}
\end{english}}


\item{Mac OS:
\begin{english}
  \begin{text*}{breaklines, breakafter=/}
/Users/<username>/Library/Application Support/Google/Chrome/Default
  \end{text*}
\end{english}}

\item{Linux:
\begin{english}
  \begin{text*}{breaklines, breakafter=/}
/home/<username>/.config/google-chrome/default
  \end{text*}
\end{english}}

\end{itemize}

В случае с SQLite спека выглядит так (обратите внимание на ключи \code{classname} и \code{subprotocol}):

\begin{english}
  \begin{clojure}
(def db
  {:classname "org.sqlite.JDBC"
   :subprotocol "sqlite"
   :subname "/Users/ivan/.../Chrome/Default/History"})
  \end{clojure}
\end{english}

Для доступа к базе Chrome должен быть выключен, иначе вы получите ошибку.

Для начала узнаем, какие таблицы содержит база. Прочитаем их из главной таблицы \code{sqlite\_master}, в которой записаны все сущности (таблицы, индексы, триггеры и прочее).

\begin{english}
  \begin{clojure}
(->> (jdbc/query db "SELECT name FROM sqlite_master
                     WHERE type = 'table'")
     (mapv :name))
  \end{clojure}
\end{english}

Запрос вернет список строк:

\begin{english}
  \begin{clojure}
["meta"
 "urls"
 "sqlite_sequence"
 "visits"
 "visit_source"
 "keyword_search_terms"
 "downloads"
 "downloads_slices"
 "segments"
 ...]
  \end{clojure}
\end{english}

Чтобы увидеть последние сайты, что вы посещали, выполните запрос:

\begin{english}
  \begin{clojure}
(jdbc/query db
  "SELECT * FROM urls
   ORDER BY last_visit_time DESC LIMIT 10")
  \end{clojure}
\end{english}

Приведем один из элементов списка. В нем указан адрес страницы, ее заголовок, число посещений и время последнего посещения в формате наносекунд.

\begin{english}
  \begin{clojure}
{:id 98,
 :url "https://github.com/igrishaev",
 :title "igrishaev (Ivan Grishaev)",
 :visit_count 5,
 :typed_count 0,
 :last_visit_time 13261760285085441,
 :hidden 0}
  \end{clojure}
\end{english}

Таблица \code{downloads} хранит данные о загруженных файлах:

\begin{english}
  \begin{clojure}
(jdbc/query db "SELECT * FROM downloads limit 10")
  \end{clojure}
\end{english}

Очистка этих таблиц приведет к удалению истории в браузере. Когда вы нажимаете на кнопку <<очистить историю>>, браузер выполняет запросы \code{DELETE FROM} к этим и другим таблицам.

Пользуясь случаем, исследуйте базу History, а также базы Firefox и Telegram. Обратите внимание, насколько легко чужой программе получить доступ к истории браузера. Этим пользуются некоторые программы: взамен на бесплатную установку они читают историю и передают фирмам, которые показывают рекламу.

\subsection{База в памяти}

В этом разделе мы рассмотрим, как работать с базой SQLite в памяти. Для начала измените путь к файлу на строку \code{:memory:} Это особое значение, которое велит драйверу переключиться на другой тип хранилища.

\begin{english}
  \begin{clojure}
(def db
  {:classname   "org.sqlite.JDBC"
   :subprotocol "sqlite"
   :subname     ":memory:"})
  \end{clojure}
\end{english}

Далее вас ждет странность: если создать таблицу и записать в нее значение, получим ошибку, что таблицы не существует.

\begin{english}
  \begin{clojure}
(jdbc/execute! db "create table users (id integer)")

(jdbc/query db "SELECT * FROM users")
;; SQL error or missing database (no such table: users)
  \end{clojure}
\end{english}

Как мы помним, если в JDBC-спеке нет состояния, то каждый запрос протекает в новом соединении, которое закрывается. Драйвер SQLite устроен так, что с закрытием соединения пропадает база, созданная в памяти. В примере выше мы создали и уничтожили две базы данных~--- по одной на запрос.

Чтобы все работало правильно, установим постоянное соединение. Для этого объявим переменную \code{db*} (со звездочкой) с полем \code{:connection}:

\begin{english}
  \begin{clojure}
(def db
  {:classname   "org.sqlite.JDBC"
   :subprotocol "sqlite"
   :subname     ":memory:"})

(def db*
  (assoc db :connection
         (jdbc/get-connection db)))
  \end{clojure}
\end{english}

Теперь запросы общаются с одной и той же базой и ошибки не будет:

\begin{english}
  \begin{clojure}
(jdbc/execute! db* "create table users (id integer)")
(jdbc/insert! db* :users {:id 1})
(jdbc/query db* "select * from users")

;; [{:id 1, ...}, ...]
  \end{clojure}
\end{english}

Прием с полем \code{:connection} подходит и для файловой версии. Без него драйвер открывает файл на каждый запрос, что замедляет программу.

\section{Сложные типы}

Когда драйвер читает данные, он приводит их типам языка, в котором вы работаете. Для простых типов эта связь очевидна: \code{int} становится условным \code{java.lang.Integer}, \code{varchar} становится \code{java.lang.String} и так далее.

Гораздо интересней сложные типы, которые состоят из нескольких значений. К ним относятся точки на плоскости, географические объекты, JSON. Нет четких правил о том, как сопоставить их с типами Java. В зависимости от проекта эти соглашения меняются. Например, при записи в базу словарь может становиться объектом \code{hstore} или \code{jsonb}~--- выбор остается на усмотрение программиста.

Конечно, даже самый сложный объект можно хранить в виде строки. Для этого нужны две функции: привести объект к строке и восстановить его. Предположим, есть таблица платежей. У платежей может быть много полей: адреса отправителя и получателя, реквизиты банков и так далее. Чтобы не создавать колонку под каждое поле, обозначим только главные поля, а остальные запишем в виде JSON.

\begin{english}
  \begin{clojure}
(jdbc/execute! db "CREATE TABLE payments (
  id SERIAL PRIMARY KEY,
  sum INTEGER,
  meta TEXT
)")
  \end{clojure}
\end{english}

В поле \code{meta} окажутся поля, для которых нет выделенных колонок. Подготовим функции для конвертации:

\begin{english}
  \begin{clojure}
(require '[cheshire.core :as json])

(defn meta->str
  [meta-info]
  (json/generate-string meta-info))

(defn str->meta
  [db-string]
  (json/parse-string db-string keyword))
  \end{clojure}
\end{english}

Запишем в базу платеж с произвольными метаданными:

\begin{english}
  \begin{clojure}
(jdbc/insert!
 db
 :payments
 {:id 1
  :sum 99
  :meta (meta->str
          {:date "2021-03-10"
           :from "test@test.com"
           :BIK "332233"
           :INN "8626235235"})})
  \end{clojure}
\end{english}

Вот как восстановить поле \code{:meta} после выборки:

\begin{english}
  \begin{clojure}
(let [result
      (jdbc/query db "select * from payments")]

  (for [row result]
    (update row :meta str->meta)))

({:id 1
  :sum 99
  :meta {:date "2021-03-10"
         :from "test@test.com"
         :BIK "332233"
         :INN "8626235235"}})
  \end{clojure}
\end{english}

Недостаток в том, что функции \code{meta->str} и \code{str->meta} нужно вызывать каждый раз при записи и чтении данных. Если забыть их, получим строку вместо объекта, что вызовет ошибку в дальнейшем коде. Кроме \code{meta}, в таблице могут быть другие поля с JSON, о которых нужно помнить.

Удачный подход в том, чтобы найти бутылочное горлышко, через которое проходят все данные от клиента в базу и обратно. Если изменить поведение там, функции \code{query}, \code{insert!} и другие сработают одинаково в любом месте проекта. JDBC предлагает такие горлышки для чтения и записи. Рассмотрим их на примере дат и JSON.

Проверим, что случится, если выбрать из базы дату. Для этого обратимся к переменной PostgreSQL с именем \code{current\_timestamp}:

\begin{english}
  \begin{clojure}
(-> (jdbc/query db "SELECT current_timestamp AS now")
    first
    :now
    type)

;; java.sql.Timestamp
  \end{clojure}
\end{english}

Тип значения будет \code{Timestamp}. Это класс-обертка над обычным \code{java.util.Date}, который учитывает особенности времени в SQL. Если мы хотим передать дату в параметрах, она тоже должна быть объектом \code{Timestamp}. Класс \code{Date} и другие вызовут ошибку:

\begin{english}
  \begin{clojure}
(jdbc/query
  db ["select ? as now" (new java.util.Date)])

;; Can't infer the SQL type to use
;; for an instance of java.util.Date.
  \end{clojure}
\end{english}

\def\urljodatime{https://www.joda.org/joda-time/}

Класс \code{Timestamp} неудобен в работе с бизнес-логикой. Проекты на Java и Clojure используют более продвинутые типы времени, например библиотеку \footurl{Joda Time}{\urljodatime}[Joda Time]. Рассмотрим, как подружить ее с JDBC.

Роль бутылочного горлышка играют протоколы \code{IResult\-Set\-Read\-Column}, \code{ISQL\-Para\-meter} и \code{ISQL\-Value}. Вместе они определяют, как обработать значение при чтении и записи. Протокол \code{IResultSetReadColumn} отвечает за чтение. Он объявляет метод с тремя параметрами:

\begin{english}
  \begin{clojure}
(result-set-read-column [val rsmeta idx])
  \end{clojure}
\end{english}

Аргументы:

\begin{itemize}

\item
  \code{val}: исходное значение из базы;

\item
  \code{rsmeta}: метаданные результата, экземпляр класса \code{Result\-Set\-Meta\-Data}. Содержит сводную информацию о полях, именах и типах;

\item
  \code{idx}: индекс текущего поля (считается от нуля).

\end{itemize}

При чтении результата JDBC пропускает значения через этот метод. По умолчанию протокол реализует \code{Object}, главный класс в дереве наследования. Для него функция \code{result-set-read-column} вернет исходное значение. В этом случае оно останется в том виде, в котором пришло из драйвера JDBC.

Изменим протокол так, чтобы \code{Timestamp} становился экземпляром \code{DateTime} из библиотеки Joda Time. Для этого импортируем класс и расширим протокол:

\begin{english}
  \begin{clojure/lines}
(:import org.joda.time.DateTime)

(extend-protocol jdbc/IResultSetReadColumn
  java.sql.Timestamp
  (result-set-read-column [val _rsmeta _idx]
    (new DateTime (.getTime val))))
  \end{clojure/lines}
\end{english}

Параметры \code{rsmeta} и \code{idx} не нужны, поэтому предварим их подчеркиваниями \coderef{5}. Из переменной \code{val} с типом \code{Timestamp} получим экземпляр \code{DateTime}. Проще всего это сделать передачей миллисекунд. Метод \code{getTime} класса \code{Timestamp} вернет их из \code{val}; далее передаем их в конструктор \code{DateTime}. Теперь любая дата, выбранная из базы, предстанет в новом виде. Проверим себя:

\begin{english}
  \begin{clojure}
(first
  (jdbc/query db "SELECT current_timestamp AS now"))

{:now #object[o.j.t.DateTime "2021-07-22T10:23:51..."]}
  \end{clojure}
\end{english}

С той же легкостью работает установка параметра. Для этого служит протокол \code{ISQLValue} и его метод \code{sql-value}. Он принимает значение и возвращает его аналог, совместимый с JDBC. Если мы передали \code{DateTime}, на выходе должен быть \code{Timestamp}. Расширим протокол обратным преобразованием:

\begin{english}
  \begin{clojure}
(extend-protocol jdbc/ISQLValue
  DateTime
  (sql-value [val]
    (new java.sql.Timestamp (.getMillis val))))
  \end{clojure}
\end{english}

Добавим в таблицу платежей поле с датой:

\begin{english}
  \begin{clojure}
(jdbc/execute!
  db "ALTER TABLE payments
      ADD COLUMN created_at TIMESTAMP WITH TIME ZONE")
  \end{clojure}
\end{english}

Запишем дату, передав экземпляр \code{DateTime}:

\begin{english}
  \begin{clojure}
(jdbc/insert!
  db :payments
  {:id 2 :sum 100 :created_at (DateTime/now)})
  \end{clojure}
\end{english}

Отныне любая работа с датами сводится к Joda Time. Если понадобится другой тип даты, измените протокол. Предположим, вместо Joda Time вы предпочитаете встроенный класс \code{java.time.Instant}. Перепишите код так, чтобы база возвращала и принимала его экземпляры.

Третий протокол \code{ISQLParameter} полезен в случаях, когда установка параметра требует особых действий. По умолчанию JDBC вызывает метод \code{.setObject} подготовленного выражения, чего хватает в большинстве случаев. В будущем мы рассмотрим задачу с массивом, где вместо \code{.setObject} должен быть другой метод. Там мы и познакомимся с этим протоколом.

\subsection{Организация кода}

Расширение протокола не должно переплетаться с бизнес-логикой. Это глобальное действие, которое влияет на всю среду исполнения, поэтому держите его в отдельном модуле. В случае с датами будет правильно создать пространства \code{project.jdbc.time-joda} и \code{project.jdbc.time-instant}. В зависимости от того, какой тип мы используем в проекте, подключим нужный модуль.

Импорт одного из модулей должен быть в коде, который загружается всегда, например в \code{.core}-модуле проекта. Добавьте комментарий о том, что импорт расширяет протокол \coderef{3}:

\begin{english}
  \begin{clojure/lines}
(ns project.core
  (:require
   project.jdbc.time-joda ;; extends JDBC protocols
   [cheshire.core :as json]
   ...))
  \end{clojure/lines}
\end{english}

\def\urljoker{https://github.com/candid82/joker}

Без комментария импорт станет неочевидным. Кажется, что модулем когда-то пользовались, но со временем забыли убрать из секции \code{:require}. Кто-то удалит импорт и столкнется со странным поведением базы. Если вы проверяете код линтером, добавьте пространство имен в список исключений. У линтера \footurl{Joker}{\urljoker}[Joker] опция называется \code{:ignored-unused-namespaces}:

\begin{english}
  \begin{clojure}
{:ignored-unused-namespaces
   [project.jdbc.time-joda
    ...]}
  \end{clojure}
\end{english}

В случае с \code{clj-kondo} предварите импорт формой \code{\#\_:clj-kondo/ignore}:

\begin{english}
  \begin{clojure}
(ns com.project.api
  (:require
    #_:clj-kondo/ignore project.jdbc.time-joda))
  \end{clojure}
\end{english}

Так вы не получите предупреждения о том, что модуль \code{project.jdbc.time-joda} подключен, но не используется. Похожая настройка встречается в других линтерах.

В теле \code{:require} модули, которые изменяют состояние, обычно помещают без квадратных скобок и псевдонимов (имени после \code{:as}). Полезно отделить их пустой строкой, чтобы выделить на общем фоне.

\subsection{Поддержка JSON}

Как видно из примеров с датами, управлять типами в JDBC нетрудно. Теперь мы добавим мощную функциональность: построим связь между типом JSON(b) и Clojure. Для начала вспомним, в чем особенность JSON и где его применяют.

\def\urljsonorg{https://www.json.org/json-en.html}

\footurl{JSON}{\urljsonorg}[json.org]~--- это запись данных на языке, близком к JavaScript. Кроме простых типов вроде чисел и строк, стандарт поддерживает коллекции~--- массивы и объекты~--- и их произвольную вложенность. С помощью JSON данные передают по сети и хранят в файлах. Формат используют для конфигурации приложений.

JSON полезен, когда у данных сложная структура, например глубокая вложенность. Раскладывать такие данные по таблицам тяжело. Иногда проще записать JSON одну в колонку и позже восстановить при чтении.

JSON оказался столь популярен, что базы научились работать с ним своими силами. Для них JSON уже не строка, а сложный тип. Для примера сравним один и тот же объект с разным порядком ключей. Если сравнить их как строки, получим ложь из-за отличия в символах:

\begin{english}
  \begin{sql}
SELECT '{"foo": 1, "bar": 2}' = '{"bar": 2, "foo": 1}';
-- false
  \end{sql}
\end{english}

Если указать \code{jsonb}, получим истину, потому что порядок ключей в объектах не важен.

\begin{english}
  \begin{sql}
SELECT '{"foo": 1, "bar": 2}'::jsonb =
       '{"bar": 2, "foo": 1}'::jsonb;
-- true
  \end{sql}
\end{english}

Кроме сравнения, \code{json(b)} предлагает доступ к полям, в том числе вложенным, объединение и пересечение объектов, массивов и многое другое. Почти любую операцию над JSON можно выполнить в SQL, не прибегая к Clojure.

Предположим, поле \code{attributes} товара содержит JSON-объект с характеристиками, которые часто меняются:

\begin{english}
  \begin{sql}
CREATE TABLE items (id SERIAL, title TEXT, attrs JSONB);

INSERT INTO items VALUES
  (1, 'Cap', '{"size": "XL",
               "color": "red",
               "country": "China"}');

INSERT INTO items VALUES
  (2, 'Hoodie', '{"size": "L",
                  "color": "black",
                  "country": "Germany"}');
  \end{sql}
\end{english}

Чтобы выбрать товары красного цвета, добавьте условие как в примере ниже. Оператор $\twoheadrightarrow$ означает извлечь поле \code{color} из объекта в виде текста.

\begin{english}
  \begin{sql}
SELECT id, title FROM items
WHERE attrs->>'color' = 'red';

 id | title
----+-------
  1 | Cap
  \end{sql}
\end{english}

PostgreSQL поддерживает индексы для отдельных полей JSON. Если вы часто ищете товары цвету, добавьте следующий индекс, и скорость поиска возрастет:

\begin{english}
  \begin{sql}
CREATE INDEX idx_items_color
  ON items((attrs->>'color'));
  \end{sql}
\end{english}

Тип \code{json(b)} полезен для нечетких данных, чья структура меняется или от чего-то зависит. Один из примеров мы уже рассмотрели~--- это характеристики товаров. В зависимости от типа товара (техника, одежда, еда) у него могут быть разные характеристики. Если держать их в отдельной таблице, это породит лишние связи и таблицы-мосты, что усложнит запрос. Порой дешевле хранить их в одной колонке \code{json(b)} и проверять в приложении перед записью.

Другой случай, когда полезен JSON~--- это сложные и объемные документы. Это может быть бухгалтерский договор или история болезни. В виде JSON эти сущности занимают несколько экранов с глубокой вложенностью. Разложить их на отдельные таблицы ст\'{о}ит усилий; много времени уйдет на запись и обновление. Проще хранить сущность как неделимый объект и изменять его целиком.

PostgreSQL поддерживает два типа JSON: одноименный (json) и с частичкой <<b>> на конце (jsonb). Последнее означает binary, двоичный JSON. Разница между типами в их устройстве. Тип json работает с данными наивно: он хранит исходную строку (с~пробелами и переносами строк) и на каждую операцию делает разбор. Наоборот, jsonb хранит данные в двоичном виде, что не требует разбора при обращении. Это замедляет запись, но ускоряет выборку. Скорее всего, вам подойдет jsonb: он поддерживает больше операций включая сравнение, что иногда необходимо.

Если выбрать из базы колонку JSON, получим загадочный объект \code{PGObject}:

\begin{english}
  \begin{clojure}
(def attrs
  (-> (jdbc/query db "SELECT * from items")
      first
      :attrs))

(type attrs)
;; org.postgresql.util.PGobject
  \end{clojure}
\end{english}

Это контейнер для данных, свойственных PostgreSQL. У класса два поля: тип и значение в виде строки. Исследуем их:

\begin{english}
  \begin{clojure}
(.getType attrs)
;; "jsonb"

(.getValue attrs)
;; "{\"size\": \"XL\", \"color\": \"red\",
;;   \"country\": \"China\"}"
  \end{clojure}
\end{english}

Кроме json(b), в \code{PGObject} могут быть данные другого типа, например сетевой адрес:

\begin{english}
  \begin{clojure}
(first (jdbc/query db "select '127.0.0.1'::inet as IP"))

{:ip #object[o.p.u.PGobject "127.0.0.1"]}
  \end{clojure}
\end{english}

Связь между \code{PGObject} и JDBC состоит из двух шагов. Во-первых, расширим протокол \code{IResultSetReadColumn}:

\begin{english}
  \begin{clojure}
(extend-protocol jdbc/IResultSetReadColumn
  org.postgresql.util.PGobject
  (result-set-read-column [pg-obj _rsmeta _idx]
    ...))
  \end{clojure}
\end{english}

Пока что не ясно, что следует за многоточием. Как мы выяснили, \code{PGobject} служит для разных типов. Проверим тип поля и для каждого варианта вызовем свой обработчик. Проще всего это сделать оператором \code{case} как в листинге \ref{fig:pg-obj-case} на следующей странице.

\begin{figure}[ht!]

\begin{english}
  \begin{clojure/lines}
(extend-protocol jdbc/IResultSetReadColumn
  org.postgresql.util.PGobject
  (result-set-read-column [pg-obj _rsmeta _idx]

    (let [pg-val (.getValue pg-obj)
          pg-type (.getType pg-obj)]

      (case pg-type
        ("json" "jsonb")
        (json/parse-string pg-val keyword)

        "inet"
        (java.net.InetAddress/getByName pg-val)

        ;; else
        pg-obj))))
  \end{clojure/lines}
\end{english}

\caption{Приведение \code{PGObject} к значению Clojure}
\label{fig:pg-obj-case}

\end{figure}

\def\urlcheshire{https://github.com/dakrone/cheshire}

Обратите внимание, что реализации \code{json} и \code{jsonb} совпадают: в обоих случаях база вернет строку, которую парсят библиотекой \footurl{Chesire}{\urlcheshire}[Chesire] \coderef{10}. Проверим теперь, что типы читаются верно:

\begin{english}
  \begin{clojure}
(first (jdbc/query db "SELECT * from items"))

{:id 1 :title "Cap"
 :attrs {:size "XL" :color "red" :country "China"}}
  \end{clojure}
\end{english}

Для сетевого адреса получим экземпляр \code{Inet4Address}:

\begin{english}
  \begin{clojure}
(first (jdbc/query db "select '127.0.0.1'::inet as IP"))

{:ip #object[java.net.Inet4Address "/127.0.0.1"]}
  \end{clojure}
\end{english}

Форма \code{case} выше не совсем удобна: если понадобится новый тип, придется дописывать его в конец. Потребители вашего кода не смогут это сделать. Возможен более гибкий подход с мультиметодом \code{pg->clojure}, чья функция-диспетчер возвращает тип поля:

\begin{english}
  \begin{clojure}
(defmulti pg->clojure (fn [pg-obj]
                        (.getValue pg-obj)))
  \end{clojure}
\end{english}

Теперь код \code{result-set-read-column} сводится к вызову мультиметода:

\begin{english}
  \begin{clojure}
(result-set-read-column [pg-obj _rsmeta _idx]
  (pg->clojure pg-obj))
  \end{clojure}
\end{english}

Расширьте мультиметод типами \code{json(b)} и сетевым адресом. Со временем мы добавим в него другие типы.

\begin{english}
  \begin{clojure}
(defmethod pg->clojure "json"
  [pg-obj] ...)

(defmethod pg->clojure "inet"
  [pg-obj] ...)
  \end{clojure}
\end{english}

\subsection{Запись JSON}

Теперь когда мы читаем JSON из базы, позаботимся о записи. Для этого расширим протокол \code{jdbc/ISQLValue} так, чтобы любая коллекция Clojure становилась объектом \code{PGobject}. Но сперва уточним, что имеем в виду под термином <<любая коллекция>>.

Протоколы в Clojure устроены на базе интерфейсов и иерархии классов. Если мы хотим, чтобы вектор и словарь отзывались на какое-то действие, нужно найти общий интерфейс и расширить его протоколом. Чтобы увидеть интерфейсы, которые реализует коллекция, выполните выражение:

\begin{english}
  \begin{clojure}
(supers (type {}))

#{clojure.lang.IMeta
  java.lang.Runnable
  java.io.Serializable
  clojure.lang.ILookup
  ...
  clojure.lang.IPersistentCollection}
  \end{clojure}
\end{english}

Вы получите множество интерфейсов Java. Среди прочих нас интересует последний элемент, \code{IPersistentCollection}. Он встречается в \code{supers} не только вектора, но и списка и последовательности:

\begin{english}
  \begin{clojure}
(supers (type []))
(supers (type ()))
(supers (type (repeat 1)))
  \end{clojure}
\end{english}

Расширим \code{ISQLValue} этим протоколом, чтобы коллекция Clojure становилась объектом \code{PGobject} с типом \code{jsonb}:

\begin{english}
  \begin{clojure}
(extend-protocol jdbc/ISQLValue
  clojure.lang.IPersistentCollection
  (sql-value [val]
    (doto (new org.postgresql.util.PGobject)
      (.setType "jsonb")
      (.setValue (json/generate-string val)))))
  \end{clojure}
\end{english}

Теперь атрибуты товара можно задать словарем:

\begin{english}
  \begin{clojure}
(jdbc/insert! db :items
              {:id 5
               :title "The Catcher in the Rye"
               :attrs {:author "J. D. Salinger"
                       :genre "novel"
                       :year 1951}})
  \end{clojure}
\end{english}

То же самое работает с \code{execute!}, потому что обе функции сходятся одной точке, где преобразуются типы.

\begin{english}
  \begin{clojure}
(jdbc/execute!
  db
  ["INSERT INTO items VALUES (?, ?, ?)"
  5
  "The Catcher in the Rye"
  {:year 1951 :genre "novel"
   :author "J. D. Salinger"}])
  \end{clojure}
\end{english}

Предположим, мы храним теги товара~--- короткие строки с его описанием. Проще всего это сделать полем \code{tags} с типом \code{jsonb}, в который запишем вектор строк:

\begin{english}
  \begin{sql}
ALTER TABLE items ADD COLUMN tags JSONB;
  \end{sql}
\end{english}

Обновим теги у только что созданной книги:

\begin{english}
  \begin{clojure}
(jdbc/update! db :items
              {:tags ["book" "novel"]}
              ["id = ?" 5])
  \end{clojure}
\end{english}


\noindent
и прочитаем ее \coderef{7}:

\begin{english}
  \begin{clojure/lines}
(jdbc/get-by-id db :items 5)

{:id 5
 :title "The Catcher in the Rye"
 :attrs {:year 1951 :genre "novel"
         :author "J. D. Salinger"}
 :tags ("book" "novel")}
  \end{clojure/lines}
\end{english}

Технически возможно записать в теги словарь, а в атрибуты~--- список. С точки зрения базы ошибки нет, потому что у обоих значений тип \code{jsonb}. Чтобы этого избежать, проверяйте данные до записи в базу. Проще всего это сделать функцией \code{insert-item}, которая проверяет аргументы спекой.

Для начала объявим спеку полей таблицы \code{items}:

\begin{english}
  \begin{clojure}
(require '[clojure.spec.alpha :as s])

(s/def ::item-fields
  (s/keys :req-un [::id ::title]
          :opt-un [::attrs ::tags]))
  \end{clojure}
\end{english}

Расширим поля атрибутов и тегов:

\begin{english}
  \begin{clojure}
(s/def ::attrs
  (s/map-of keyword? any?))

(s/def ::tags
  (s/coll-of string?))
  \end{clojure}
\end{english}

В функции \code{insert-item} мы задали \code{pre}-выражение, в котором проверяем поля спекой макросом \code{s/assert} \coderef{2}.

\begin{english}
  \begin{clojure/lines}
(defn insert-item [db fields]
  {:pre [(s/assert ::item-fields fields)]}
  (jdbc/insert! db :items fields))
  \end{clojure/lines}
\end{english}

По умолчанию \code{s/assert} ничего не делает, потому что предназначен для отладки. Включите его выражением:

\begin{english}
  \begin{clojure}
(s/check-asserts true)
  \end{clojure}
\end{english}

Вызовите функцию с неверными данными, когда один из тегов равен \code{nil} \coderef{6}:

\begin{english}
  \begin{clojure/lines}
(insert-item db {:id 5
                 :title "The Catcher in the Rye"
                 :attrs {:author "J. D. Salinger"
                         :genre "novel"
                         :year 1951}
                 :tags ["book" "novel" nil]})
  \end{clojure/lines}
\end{english}

Вы получите ошибку спеки, и запись не случится. То же самое можно сделать макросом \code{fdef} и функцией \code{instrument} из модуля спеки. Мы подробно разобрали эти возможности во второй главе первой книги. Обратитесь к ней, если вам не понятны термины, о которых мы говорим.

\subsection{Проблема nil в JSON}

При записи JSON проверяйте значение на \code{nil}. Если этого не делать, произойдет следующее: значение \code{nil} станет строкой \code{"null"} и займет место в базе. Это чревато странным поведением в запросах. Предположим, вы ищете записи с пустыми атрибутами. Если выполнить запрос:

\begin{english}
  \begin{sql}
SELECT id FROM items WHERE attrs IS NULL
  \end{sql}
\end{english}

\noindent
, в результате не будет строк с полем \code{attrs}, равным \code{"null"}, потому что это значение \code{json(b)}, отличное от \code{NULL}. Другими словами, вы ввели новое пустое значение. С ним проверка выглядит сложнее:

\begin{english}
  \begin{sql}
SELECT id FROM items
WHERE attrs IS NULL OR attrs = 'null';
  \end{sql}
\end{english}

Очевидно, первый запрос удобней, особенно если \code{json(b)} встречается в разных таблицах. Следите, чтобы пустое значение было выражено одним способом. Лучше всего для этого подходит стандартный \code{NULL}. С точки зрения Clojure это значит, что функция \code{->pg-object} возвращает \code{PGObject} только если значение отлично от \code{nil}.

Для начала проверим текущее поведение в случае с \code{nil}:

\begin{english}
  \begin{clojure}
(->pg-object nil)

;; #object[o.p.u.PGobject "null"]
  \end{clojure}
\end{english}

Получим \code{PGobject} со сторокой \code{"null"}, что нас не устраивает. С проверкой аргумента на \code{some?} результат будет \code{nil}:

\begin{english}
  \begin{clojure}
(defn ->pg-object [data]
  (when (some? data)
    (doto (new PGobject)
      (.setType "json")
      (.setValue (json/generate-string data)))))

(->pg-object nil) ;; nil
  \end{clojure}
\end{english}

Колонка в базе должна иметь атрибут \code{NULL}, установленный в истину.

\subsection{Типизированные записи}

Мы установили правило: при передаче параметров любая коллекция становится объектом JSON. Однако PostgreSQL предлагает другие сложные типы, например точки, линии и прямоугольники. Рассмотрим, что вернет база данных, если выбрать точку:

\begin{english}
  \begin{clojure}
(first (jdbc/query db "select '(1, 2)'::point"))
;; {:point #object[o.p.g.PGpoint "(1.0,2.0)"]}
  \end{clojure}
\end{english}

Получим экземпляр класса \code{PGpoint}. Логично привести его в словарю \code{\{:x 1.0, :y 2.0\}}, чтобы упростить дальнейшую работу. Однако если передать этот словарь обратно при записи точки, он станет объектом \code{PGObject} с типом \code{json}, что вызовет ошибку драйвера.

Наиболее простое решение в том, чтобы создать типизированную запись, или р\'{е}корд. Запись повторяет свойства словаря и вдобавок объявляет класс Java. Если расширить протокол JDBC этим классом, мы сохраним функциональность JSON, потому что класс стоит выше протокола \code{IPersistentCollection} в дереве наследников.

Объявим запись с двумя слотами координат:

\begin{english}
  \begin{clojure}
(defrecord Point [x y])
  \end{clojure}
\end{english}

Расширим протокол \code{IResultSetReadColumn} типом \code{PGpoint}. Импортируем его, чтобы не указывать весь путь. Метод \code{result-set-read-column} вернет экземпляр \code{Point} с заполненными слотами:

\begin{english}
  \begin{clojure}
(import 'org.postgresql.geometric.PGpoint)

(extend-protocol jdbc/IResultSetReadColumn
  PGpoint
  (result-set-read-column [pg-point _rsmeta _idx]
    (new Point (.-x pg-point) (.-y pg-point))))
  \end{clojure}
\end{english}

Теперь точка приходит из базы в удобном виде. При печати она выглядит как словарь, но на самом деле это экземпляр записи.


\begin{english}
  \begin{clojure}
(first (jdbc/query db "select '(1, 2)'::point"))

{:point {:x 1.0, :y 2.0}}
  \end{clojure}
\end{english}

Расширим \code{ISQLValue} для перевода точки в тип JDBC. Обратите внимание: поскольку запись ведет себя как словарь, мы распаковали поля \code{x} и \code{y} на уровне сигнатуры \coderef{3}.

\begin{english}
  \begin{clojure/lines}
(extend-protocol jdbc/ISQLValue
  Point
  (sql-value [{:keys [x y]}]
    (new PGpoint x y)))
  \end{clojure/lines}
\end{english}

Передать точку в запрос можно несколькими способами. Первый~--- вызвать конструктор класса оператором \code{new}. Второй~--- получить запись из словаря функцией \code{map->RecordName}. Функция находится в том же пространстве имен, где объявлена запись. Третий способ~--- предварить словарь решеткой с полным именем записи. Все три способа вернут экземпляр \code{Point}:

\begin{english}
  \begin{clojure}
(def sql "select ? as point")

(jdbc/query db [sql (new Point 1 2)])
(jdbc/query db [sql (map->Point {:x 1 :y 2})])
(jdbc/query db [sql #book.db.Point{:x 1 :y 2}])
  \end{clojure}
\end{english}

По аналогии сопоставьте другие типы с записями Clojure, например линии и прямоугольники (\code{line} и \code{box}).

\section{Проблемы SQL}

Каждый, кто работает с базой данных, сталкивается с проблемой: длинный SQL затрудняет чтение кода. Блоки SQL разрывают логику приложения и вносят визуальный шум.

\begin{english}
  \begin{clojure}
(let [events (get-events http-client)
      sql "SELECT * FROM users u
JOIN profiles p ON p.user_id = u.id
WHERE u.is_active
AND p.created_at > ..."
      result (jdbc/query db sql)]
  ...)
  \end{clojure}
\end{english}

Большие запросы в коде смотрятся чужеродно. При чтении приходится переключать контекст, чтобы понять, что происходит в запросе. Ситуация ухудшается с копированием: часто необходим такой же запрос, но с небольшими правками. Это усложняет поддержку, ведь однажды критерии выборки могут измениться для всех запросов.

Предположим, в таблице появился флаг отложенного удаления. Пользователь закрыл учетную запись, но физическая очистка базы происходит раз в месяц. Поэтому при выборке пользователя нужно добавить условие <<не удален>>:

\begin{english}
  \begin{clojure}
SELECT ... FROM users WHERE ... AND NOT is_deleted
  \end{clojure}
\end{english}

Если запрос многократно копировали, придется искать все случаи и дописывать к каждому \code{AND NOT is\_deleted}.

SQL-выражения со временем растут. На старте проекта в нем мало сущностей и таблиц, но затем их число увеличивается. Например, выборка популярных товаров с их категориями, оценками и сортировкой может занять экран. Если вставить подобный SQL прямо в код, станет тяжелее поддерживать и код, и SQL.

Мы подводим читателя к вопросу о том, как управлять запросами в промышленных масштабах. В разных языках приняты разные подходы. Наиболее популярен промежуточный слой, который преобразует объекты в записи таблиц и наоборот. Например, запрос к таблице \code{users} вернет список объектов \code{User}, который еще называют моделью. Если изменить поля модели и вызвать метод \code{.save()}, сработает либо запрос \code{UPDATE} (обновить текущую запись) или \code{INSERT} (добавить новую запись).

\def\urlwikiorm{https://ru.wikipedia.org/wiki/ORM}
\def\urlwiriar{https://ru.wikipedia.org/wiki/ActiveRecord}

Сопоставление таблиц и объектов называется \footurl{ORM}{\urlwikiorm}[ORM] (Ob\-ject–re\-la\-ti\-o\-nal map\-ping). Встречается его разновидность \footurl{Active Record}{\urlwiriar} [Active Record] (сокращенно AR). Как правило, любой современный язык предлагает библиотеки для ORM или AR.

Попытки создать ORM были и в Clojure, но они не получили широкого распространения. Практика показывает, что в Clojure легко работать с базой на низкому ровне. Коллекции Clojure \emph{уже} обладают важными свойствами: они неизменяемы и на них действуют сотни функций стандартной библиотеки. В Clojure список словарей достаточен для дальнейшей работы, и нет смысла приводить их к другим сущностям.

Работу с SQL можно облегчить, подключив некоторые библиотеки. Мы рассмотрим построители запросов на шаблонах и данных: их особенности, преимущества и недостатки.

\subsection{Шаблоны}

Подход с шаблоном состоит из двух этапов. Сначала создают файл с расширением \code{.sql} и пишут в нем запросы. Каждый запрос предваряется шапкой из нескольких комментариев. В них указаны имя запроса, описание и характеристики. На месте параметров стоят именованные метки. Пример подобного файла:

\begin{english}
  \begin{sql}
-- :name list-users :?
-- :doc Get all the users
select * from users;

-- :name get-user-by-id :? :1
-- :doc Get a single user by ID
select * from users
where id = :id;
  \end{sql}
\end{english}

Специальный код читает этот файл. Для каждого запроса он порождает одноименную функцию, которая принимает JDBC-спеку и параметры. Результат запроса станет результатом функции при вызове. Так, запросу \code{get-user-by-id} соответствует функция, вызвав которую с подключением и параметром, получим результат:

\begin{english}
  \begin{clojure}
(get-user-by-id db {:id 1})

{:id 1, :fname "Ivan" ...}
  \end{clojure}
\end{english}

Способ, когда SQL преобразуют в функции, несет несколько преимуществ. Прежде всего, в проекте один источник SQL. Запросы собраны в одном файле, и не нужно искать их по всему проекту.

Некоторые фирмы проводят аудит запросов, чтобы выявить узкие места. DBA-инженеру будет удобно посмотреть .sql файл и улучшить его. Если же вы обращаетесь к базе с помощью ORM, придется искать конечные запросы в логах. При этом запросы, составленные программой, читаются хуже, чем написанные человеком.

Если требуется особый оператор, например слияние JSON-объектов или пересечение интервалов, вы скопируете его из документации. В примере ниже оператор \code{||} объединяет два объекта JSON. В случае с ORM придется расширить класс или писать какую-то обертку.

\begin{english}
  \begin{sql}
UPDATE items
  SET attrs = attrs || '{"size": "XXL"}'::jsonb
  WHERE id = 123;
  \end{sql}
\end{english}

Запросы в исходном виде удобны для отладки. Если вы составили сложный запрос с помощью ORM, то должны убедиться, что он порождает верный SQL. Для этого вызывают уловный объект \code{QuerySet} и смотрят логи базы. С сырым SQL этот шаг отпадает: его можно выполнить в PGAdmin или схожей программе с минимальными усилиями.

\def\urlhugsqlorg{https://www.hugsql.org/}
\def\urlhugsqlgh{https://github.com/layerware/hugsql}

SQL в шаблонах предлагает библиотека \footurl{HugSQL}{\urlhugsqlorg}[HugSQL]. Подключите ее в проект (понадобится свежая версия \code{tools.reader}):

\begin{english}
  \begin{clojure}
[org.clojure/tools.reader "1.3.6"]
[com.layerware/hugsql "0.5.1"]
  \end{clojure}
\end{english}

Создайте файл \code{queries.sql} в папке \code{resources/sql} с запросами:

\begin{english}
  \begin{sql/lines}
-- :name list-users :?
-- :doc Get all the users
select * from users;

-- :name get-user-by-id :? :1
-- :doc Get a single user by ID
select * from users
where id = :id;
  \end{sql/lines}
\end{english}

Параметр \code{:name} означает имя будущей функции. По желанию добавьте \code{:doc} с описанием, и тогда редактор покажет справку в месте вызова. Особенно интересны параметры \code{:?} и \code{:1}, что указаны после \code{:name} (строки 1 и 5). Это флаги, которые определяют, как обработать запрос и его результат.

Знак вопроса означает, что запрос выполняется функцией \code{jdbc/query}. Библиотека JDBC отличает чтение от исполнения. Чтение означает обработку результата, в то время как при исполнении результат отбрасывается. Поэтому в запросах на чтение указывают \code{:?}.

Флаги \code{:*} и \code{:1} означают сколько записей прочитать из ответа: все или одну. Когда мы ищем заведомо одну запись, логично указать \code{:1}, чтобы получить либо ее, либо \code{nil}. В противном случае вам придется оборачивать результат в \code{(first...)}, что неудобно. Если не задана единица, по умолчанию получим все записи.

Преобразуем запросы в функции. Вызов \code{def-db-fns} принимает путь к файлу и наполняет текущее пространство новыми функциями:

\begin{english}
  \begin{clojure}
(require '[hugsql.core :as hugsql])

(hugsql/def-db-fns "sql/queries.sql")
  \end{clojure}
\end{english}

Выполним их:

\begin{english}
  \begin{clojure}
(list-users db)
;; ({:id 1 :fname "Ivan", ...}, ...)

(get-user-by-id db {:id 1})
;; {:id 1 :fname "Ivan", ...}
  \end{clojure}
\end{english}

Подготовим вставку пользователей:

\begin{english}
  \begin{sql}
-- :name create-user :i!
insert into users (fname, lname, email, age)
values (:fname, :lname, :email, :age);
  \end{sql}
\end{english}

После изменений в файле сгенерируйте функции еще раз. Появится новая функция \code{create-user}:

\begin{english}
  \begin{clojure}
(create-user db {:fname "Ioann"
                 :lname "Smith"
                 :email "test@test.com"
                 :age 30})
;; {:id 76, :fname "Ioann", ...}
  \end{clojure}
\end{english}

Флаг \code{:i!} служит для оператора \code{INSERT}. Он означает вернуть первичные ключи записей, которые произвела база данных. Схожий флаг \code{:<!} работает с выражением \code{INSERT ... RETURNING ...}, что значит <<вставить и вернуть>>. Она полезна, когда полям таблицы заданы значения по умолчанию.

Эти и другие флаги служат синтаксическим сахаром для параметра \code{:command}. Если вам трудно запомнить флаги, укажите их явно:

\begin{itemize}

\item
  \code{:command :query} для обычного запроса с \code{SELECT};

\item
  \code{:command :insert} для вставки и возврата первичного ключа;

\item
  \code{:command :execute} для выполнения без чтения результата, например при создании таблицы;

\item
  \code{:command :returning-execute} для выполнения в возвратом результата.

\end{itemize}

Чтобы создать несколько записей в транзакции, обернем функции в макрос \code{with-db-transaction} и укажем \code{tx} первым аргументом:

\begin{english}
  \begin{clojure}
(jdbc/with-db-transaction [tx db]
  (create-user tx {:fname "User1" ...})
  (create-user tx {:fname "User2" ...}))
  \end{clojure}
\end{english}

HugSQL упрощает работу с параметрами. JDBC принимает вектор параметров, и чем их больше, тем сложнее понять, что означает каждый. HugSQL полагается на кейворды и словари. Когда у параметра есть имя, легче понять его семантику. Вдобавок на именованный параметр можно сослаться в разных местах запроса.

HugSQL предлагает множество полезных функций. Среди прочих отметим сниппеты~--- повторяющиеся участки кода. Если один и тот же фрагмент SQL встречается много раз, его задают отдельно и ссылаются на него. Предположим, мы хотим контролировать, какие поля пользователя вернет запрос. Объявим их тегом \code{:snip}:

\begin{english}
  \begin{sql}
-- :snip user-fields
id, fname, lname
  \end{sql}
\end{english}

Запрос на выборку пользователя изменится. Вместо звездочки (все поля) укажем \code{:snip:user-fields}:

\begin{english}
  \begin{sql}
-- :name get-user-by-id :? :1
-- :doc Get a single user by ID
select :snip:user-fields from users
where id = :id;
  \end{sql}
\end{english}

Чтобы выполнить запрос, передайте в параметр \code{:user-fields} вызов сниппета. Так мы получим только те поля, что объявили.

\begin{english}
  \begin{clojure}
(get-user-by-id db {:id 1 :user-fields (user-fields)})

;; {:id 1, :fname "Ivan", :lname "Petrov"}
  \end{clojure}
\end{english}

В сниппете может быть что угодно: условия \code{WHERE}, постраничная навигация с помощью \code{LIMIT} и \code{OFFSET} и так далее. Однако помните, что чем больше в запросе сниппетов, тем менее он декларативен. С ними теряется преимущества чистого SQL, о которых мы говорили.

\subsection{Выражения}

Еще одна особенность HugSQL~--- это поддержка управляющих конструкций Clojure. С помощью особого синтаксиса в запрос можно добавить код на Clojure, который соединяет его части. Прием полезен, когда запрос меняется в зависимости от параметров.

Предположим, мы пишем поиск пользователей. В отборе участвуют несколько полей: имя, город, год рождения, при этом обязательно только имя. В этом случае мы не можем составить запрос как в примере ниже:

\begin{english}
  \begin{sql}
-- :name find-users :?
SELECT * FROM users
WHERE fname = :name
  AND city = :city
  AND year = :year
LIMIT 10
  \end{sql}
\end{english}

Если не указать город или год рождения, получим ошибку:

\begin{english}
  \begin{clojure}
(find-users db {:name "Ivan"})

;; Execution error (ExceptionInfo)
;; at hugsql.core/validate-parameters! (core.clj:83).
;; Parameter Mismatch: :city parameter data not found.
  \end{clojure}
\end{english}

Отбор по необязательным полям должен быть только если значения не пустые. Правильный запрос выглядит так:

\begin{english}
  \begin{sql/lines}
-- :name find-users :?
select * from users
where fname = :name
--~ (when (:city params) "and city = :city")
--~ (when (:year params) "and year = :year")
limit 10
  \end{sql/lines}
\end{english}

Синтаксис \code{-{}-{}\~} предваряет выражение на Clojure. Оно должно вернуть строку SQL или \code{nil}. Внутри доступна переменная \code{params}~--- словарь параметров, которые передали в запрос. Выше мы проверяем: если заданы поля с городом или возрастом, добавить к \code{WHERE} отбор по ним (строки 4 и 5).

Выражение:

\begin{english}
  \begin{clojure}
(find-users db {:name "Ivan" :city "Chita"})
  \end{clojure}
\end{english}

\noindent
порождает следующий запрос:

\begin{english}
  \begin{sql}
SELECT * FROM users
WHERE fname = $1
  AND city = $2
LIMIT 10
parameters: $1 = 'Ivan', $2 = 'Chita'
  \end{sql}
\end{english}

Кроме однострочных выражений, HugSQL предлагает многострочные по следующим правилам:

\begin{english}
  \begin{sql}
/*~ (if ... */
SQL if true
/*~*/
SQL if false
/*~ ) ~*/
  \end{sql}
\end{english}

Форма \code{/*{}\~{}*/} означает переход к следующей форме Clojure, в данном случае от положительной ветви \code{if} к негативной. Обратите внимание, что последняя строка несет закрывающую скобку для \code{if}. Без нее получится ошибка синтаксиса.

Опробуем условный оператор в действии. Доработаем функцию \code{get-user-by-id} так, что если не задан сниппет полей, вернем их все. Для этого проверим \code{:user-fields} на пустоту и подставим либо \code{:snip:user-fields}, либо \code{*}.

\begin{english}
  \begin{sql}
-- :name get-user-by-id :? :1
-- :doc Get a single user by ID
SELECT
/*~ (if (:user-fields params) */
:snip:user-fields
/*~*/
*
/*~ ) ~*/
FROM users
WHERE id = :id;
  \end{sql}
\end{english}

Результат:

\begin{english}
  \begin{clojure}
(get-user-by-id db {:id 1})

{:id 1
 :fname "Ivan"
 :lname "Petrov"
 :email "..."
 :age ...}

(get-user-by-id db {:id 1 :user-fields (user-fields)})

{:id 1
 :fname "Ivan"
 :lname "Petrov"}
  \end{clojure}
\end{english}

Настоящие сложности возникают, когда управляют не отдельными полями, а таблицами. Предположим, в поиске пользователей появилось галочка <<только с фотографией>>. Снимки хранятся в отдельной таблице \code{photos}, которая связана с пользователями внешним ключом. Чтобы выбрать пользователей по наличию фото, в запросе должно быть внутреннее соединение таблиц (\code{INNER JOIN}). При этом не всегда, а только если установлен параметр. Все вместе дает нам шаблон:

\begin{english}
  \begin{sql}
-- :name find-users2 :?
SELECT * FROM users u
/*~ (when (:with-photo? params) */
JOIN photos p ON p.user_id = u.id
/*~ ) ~*/
  \end{sql}
\end{english}

Если выполнить запрос с флагом, таблица \code{photos} окажется в запросе:

\begin{english}
  \begin{clojure}
(find-users2
  db {:with-photo? true})

;; SELECT * FROM users u
;; JOIN photos p ON p.user_id = u.id
  \end{clojure}
\end{english}

Сниппеты тоже принимают параметры. Добавим в \code{user-fields} условие: если передан флаг \code{:root?}, вернуть все поля пользователя, а иначе только их часть.

\begin{english}
  \begin{sql}
-- :snip user-fields
/*~ (if (:root? params) */
*
/*~*/
id, fname, lname
/*~ ) ~*/
  \end{sql}
\end{english}

Теперь запрос с флагом вернет все поля. Обратите внимание, что параметр \code{:root?} передан именно сниппету, а не основному запросу \coderef{4}. Это гарантирует, что одноименные поля запроса и сниппета не вступят в конфликт.

\begin{english}
  \begin{clojure/lines}
(get-user-by-id
  db
  {:id 1
   :user-fields (user-fields {:root? true})})
  \end{clojure/lines}
\end{english}

HugSQL предлагает многие другие возможности. Ознакомьтесь с ними \footurl{на странице проекта}{\urlhugsqlgh}[HugSQL].

\def\urlyesql{https://github.com/krisajenkins/yesql}

Завершая раздел, отметим похожие библиотеки. \footurl{Yesql}{\urlyesql}[Yesql] предлагает схожий подход: по файлу запросов библиотека строит функции Clojure. Отличие в том, что при генерации вы указываете JDBC-спеку по умолчанию. В этом случае ее не нужно указывать явно при вызове функций. Для транзакций и особых случаев спеку передают в словаре опций. Yesql портирована на Python, Ruby, Golang и другие популярные языки.

\def\urlconman{https://github.com/luminus-framework/conman}

Еще одна библиотека называется \footurl{Conman}{\urlconman}[Conman]. Это обертка над HugSQL с некоторыми упрощениями. Conman входит в состав фреймворка Luminus и является важной его частью. Можно использовать его отдельно от Luminus в проектах на другом стеке.

\subsection{Построители}

Существует иной подход к написанию SQL, известный как Query Builder или построитель запросов. Это объект, который хранит части запроса: список полей, таблиц, условий и так далее. Вызывая методы \code{.addWhere}, \code{.addJoin} и другие, мы наполняем его состояние. Метод \code{.toString} или \code{.render} построит SQL из накопленных частей. Ниже~--- пример построителя запросов на Java:

\begin{english}
  \begin{java}
String sql = QueryBuilder.select("u.*", "p.*")
  .from("users", "u")
  .join("profiles", "p").on("p.user_id = u.id")
  .where("not u.is_deleted")
  .toString();

// SELECT u*, p* FROM users AS u
// JOIN profiles AS p ON p.user_id = u.id
// WHERE NOT u.is_deleted
  \end{java}
\end{english}

Похоже устроены библиотеки SQLAlchemy и Knex.js в Python и JavaScript.

Принцип работает и в Clojure с той разницей, что вместо объекта используют привычный словарь. Специальная функция обходит его и строит SQL. Поскольку данные неизменяемы, каждая операция над словарем вернет новый словарь. Тем самым снижается риск ошибки, что мы случайно изменим запрос, который используется в другом месте.

\def\urlhoneysql{https://github.com/seancorfield/honeysql}

Библиотека \footurl{HoneySql}{\urlhoneysql}[Honey SQL] работает по принципу <<SQL как данные>>. Добавьте ее в проект:

\begin{english}
  \begin{clojure}
[com.github.seancorfield/honeysql "2.0.0-rc5"]
  \end{clojure}
\end{english}

Создайте простой запрос в виде словаря:

\begin{english}
  \begin{clojure}
(def query
  {:select [:*]
   :from [:users]
   :where [:= :id 1]})
  \end{clojure}
\end{english}

Очевидно, ключи \code{:select}, \code{:from} и \code{:where} означают одноименные части SQL. Важно, что переменная \code{query} имеет структуру. Ей легко добавить новое поле или условие функциями \code{assoc-in} и \code{update-in}.

Функция \code{sql/format} принимает подобный словарь и возвращает вектор. Его первый элемент~--- строка запроса, а остальные~--- параметры. В нашем случае получим вектор:

\begin{english}
  \begin{clojure}
(require '[honey.sql :as sql])

(sql/format query)
;; ["SELECT * FROM users WHERE id = ?" 1]
  \end{clojure}
\end{english}

Обратите внимание, что значение 1 стало параметром, а не частью запроса. Другими словами, запрос не оказался таким:

\begin{english}
  \begin{sql}
SELECT * FROM users WHERE id = 1
  \end{sql}
\end{english}

Как мы обсуждали в начале главы, значения в запросе чреваты ошибками. Скорей всего, единица приходит извне и может содержать махинации для инъекций.

В HoneySql любое значение, отличное от символа и кейворда, означает параметр. Числа, булево и строки станут параметрами, а в запросе на их месте окажутся вопросительные знаки. Параметры установит драйвер с учетом кавычек, типов и правил безопасности. Пример со вставкой пользователя:

\begin{english}
  \begin{clojure}
(def query
  {:insert-into :users
   :columns [:id :fname :email]
   :values [[99 "Ivan" "test@test.com"]]})

(sql/format query)

["INSERT INTO users (id, fname, email)
  VALUES (?, ?, ?)"
 99
 "Ivan"
 "test@test.com"]
  \end{clojure}
\end{english}

Передайте результат в \code{jdbc/execute!}, чтобы добавить запись:

\begin{english}
  \begin{clojure}
(jdbc/execute! db (sql/format query))
  \end{clojure}
\end{english}

Чтобы сослаться на другое поле в условии, поставьте на его место кейворд или символ. Предположим, мы храним бонусные баллы пользователя. Очередная покупка прибавляет сто баллов. Вот как начислить их пользователю с номером 5:

\begin{english}
  \begin{clojure}
(def query
  {:update :users
   :set {:bonus_points [:+ :bonus_points 100]}
   :where [[:= :id 5]]})

(sql/format query)

["UPDATE users
  SET bonus_points = bonus_points + ?
  WHERE (id = ?)" 100 5]
  \end{clojure}
\end{english}

По аналогии работают операторы удаления, группировки, \code{JOIN}, \code{UNION} и другие. Для каждого из них служит одноименный ключ, который принимает другой словарь или вектор. Справку по всем ключам вы найдете на странице проекта.

Кроме словаря, библиотека предлагает другой способ составить запрос. В модуле \code{honey.sql.helpers} находятся функции, совместимые со стрелочными оператором. Каждая функция принимает предыдущий запрос и дополняет его новым полем. Перепишем пример с бонусными баллами:

\begin{english}
  \begin{clojure}
(require '[honey.sql.helpers :as h])

(def query
  (-> (h/update :users)
      (h/set {:bonus_points [:+ :bonus_points 100]})
      (h/where [[:= :id 5]])))
  \end{clojure}
\end{english}

Некоторые предпочитают такую запись, хотя технически она равнозначна наполнению словаря.

\subsection{Служебные функции}

Выше мы проделываем одну и ту же работу: получаем SQL-вектор и передаем в JDBC. Совместим эти шаги в одной функции. Она принимает два словаря~--- запрос и параметры~--- и возвращает данные из базы. Назовем ее \code{map-query}:

\begin{english}
  \begin{clojure/lines}
(defn map-query
  [db-spec map-sql & [map-params]]
  (jdbc/query db-spec
              (sql/format map-sql
                          {:params map-params})))
  \end{clojure/lines}
\end{english}

Пример с поиском пользователя по номеру:

\begin{english}
  \begin{clojure}
(def query
  {:select [:*]
   :from [:users]
   :where [:= :id :?id]})

(map-query db query {:id 13})
  \end{clojure}
\end{english}

Обратите внимание на параметр \code{:?id} в секции \code{:where}: это кейворд со знаком вопроса впереди \coderef{4}. HoneySQL считает его именным параметром. Значение параметра следует в словаре \code{:params} в аргументах \code{sql/format} (без знака вопроса, строка 6).

С новой функцией код сократится. Для б\'{о}льшего удобства поместите запросы в отдельный модуль, чтобы позже ссылаться на них. По аналогии напишите функцию \code{map-execute}, которая выполняет \code{INSERT}, \code{UPDATE} и другие операции, отличные от чтения.

\subsection{Логирование и форматирование}

Теперь когда появилась общая точка, через которую проходят все запросы, ее можно улучшить. Добавить необязательные параметры, логирование и многое другое.

Предположим, в режиме разработки мы бы хотели видеть запросы, которые посылаем к базе. Добавим отладочный лог \coderef{4}:

\begin{english}
  \begin{clojure/lines}
(defn map-query [db-spec map-sql & [map-params]]
  (let [sql-vec
        (sql/format map-sql {:params map-params})]
    (log/infof "Query: %s" (first sql-vec))
    (jdbc/query db-spec sql-vec)))
  \end{clojure/lines}
\end{english}

При вызове функции \code{map-query} увидим в консоли запись:

\begin{english}
  \begin{clojure}
(map-query db query {:id 1})

;; ... Query: SELECT * FROM users WHERE id = ?
  \end{clojure}
\end{english}

\def\urlsqlformatter{https://github.com/vertical-blank/sql-formatter}

%% TODO: сноска

К сожалению, HoneySql не поддерживает форматирование с отступами и переносами строк. Для больших запросов это становится проблемой, потому что их трудно читать в одну строку. На время разработки подключим Java-библиотеку \footurl{SqlFormatter}{\urlsqlformatter}[Sql For\-mat\-ter] для форматирования SQL. Добавьте зависимость в проект:

\begin{english}
  \begin{clojure}
[com.github.vertical-blank/sql-formatter "2.0.1"]
  \end{clojure}
\end{english}

Импортируйте одноименный класс:

\begin{english}
  \begin{clojure}
(import
  'com.github.vertical_blank.sqlformatter.SqlFormatter)
  \end{clojure}
\end{english}

Чтобы получить форматированный запрос, передайте строку SQL в статический метод \code{SqlFormatter/format}. Доработаем логирование в функции \code{map-query}:

\begin{english}
  \begin{clojure}
(defn map-query [db-spec map-sql & [map-params]]
  (let [sql-vec
        (sql/format map-sql {:params map-params})
        sql-text
        (SqlFormatter/format (first sql-vec))]
    (log/infof "Query:\n%s" sql-text)
    (jdbc/query db-spec sql-vec)))
  \end{clojure}
\end{english}

Теперь в консоли появится красиво оформленный SQL:

\begin{english}
  \begin{clojure}
(map-query db query {:id 1})

;; 2021-08-06 10:40:24,062 INFO  book.db - Query:
;; SELECT
;;  *
;; FROM
;;   users
;; WHERE
;;  id = ?
  \end{clojure}
\end{english}

По желанию его можно как-то выделить, например предварить каждую строку угловой скобкой или вертикальной чертой. Помните, что форматирование отнимает ресурсы и снижает производительность \code{map-query}. Сделайте так, чтобы логирование включалось по требованию или в зависимости от среды, например только при разработке.

Доработайте \code{map-query} так, чтобы в опциях можно было задать условие логирования, его уровень, форматирование и другие параметры.

\subsection{Расширения}

HoneySQL легко расширить оператором, которого нет по умолчанию. Технически это значит вызвать функцию \code{sql/register-clause!}. Она меняет приватный атом, где хранятся известные выражения. Функция принимает другую функцию, которая вернет вектор SQL по словарю.

Приведем пример с выражением \code{CREATE INDEX} для PostgreSQL. Это сложная команда со множеством полей и условий. Вот лишь малая часть ее синтаксиса:

\begin{english}
  \begin{sql}
CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ]
    [ [ IF NOT EXISTS ] name ]
    ON [ ONLY ] table
    [ USING method ] ...
  \end{sql}
\end{english}

Наша задача~--- сделать так, чтобы индекс можно было задать словарем. Этим мы снизим риск ошибки при написании индексов вручную. Например:

\begin{english}
  \begin{clojure}
(sql/format
  {:create-index {:if-not-exists? true
                  :name "idx_user_lname"
                  :on-table :users
                  :on-field :lname}})

;; CREATE INDEX IF NOT EXISTS idx_user_lname
;; ON users (id);
  \end{clojure}
\end{english}

Для начала обработаем главные поля индекса: имя, уникальность, имя таблицы и некоторые другие. Ниже~--- черновая версия кода, которая строит индекс:

\begin{english}
  \begin{clojure}
(sql/register-clause!
 :create-index
 (fn [_ {idx-name :name
         :keys [unique?
                if-not-exists?
                on-table
                on-field
                using]}]

   [(clojure.string/join
     " "
     ["CREATE"
      (when unique? "UNIQUE")
      "INDEX"
      (when if-not-exists? "IF NOT EXISTS")
      (name idx-name)
      "ON"
      (name on-table)
      "(" (name on-field) ")"
      (when using "USING")
      (when using using)])])
 nil)
  \end{clojure}
\end{english}

Проверим, что вернет форматирование:

\begin{english}
  \begin{clojure}
(sql/format {:create-index {:if-not-exists? true
                            :name "idx_user_lname"
                            :on-table :users
                            :on-field :lname}})

["CREATE INDEX IF NOT EXISTS idx_user_lname
  ON users ( lname )"]
  \end{clojure}
\end{english}

Если передать этот вектор в \code{jdbc/execute!}, в базе появится индекс. Доработайте ключ \code{:create-index} так, чтобы он поддерживал больше параметров индекса, в том числе специфичных для некоторых баз данных.

Кроме выражений, HoneySQL можно расширить операторами. Например, сделать так, чтобы условие:

\begin{english}
  \begin{clojure}
{:where [:= [:json->> :attributes :color] "red"]}
  \end{clojure}
\end{english}

\noindent
становилось:

\begin{english}
  \begin{clojure}
["... WHERE attributes ->> 'color' = ?" "red"]
  \end{clojure}
\end{english}

Для этого служит функция \code{sql/register-op!}, которая принимает псевдоним оператора (в нашем случае \code{:json->>}) и логику его построения. С таким подходом запросы становятся гибче. Если вы пользуетесь специфичным оператором, зарегистрируйте его в HoneySQL, чтобы не копировать код и оперативно править его в одном месте. Изучите примеры с вызовом \code{sql/register-fn!} и \code{sql/register-op!} из документации библиотеки.

\subsection{Сырой SQL}

HoneySql покрывает почти все операторы SQL, однако рано или поздно понадобится такой, которого нет в поставке. Для этого служит последнее средство~--- внедрение сырого SQL. Ключ \code{:raw} принимает текст или вектор и встраивает в запрос с минимальной обработкой. Приведем несколько примеров.

Выборка пользователей, созданных за последний день. В поле \code{:raw} следует строка SQL, где из текущей даты вычитается один день:

\begin{english}
  \begin{clojure/lines}
{:select [:*]
 :from [:users]
 :where [:>= :created_at
             [:raw "now() - interval '1 day'"]]}
  \end{clojure/lines}
\end{english}

Более сложный запрос, где атрибуты товаров дополняют цветом и размером. Оператор \code{||} объединяет два объекта JSON.

\begin{english}
  \begin{clojure}
(map-query
 db
 {:update :items
  :set {:attrs [:raw ["attrs || " [:param :new-attrs]]]}
  :returning [:id]}
 {:new-attrs {:color "red" :size "XL"}})
  \end{clojure}
\end{english}

Обратите внимание, что \code{:raw} принимает не только строку, но и вектор элементов \coderef{4}. Во втором запросе один из элементов~--- вектор с тегом \code{:param}. Это необходимо, чтобы словарь \code{:new-attrs} остался параметром вместо того, чтобы стать частью запроса.

Будьте особенно осторожны с сырым SQL: не допускайте, чтобы в нем был ввод пользователя. Добавляйте его только ключом \code{:raw}, но ни в коем случае не конкатенацией строк. Сюда же относятся автозамена, разбиение и другие операции со строками. Все они будут ошибкой.

\subsection{Повторное использование запросов}

Как мы выяснили, некоторые части запроса можно использовать повторно. Это может быть набор полей или условий. HugSQL предлагает сниппеты~--- именованные участки кода, которые передают в параметрах. В HoneySQL это делается проще: поскольку речь идет о неизменяемых коллекциях, все решается силами Clojure.

Рассмотрим таблицу пользователей. Приложение часто обращается к ним: читает всех пользователей, ищет по имени или городу, находит конкретного человека по электронной почте. У этих запросов общая часть: имя таблицы и список полей, которые получит клиент. Вынесем ее в переменную, на которую позже будем ссылаться. По-другому ее называют <<тушкой>> запроса:

\begin{english}
  \begin{clojure}
(def user-base
  {:select [:*]
   :from [:users]})
  \end{clojure}
\end{english}

Если выполнить <<тушку>>, получим всех пользователей. Чтобы задать отбор по имени и ограничить длину выборки, добавим эти критерии с помощью \code{assoc}:

\begin{english}
  \begin{clojure}
(map-query db
           (assoc user-base
                  :where [:= :fname "Ivan"]
                  :limit 9))
  \end{clojure}
\end{english}

Переменная \code{user-base} не изменится от новых ключей и не повлияет на дальнейшие запросы.

Усложним задачу поиском по многим полям. В зависимости от того, заполнено поле или нет, мы должны добавить его в \code{WHERE}. Обратимся к макросу \code{cond->}, который подходит к этой задаче. Он пропускает данные через серию предикатов и форм, при этом каждая форма получает результат предыдущей.

Предположим, при поиске пользователя имя обязательно для заполнения, а почта и возраст~--- нет. В этом случае составим запрос на основе \code{user-base} с отбором по имени. Затем, если заданы почта и возраст, дополним секцию \code{WHERE}:

\begin{english}
  \begin{clojure}
(let [q-fname (get params :name)  ;; "Ivan"
      q-email (get params :email) ;; "test@test.com"
      q-age   (get params :age)   ;; nil
      query
      (assoc user-base
             :where [:and [:= :fname q-fname]])]

  (cond-> query
    q-age
    (update :where conj [:= :age q-age])
    q-email
    (update :where conj [:= :email q-email])))
  \end{clojure}
\end{english}

Результат:

\begin{english}
  \begin{clojure}
{:select [:*]
 :from [:users]
 :where [:and
         [:= :fname "Ivan"]
         [:= :email "test@test.com"]]}
  \end{clojure}
\end{english}

Похоже работает условное соединение таблиц. Если задан флаг <<с фотографией>>, добавим в словарь поле \code{:join} с таблицей \code{photos}:

\begin{english}
  \begin{clojure}
(let [q-fname (get params :name)           ;; "Ivan"
      with-photo? (get params :with_photo) ;; true
      query
      (assoc user-base
             :where [:and [:= :fname q-fname]])]

  (cond-> query
    with-photo?
    (assoc :join
           [:photos [:= :users.id :photos.user_id]])))
  \end{clojure}
\end{english}

Если передать результат в \code{sql/format}, получим запрос:

\begin{english}
  \begin{sql}
SELECT * FROM users
INNER JOIN photos ON users.id = photos.user_id
WHERE (fname = 'Ivan')
  \end{sql}
\end{english}

Усложним поиск еще больше. До сих пор мы использовали равенство полей, но на практике встречаются диапазоны и частичные совпадения. Например, цена от и до при поиске товара или вхождение слова в строку.

Доработайте код так, чтобы возраст можно было задать границами. Теперь мы ожидаем не одно, а два поля: \code{age\_\_min} и \code{age\_\_max}. Обратите внимание на двойное подчеркивание: оно отделяет имя поля (\code{age}) от оператора сравнения (\code{min}, больше или \code{max}, меньше). Для почты, города и других строковых полей напишите оператор вхождения: \code{name\_\_contains}, \code{city\_\_contains} и другие.

\subsection{Аналоги}

\def\urlsqlingvo{https://github.com/r0man/sqlingvo}
\def\urltoucan{https://github.com/metabase/toucan}

Перечислим аналоги HoneySQL. Это \footurl{SQLingvo}{\urlsqlingvo}[SQLingvo], \footurl{Toucan}{\urltoucan}[Toucan], Korma и другие. Все они так или иначе строят SQL с помощью данных, которые позже становятся строкой. Изучив с HoneySQL, вы без труда освоите эти библиотеки, потому что они исповедуют тот же подход.

\def\urlkorma{https://github.com/korma/Korma}

Отдельно отметим фреймворк \footurl{Korma}{\urlkorma}[Korma], потому что он делает шаг в сторону ORM. В нем объявляют сущности базы данных, по которым позже строят запросы. Korma понравится тем, кто работал с фреймворками Django или Rails и теперь ищет что-то подобное.

\subsection{Промежуточный итог}

Мы рассмотрели два способа работы с SQL: шаблоны и данные. В первом случае пишут сырой SQL, который позже становится функциями. Во втором случае запросы получают из словарей и списков. Что выбрать?

Вариант с шаблонами хорош тем, что мысленно вы остаетесь на уровне базы. Запрос легко скопировать в PGAdmin и выполнить там, доработать и перенести обратно в проект. Если в фирме есть специалист по базам данных, он проведет аудит запросов: найдет медленные выражения, не оптимальные операторы \code{WHERE} и \code{JOIN}.

Наоборот, когда запросы заданы словарями, за ними плохо видна логика SQL. Для сложных запросов это становится проблемой. Иногда их пишут в исходном виде, долго тестируют и только затем приводят к виду HoneySQL. Получается двойная работа.

С другой стороны, запросы в виде данных легче использовать повторно. Если в нескольких запросах повторяется одно выражение, его легко вынести в переменную. Словари и списки удобней наращивать формами \code{assoc-in} и \code{cond->}, нежели добавлять код на Clojure в шаблоны SQL.

Оба способа равнозначны, потому нельзя с уверенностью сказать, что лучше. Чтобы определиться, испытайте то и другое на практике.

\section{Структура и группировка}

Библиотеки, что мы рассмотрели выше, только составляют запрос, но не влияют на его обработку. Независимо от того, что вы предпочитаете~--- шаблоны или данные~--- вы столкнетесь с тем, что выполнить запрос еще не достаточно. Часто ответ базы нуждается в обработке из-за вложенных данных. Рассмотрим, что это за проблема и как ее решить.

В сердце реляционных баз данных лежат отношения между таблицами. Почти все операции над ними возвращают таблицы. Прибегая к аналогии, можно сказать, что из прямоугольников можно выложить только прямоугольные формы, но не круглые или треугольные. В общем случае база хранит плоские данные и не может построить из них дерево.

На практике мы имеем дело с подчиненными сущностями. Например, у организации несколько филиалов и в каждом из них департаменты. У автора несколько статей, а у статей~--- комментарии. Товары делятся на категории и подкатегории, заказ состоит из этапов и так далее. Это значит, не достаточно просто выбрать сущности по типу, например отдельно авторов и статьи:

\begin{english}
  \begin{clojure}
;; authors
[{:id 1 :name "Ivan Petrov"}
 {:id 2 :name "Ivan Rublev"}]

;; posts
[{:id :title "Introduction to Python" :author-id 1}
 {:id :title "Thoughts on LISP" :author-id 2}]
  \end{clojure}
\end{english}

Мы должны выразить их структуру:

\begin{english}
  \begin{clojure}
[{:id 1
  :name "Ivan Petrov"
  :posts [{:id
           :title "Introduction to Python"
           :author-id 1}]}
 {:id 2
  :name "Ivan Rublev"
  :posts [{:id
           :title "Thoughts on LISP"
           :author-id 2}]}]
  \end{clojure}
\end{english}

На этом месте реляционные базы проявляют <<прямоугольные>> свойства. Без особых ухищрений нельзя получить ответ как в примере выше. Проверим это на практике: создадим таблицы с подчиненными сущностями и выберем из них данные.

Первый шаг, таблицы авторов и статей:

\begin{english}
  \begin{sql}
CREATE TABLE authors (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL
);

CREATE TABLE posts (
  id SERIAL PRIMARY KEY,
  title TEXT NOT NULL,
  author_id INTEGER REFERENCES authors(id)
);
  \end{sql}
\end{english}

Добавим минимальный набор данных: два автора четыре статьи и по две статьи на каждого.

\begin{english}
  \begin{sql}
INSERT INTO authors (id, name) VALUES
  (1, 'Ivan Petrov'),
  (2, 'Ivan Rublev');

INSERT INTO posts (id, author_id, title) VALUES
  (10, 1, 'Introduction to Python'),
  (20, 1, 'Thoughts on LISP'),
  (30, 2, 'Learning Clojure'),
  (40, 2, 'Working on my pet project');
  \end{sql}
\end{english}

Третий шаг: выберем авторов и их статьи:

\begin{english}
  \begin{sql}
SELECT *
FROM authors a
JOIN posts p ON p.author_id = a.id;
  \end{sql}
\end{english}

Результат:

\begin{english}
  \begin{text*}{fontsize=\small}
id |    name     | id |            title          | author_id
---+-------------+----+---------------------------+----------
 1 | Ivan Petrov | 10 | Introduction to Python    |         1
 1 | Ivan Petrov | 20 | Thoughts on LISP          |         1
 2 | Ivan Rublev | 30 | Learning Clojure          |         2
 2 | Ivan Rublev | 40 | Working on my pet project |         2
  \end{text*}
\end{english}

%% \begin{table}[H]
%% \resizebox{\columnwidth}{!}{\begin{tabular}{|l|l|l|l|l|}
%% \hline
%% id & name & id & title & author\_id \\
%% \hline
%%  1  &  Ivan Petrov  &  10  &  Introduction to Python     & 1 \\
%%  1  &  Ivan Petrov  &  20  &  Thoughts on LISP           & 1 \\
%%  2  &  Ivan Rublev  &  30  &  Learning Clojure           & 2 \\
%%  2  &  Ivan Rublev  &  40  &  Working on my pet project  & 2 \\
%% \hline
%% \end{tabular}}
%% \end{table}

Видим, что родительская сущность (автор) повторяется столько раз, столько у нее дочерних записей (статей). Результат нельзя вывести в плоском виде, потому что пользователь ожидает структуру. Наверняка он хочет увидеть вложенный список:

\begin{itemize}
\item
  Ivan Petrov
  \begin{itemize}
    \item
      Introduction to Python
    \item
      Thoughts on LISP
  \end{itemize}
\item
  Ivan Rublev
  \begin{itemize}
    \item
      Learning Clojure
    \item
      Working on my pet project
  \end{itemize}
\end{itemize}

Ситуация ухудшается, если у дочерних записей есть другие дочерние, например оценки или комментарии. Это приведет к еще большим повторам родителей.

Проблема структуры не так проста, какой кажется на первый взгляд; она может серьезно задержать разработку. Требуется общий подход к решению задачи~--- такой, чтобы можно было группировать сущности, зная о них как можно меньше. Мы рассмотрим два способа: на уровне кода и базы данных.

\subsection{Выборка по слоям}

Наиболее простой способ в том, чтобы выбрать главную и подчиненные сущности по отдельности. Предположим, мы знаем номер автора, которого нужно найти. Первый запрос вернет его по первичному ключу:

\begin{english}
  \begin{clojure}
(def author-id 1)

(jdbc/get-by-id db :authors author-id)
;; {:id 1 :name "Ivan Petrov"}
  \end{clojure}
\end{english}

Статьи получим запросом, где ссылка на автора равна его номеру:

\begin{english}
  \begin{clojure}
(jdbc/find-by-keys db :posts {:author_id author-id})

({:id 10, :title "Introduction to Python", :author_id 1}
 {:id 20, :title "Thoughts on LISP", :author_id 1})
  \end{clojure}
\end{english}

Соедининим результаты, и ответ готов:

\begin{english}
  \begin{clojure}
(let [author-id 1
      author (jdbc/get-by-id ...)
      posts (jdbc/find-by-keys ...)]
  (assoc author :posts posts))
  \end{clojure}
\end{english}

Хоть это и наивное решение, оно имеет право на жизнь. Мы совершаем строго два запроса, что не нагрузит базу данных. При желании их можно запустить параллельно.

Задача усложняется, когда автора ищут по имени или рейтингу, отчего номер заранее неизвестен. В этом случае выбирают родительские записи (их будет несколько), а затем дочерние, что на них ссылаются.

Поиск авторов по имени:

\begin{english}
  \begin{clojure}
(jdbc/query db ["SELECT * FROM authors
                 WHERE name = ?" "Ivan"])

;; ({:id 1 ...} {:id 2 ...})
  \end{clojure}
\end{english}

Получили несколько записей. Возникает вопрос, как найти дочерние. Если делать это в цикле для каждого родителя, как в примере ниже, мы произведем столько же запросов, сколько и авторов:

\begin{english}
  \begin{clojure}
(for [author authors]
  (let [{:keys [id]} author
        posts (jdbc/find-by-keys
                db :posts {:author_id id})]
    (assoc author :posts posts)))
  \end{clojure}
\end{english}

Это неэффективно: с ростом выборки число запросов будет расти линейно. Если запрос по имени вернул тысячу авторов, мы тысячу раз обратимся к базе.

Другой способ в том, чтобы получить номера авторов и составить запрос вида:

\begin{english}
  \begin{sql}
... FROM posts WHERE author_id IN (?, ?, ...)
  \end{sql}
\end{english}

\noindent
, где знаков вопроса столько же, сколько авторов. Получится один запрос к базе. Если добавить индекс на поле \code{posts.author\_id}, это ускорит выборку.

Заметим, что выражение \code{IN (...)} требует усилий в построении. Это не один, а несколько параметров, разделенных запятой. Их позиция должна совпадать с позицией значения в векторе SQL. Если поиск по имени нашел десять авторов, вот как выглядит вектор SQL с поиском статей:

\begin{english}
  \begin{clojure}
(jdbc/query db
            ["SELECT * FROM posts WHERE author_id
              IN (?,?,?,?,?,?,?,?,?,?)"
             1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
  \end{clojure}
\end{english}

Библиотеки пытаются облегчить подобную запись. В HugSQL для этого служит оператор \code{where id in (:v*:ids)}~--- частичка \code{:v*} означает вектор параметров с именем \code{ids}. HoneySQL предлагает форму \code{:in} с похожей семантикой.

\def\urlfetchrelated{https://docs.djangoproject.com/en/4.1/ref/models/querysets/\#prefetch-related}

В современных ORM такая выборка называется fetch related, извлечь связанные записи. Например, в Django ORM у объекта \code{QuerySet} есть одноименный метод \footurl{\code{prefetch\_related}}{\urlfetchrelated}[Prefetch related]. С его помощью данные извлекают послойно: сперва сущности первого порядка, затем те, что ссылаются на них, затем потомки потомков и так далее. Можно управлять вложенностью и другими параметрами.

Напишем функцию на Clojure, которая выбирает <<слой>> сущностей. Она ожидает подключение к базе, таблицу, имя внешнего ключа и список их значений.

\begin{english}
  \begin{clojure}
(defn fetch-related
  [db-spec table fk-name fk-vals]
  (jdbc/query
   db-spec
   (sql/format
   {:select [:*]
    :from [table]
    :where [[:in fk-name fk-vals]]})))
  \end{clojure}
\end{english}

Пример ее вызова:

\begin{english}
  \begin{clojure}
(fetch-related db :posts :author_id [1..10])
;; ["SELECT * FROM posts WHERE
;;   (author_id IN (?, ?, ...))" 1 2 ...]
  \end{clojure}
\end{english}

Номера авторов получим формой \code{(mapv :id authors)} из предыдущего результата.

Будьте осторожны с оператором \code{IN}. Когда параметров много, это замедляет выборку. Поиск авторов может вернуть сто тысяч записей, что породит запрос с таким же числом параметров. Трудно обозначить конкретный порог для \code{IN}, потому что он зависит от окружения. В одном из проектов, над которым работал автор, таким порогом было число 100. Другими словами, в оператор \code{WHERE ... IN (...)} разрешалось передать не более ста параметров.

Это условие меняет код. Мы не знаем заранее, сколько ключей получим из базы, поэтому приходиться делать запросы в цикле. Для этого разбиваем список ключей по сотням и наполняем единый результат. Очевидно, должна быть универсальная функция, которая проходит цикл. Если каждый раз копировать код, вы не избежите ошибок.

Проще всего сделать выборку через \code{loop} или \code{reduce}:

\begin{english}
  \begin{clojure}
(defn by-chunks [coll n]
  (partition n n [] coll))

(reduce
 (fn [result ids-chunk]
   (let [rows (fetch-related ... ids-chunk)]
     (into result rows)))
 []
 (by-chunks ids-all 100))
  \end{clojure}
\end{english}

Опробуйте выборку в полупараллельном режиме через \code{pmap}. Функция строит ленивую коллекцию футур, которые выполняются по мере ее чтения. Окно коллекции (chunk size) равно числу ядер компьютера, умноженному на два.

\begin{english}
  \begin{clojure}
(let [ids-chunks
      (by-chunks ids-all 100)

      futs
      (pmap (fn [ids-chunk]
              (fetch-related ... ids-chunk))
            ids-chunks)]

  (reduce
   (fn [result fut]
     (into result @fut))
   []
   futs))
  \end{clojure}
\end{english}

Оператор \code{IN} можно записать в виде условия \code{ANY} с массивом. Синтаксис читается как <<поле \code{id} равно хотя бы одному элементу>>:

\begin{english}
  \begin{clojure}
SELECT * FROM authors WHERE id = ANY('{1,2,3,4,5}');
  \end{clojure}
\end{english}

Следующий код показывает, как передать массив в параметры запроса. Для начала получим соединение с базой:

\begin{english}
  \begin{clojure}
(def ^java.sql.Connection conn
  (jdbc/get-connection db))
  \end{clojure}
\end{english}

Соединение нужно для того, чтобы построить объект массива. Метод \code{.createArrayOf} принимает тип элемента и массив объектов \code{Object} с номерами сущностей.

\begin{english}
  \begin{clojure}
(def array
  (.createArrayOf conn "INTEGER"
                  (object-array [1 2 3 4 5])))
  \end{clojure}
\end{english}

Чтобы установить массив в параметр, расширим протокол \code{ISQLParameter} для типа \code{java.sql.Array}. По умолчанию JDBC вызывает метод \code{.setObject}, что не подходит для массива. Реализуем метод \code{set-parameter} так, что у подготовленного выражения вызывается метод \code{.setArray}:

\begin{english}
  \begin{clojure}
(extend-protocol jdbc/ISQLParameter
  java.sql.Array
  (set-parameter [val ^PreparedStatement stmt ix]
    (.setArray stmt ix val)))
  \end{clojure}
\end{english}

После всех подготовок выполните запрос с массивом. Он будет правильно передан в запрос:

\begin{english}
  \begin{clojure}
(def array
  (.createArrayOf conn "INTEGER"
                  (object-array [1 2 3 4 5])))

(jdbc/query db ["select * from authors
                 where id = ANY(?)" array])

({:id 1 :name "Ivan Petrov"}
 {:id 2 :name "Ivan Rublev"})
  \end{clojure}
\end{english}

Сократим код при помощи служебной функции \code{make-db-array}. По спеке, типу и вектору значений она вернет экземпляр \code{java.sql.Array}:

\begin{english}
  \begin{clojure}
(defn make-db-array
  [db-spec db-type values]
  (let [conn (jdbc/get-connection db)]
    (.createArrayOf conn db-type
                    (object-array values))))

(make-db-array db "integer" [1 2 3])

;; #object[o.p.j.PgArray "{\"1\",\"2\",\"3\"}"]
  \end{clojure}
\end{english}

\subsection{Ручная группировка}

Выбрать смежные записи можно оператором \code{JOIN}. С ним мы получим данные одним запросом. Порой это выгодней обхода по слоям, который совершает серию запросов. Даже если выборка не обладает нужной структурой, ее обрабатывают в коде, в то время как база обслуживает других клиентов.

С другой стороны, на больших таблицах оператор \code{JOIN} замедляется, особенно если условие связи не попадает в индекс. Производительность таких запросов зависит от окружения, оборудования и прочих факторов.

Пример запроса с \code{JOIN}, который вернет плоские данные. Обратите внимание на повторы в первых трех колонках (авторах):

\begin{english}
  \begin{sql}
SELECT *
FROM authors a
JOIN posts p ON p.author_id = a.id;
  \end{sql}
\end{english}

\begin{english}
  \begin{text*}{fontsize=\small}
id |    name     | id |            title          | author_id
---+-------------+----+---------------------------+----------
 1 | Ivan Petrov | 10 | Introduction to Python    |         1
 1 | Ivan Petrov | 20 | Thoughts on LISP          |         1
 2 | Ivan Rublev | 30 | Learning Clojure          |         2
 2 | Ivan Rublev | 40 | Working on my pet project |         2
  \end{text*}
\end{english}

%% \begin{table}[H]
%% \resizebox{\columnwidth}{!}{\begin{tabular}{|l|l|l|l|l|}
%% \hline
%% id & name & id & title & author\_id \\
%% \hline
%%  1  &  Ivan Petrov  &  10  &  Introduction to Python     & 1 \\
%%  1  &  Ivan Petrov  &  20  &  Thoughts on LISP           & 1 \\
%%  2  &  Ivan Rublev  &  30  &  Learning Clojure           & 2 \\
%%  2  &  Ivan Rublev  &  40  &  Working on my pet project  & 2 \\
%% \hline
%% \end{tabular}}
%% \end{table}

Первый шаг к группировке~--- задать полям уникальные имена. В выборке два поля \code{id}, и может возникнуть путаница где чей номер. Чтобы этого избежать, укажем псевдонимы с пространством имен. Из-за символа \code{/} их нужно заключить в двойные кавычки.

\begin{english}
  \begin{sql}
SELECT
  a.id        as "author/id",
  a.name      as "author/name",
  p.id        as "post/id",
  p.title     as "post/title",
  p.author_id as "post/author-id"
FROM authors a
JOIN posts p ON p.author_id = a.id;
  \end{sql}
\end{english}

Польза подобных имен в том, что мы получим словари с ключами \code{:author/id}, \code{:post/id} и другими, что удобно для работы в Clojure.

Каждая запись содержит <<слипшиеся>> сущности~--- автора и публикацию~--- и наша задача разделить их. Простой способ это сделать~--- написать функции \code{get-author} и \code{get-post} с явной выборкой ключей:

\begin{english}
  \begin{clojure}
(defn get-author [db-row]
  (select-keys db-row [:author/id :author/name]))

(defn get-post [db-row]
  (select-keys db-row
    [:post/id :post/title :post/author-id]))
  \end{clojure}
\end{english}

Проверка функций:

\begin{english}
  \begin{clojure}
(def row
  {:author/id 1
   :author/name "Ivan Petrov"
   :post/id 10
   :post/title "Introduction to Python"
   :post/author-id 1})

(get-author row)
;; #:author{:id 1 :name "Ivan Petrov"}

(get-post row)
;; #:post{:id 10
;;        :title "Introduction to Python"
;;        :author-id 1}
  \end{clojure}
\end{english}

Выполним обход всех записей. На каждом шаге разделим запись на сущности и наполним пустой словарь.

\begin{english}
  \begin{clojure}
(reduce
 (fn [result row]
   (let [author    (get-author row)
         post      (get-post row)
         author-id (:author/id author)
         post-id   (:post/id post)]
     (-> result
         (update-in [:authors author-id]
                    merge author)
         (update-in [:authors author-id
                     :author/posts post-id]
                    merge post))))
 {}
 db-result)
  \end{clojure}
\end{english}

Распечатаем результат. Видим, что статьи сгруппированы по авторам:

\begin{english}
  \begin{clojure*}{fontsize=\small}
{:authors
 {1 {:author/id 1
     :author/name "Ivan Petrov"
     :author/posts
       {10 {:post/id 10
            :post/title "Introduction to Python"
            :post/author-id 1}
        20 {:post/id 20
            :post/title "Thoughts on LISP"
            :post/author-id 1}}}
  2 {:author/id 2
     :author/name "Ivan Rublev"
     :author/posts
       {30 {:post/id 30
            :post/title "Learning Clojure"
            :post/author-id 2}
        40 {:post/id 40
            :post/title "Working on my pet project"
            :post/author-id 2}}}}}
  \end{clojure*}
\end{english}

Теперь можно отдать эти данные клиенту в виде JSON. Заметим, мы выполнили только один обход функцией \code{reduce}, что немаловажно. Если алгоритм требует два и более обходов выборки, с ее ростом код замедлится.

Расширим алгоритм под тройную вложенность. Предположим, к статьям оставляют комментарии и мы бы хотели видеть несколько последних. Для начала добавим комментарии в базу:

\begin{english}
  \begin{sql}
CREATE TABLE comments (
  id SERIAL PRIMARY KEY,
  text TEXT NOT NULL,
  post_id INTEGER NOT NULL REFERENCES posts(id)
);

INSERT INTO comments (id, post_id, text) VALUES
  (100, 10, 'Thanks for sharing this!'),
  (200, 10, 'Nice reading, it was useful.'),
  (300, 30, 'TL;DR: you must learn lisp');
  \end{sql}
\end{english}

Новый запрос включает авторов, статьи и комментарии к ним. Обратите внимание на разницу в операторах \code{JOIN}. Для таблицы \code{posts} это \code{(INNER) JOIN} \coderef{10}. С ним мы пропустим авторов, у которых нет статей. Но для \code{comments} используем \code{LEFT JOIN}, чтобы оставить статьи без комментариев \coderef{11}.

\begin{english}
  \begin{sql/lines}
SELECT
  a.id        as "author/id",
  a.name      as "author/name",
  p.id        as "post/id",
  p.title     as "post/title",
  p.author_id as "post/author-id",
  c.id        as "comment/id",
  c.text      as "comment/text"
FROM authors a
JOIN posts p ON p.author_id = a.id
LEFT JOIN comments c ON c.post_id = p.id;
  \end{sql/lines}
\end{english}

Повторов станет еще больше:

%% \begin{table}[H]
%% \resizebox{\columnwidth}{!}{\begin{tabular}{|l|l|l|l|l}
%% \hline
%% author/id & author/name & post/id &         post/title           & \ldots \\
%% \hline
%%          1 & Ivan Petrov &      10 & Introduction to Python      & \ldots \\
%%          1 & Ivan Petrov &      10 & Introduction to Python      & \ldots \\
%%          2 & Ivan Rublev &      30 & Learning Clojure            & \ldots \\
%%          1 & Ivan Petrov &      20 & Thoughts on LISP            & \ldots \\
%%          2 & Ivan Rublev &      40 & Working on my pet project   & \ldots \\
%% \hline
%% \end{tabular}}

%% \vspace{3mm}

%% \resizebox{\columnwidth}{!}{\begin{tabular}{l|l|l|l|}
%% \hline
%% \ldots         & post/author-id & comment/id &         comment/text \\
%% \hline
%% \ldots   &              1 &        100 & Thanks for sharing this!       \\
%% \ldots   &              1 &        200 & Nice reading, it was useful.   \\
%% \ldots   &              2 &        300 & TL;DR: you must learn lisp     \\
%% \ldots   &              1 &            &                                \\
%% \ldots   &              2 &            &                                \\
%% \hline
%% \end{tabular}}
%% \end{table}

\begin{english}
  \begin{text*}{fontsize=\small}
 author/id | author/name | post/id |         post/title         | ..
-----------+-------------+---------+----------------------------+---
         1 | Ivan Petrov |      10 | Introduction to Python     | ..
         1 | Ivan Petrov |      10 | Introduction to Python     | ..
         2 | Ivan Rublev |      30 | Learning Clojure           | ..
         1 | Ivan Petrov |      20 | Thoughts on LISP           | ..
         2 | Ivan Rublev |      40 | Working on my pet project  | ..

.. | post/author-id | comment/id |         comment/text         |
---+----------------+------------+------------------------------+
.. |              1 |        100 | Thanks for sharing this!     |
.. |              1 |        200 | Nice reading, it was useful. |
.. |              2 |        300 | TL;DR: you must learn lisp   |
.. |              1 |            |                              |
.. |              2 |            |                              |
  \end{text*}
\end{english}

Доработаем прошлый код. Прежде всего, в функциях \code{get-author}, \code{get-post} и других нет смысла. Сущности определяются пространством, например, все ключи с пространством \code{:author/} относятся к авторам. Напишем общую функцию \code{get-entity}, которая принимает пространство и запись базы данных. Функция отбирает только те ключи, пространства которых совпадают с указанным.

\begin{english}
  \begin{clojure}
(defn get-entity [db-row entity]
  (reduce-kv
   (fn [result k v]
     (if (= (namespace k) entity)
       (assoc result k v)
       result))
   {}
   db-row))
  \end{clojure}
\end{english}

С ней мы получим любую сущность:

\begin{english}
  \begin{clojure}
(get-entity row "author")
#:author{:id 1 :name "Ivan Petrov"}

(get-entity row "post")
#:post{:id 10
       :title "Introduction to Python"
       :author-id 1}
  \end{clojure}
\end{english}

Более универсальное решение: напишем функцию, которая принимает запись и вернет словарь вида \{имя сущности \arr сущность\}:

\begin{english}
  \begin{clojure}
(defn row->entities [db-row]
  (reduce-kv
   (fn [result k v]
     (assoc-in result [(namespace k) k] v))
   {}
   db-row))
  \end{clojure}
\end{english}

Пример ее работы:

\begin{english}
  \begin{clojure}
(row->entities row)

{"author" #:author{:id 1
                   :name "Ivan Petrov"}
 "post" #:post{:id 10
               :title "Introduction to Python"
               :author-id 1}}
  \end{clojure}
\end{english}

Чтобы назначить сущности переменным, применим синтаксис \code{:strs} для разбиения словаря с ключами-строками. Это значительно экономит код.

\begin{english}
  \begin{clojure}
(let [{:strs [author
              post
              comment]}
      (row->entities row)]
  ...)
  \end{clojure}
\end{english}

Новый обход с учетом комментариев:

\begin{english}
  \begin{clojure}
(reduce
 (fn [result row]
   (let [{:strs [author post comment]}
         (row->entities row)

         {author-id :author/id}   author
         {post-id :post/id}       post
         {comment-id :comment/id} comment]

     (cond-> result
       :then
       (update-in [:authors
                   author-id] merge author)

       :then
       (update-in [:authors
                   author-id
                   :author/posts
                   post-id] merge post)

       comment-id
       (update-in [:authors
                   author-id
                   :author/posts
                   post-id
                   :post/comments
                   comment-id] merge comment))))
 {}
 db-result)
  \end{clojure}
\end{english}

Обратите внимание: вместо линейного оператора \code{\arr} мы используем условный \code{cond\arr}. С ним комментарий добавляется к результату только если поле \code{comment-id} не пустое. Проверка необходима, потому что комментарий может быть пустым. Результат приведен на странице справа в листинге \ref{lis:nested-result}.

\begin{figure}[ht!]

\begin{english}
  \begin{clojure*}{fontsize=\small}
{:authors
 {1 {:author/id 1
     :author/name "Ivan Petrov"
     :author/posts
       {10 {:post/id 10
            :post/title "Introduction to Python"
            :post/author-id 1
            :post/comments
              {100 {:comment/id 100
                    :comment/text "Thanks for sharing this!"
                    :comment/post-id 10}
               200 {:comment/id 200
                    :comment/text "Nice reading, it was useful."
                    :comment/post-id 10}}}
        20 {:post/id 20
            :post/title "Thoughts on LISP"
            :post/author-id 1}}}
  2 {:author/id 2
     :author/name "Ivan Rublev"
     :author/posts
       {30 {:post/id 30
            :post/title "Learning Clojure"
            :post/author-id 2
            :post/comments
              {300 {:comment/id 300
                    :comment/text "TL;DR: you must learn lisp"
                    :comment/post-id 30}}}
        40 {:post/id 40
            :post/title "Working on my pet project"
            :post/author-id 2}}}}}
  \end{clojure*}
\end{english}

%% TODO: рисунок

\caption{Группировка авторов, статей и комментариев}
\label{lis:nested-result}

\end{figure}

Из примеров напрашивается общая функция группировки. Они принимает результат базы и описание сущностей: их поля и связи между родителем и потомком. По этим данным функция обходит выборку и наполняет результат. С учетом всех тонкостей код будет велик, поэтому оставим эту задачу в качестве упражнения.

\subsection{Порядок записей}

У нашего обхода один недостаток. Предположим, мы выбрали данные из базы в особом порядке: авторы~--- по алфавиту, статьи~--- по дате публикации, комментарии~--- по числу плюсов. Поскольку мы группируем сущности в словарях, порядок записей нарушается. Если отправить данные из прошлого примера клиенту, он будет вынужден сортировать их заново, что неудобно.

Чтобы клиент был доволен, после группировки мы должны восстановить порядок записей. В техническом плане поля \code{:authors}, \code{:author/posts} и \code{:post/comments} должны стать списками, элементы которых идут в той же последовательности, что и в выборке. Для этого назначим сущностям поле \code{:db/index} с числом~--- номер записи. Чтобы знать индекс на каждом шаге, напишем служебную функцию \code{enumerate}. Она превращает коллекцию в список пар, где первый элемент~--- индекс от нуля:

\begin{english}
  \begin{clojure}
(def enumerate
  (partial map-indexed vector))

(enumerate ["a" "b" "c"])
;; ([0 "a"] [1 "b"] [2 "c"])
  \end{clojure}
\end{english}

Группировка сущностей тоже изменится: теперь она принимает индекс и добавляет его к каждой сущности.

\begin{english}
  \begin{clojure}
(defn row->entities [idx db-row]
  (reduce-kv
   (fn [result k v]
     (update result
             (namespace k)
             assoc
             k v
             :db/index idx))
   {}
   db-row))
  \end{clojure}
\end{english}

Пример:

\begin{english}
  \begin{clojure}
(row->entities 3 {:post/id 1 :author/id 2})

{"post" {:post/id 1 :db/index 3}
 "author" {:author/id 2 :db/index 3}}
  \end{clojure}
\end{english}

Новый обход отличается тем, что \code{reduce} принимает результат \code{enumerate}. Индекс каждой записи передается в \code{row->\-entities}:

\begin{english}
  \begin{clojure}
(reduce
 (fn [result [idx row]]
   (let [{:strs [author post comment]}
         (row->entities idx row)]
     ...))
 {}
 (enumerate db-result))
  \end{clojure}
\end{english}

Приведем малую часть результата:

\begin{english}
  \begin{clojure*}{fontsize=\small}
{:authors
 {1 {:author/id 1
     :db/index 3
     :author/posts
     {10 {:post/id 10
          :db/index 1
          :post/comments
          {100 {:comment/id 100
                :db/index 0
                :comment/post-id 10}
           200 {:comment/id 200
                :db/index 1
                :comment/post-id 10}}}}}}}
  \end{clojure*}
\end{english}

Видим, что в каждой сущности появилось поле \code{:db/index}. Изменим дерево так, чтобы словари \code{:authors}, \code{:author/posts} и \code{:post/comments} стали вектором, упорядоченным по этому полю. Проще всего это сделать модулем \code{clojure.walk}. Подготовим проверку на элемент словаря:

\begin{english}
  \begin{clojure}
(def entry?
  (partial instance? clojure.lang.MapEntry))
  \end{clojure}
\end{english}

Укажем теги, которые нуждаются в сортировке:

\begin{english}
  \begin{clojure}
(def nested-tags
  #{:authors :author/posts :post/comments})
  \end{clojure}
\end{english}

Вот как выглядит <<ремаппинг>> сущностей. Если текущая форма~--- элемент словаря, а ключ~--- один из тех, что нуждается в сортировке, то значение (вложенный словарь) приводится к вектору, элементы которого~--- значения вложенного словаря, упорядоченные по \code{:db/index}.

\begin{english}
  \begin{clojure}
(defn remap-entities
  [form]
  (if (entry? form)
    (let [[k v] form]
      (if (contains? nested-tags k)
        [k (->> v vals (sort-by :db/index) vec)]
        form))
    form))
  \end{clojure}
\end{english}

Мы используем префикс \code{remap-} вместо \code{sort-} для имени функции, потому что она не только сортирует сущности, но и меняет их структуру. Подключим модуль \code{clojure.walk} и вызовем \code{prewalk} с новой функцией и результатом группировки:

\begin{english}
  \begin{clojure}
(require '[clojure.walk :as walk])

(:authors
 (walk/prewalk remap-entities result-grouped))
  \end{clojure}
\end{english}

Результат с небольшими сокращениями:

\begin{english}
  \begin{clojure*}{fontsize=\small}
[{:author/id 1
  :db/index 3
  :author/name "Ivan Petrov"
  :author/posts
  [{:post/id 10
    :db/index 1
    :post/title "Introduction to Python"
    :post/comments
    [{:comment/id 100
      :db/index 0
      :comment/text "Thanks for sharing this!"}
     {:comment/id 200
      :db/index 1
      :comment/text "Nice reading, it was useful."}]}
   {:post/id 20
    :db/index 3
    :post/title "Thoughts on LISP"}]}
 {:author/id 2
  :db/index 4
  :author/name "Ivan Rublev"
  :author/posts
  [{:post/id 30
    :db/index 2
    :post/title "Learning Clojure"
    :post/comments
    [{:comment/id 300
      :db/index 2
      :comment/text "TL;DR: you must learn lisp"}]}
   {:post/id 40
    :db/index 4
    :post/title "Working on my pet project"}]}]
  \end{clojure*}
\end{english}

Эти данные устроят клиента, поскольку не нуждаются в обработке в браузере. Разве что поле \code{:db/index} можно удалить: это технический артефакт, в котором больше нет смысла. Доработайте \code{remap-entities} так, чтобы после \code{(sort-by :db/index)} шла форма с удалением \code{:db/index}. Искушенные читатели могут объединить сортировку и удаление в трансдьюсер.

\subsection{Итог}

Подход fetch related означает, что сущности извлекают по слоям. Сперва находят основные, затем те, что ссылаются на них и так далее. Подобные запросы содержат оператор \code{IN} и набор первичных ключей. Чтобы не передать их огромное количество, дочерние записи накапливают в цикле с шагом в сто элементов. В зависимости от проекта у порога могут быть другие значения.

Способ, когда из базы выбирают все за раз, называется select related. Одноименный метод в ORM добавляет в запрос оператор \code{(LEFT) JOIN} с дочерними таблицами, которые ссылаются на основную. Позже, когда вы обращаетесь к полям-ссылкам, система находит их из выборки без обращения к базе.

Каждый подход несет преимущества и недостатки. Select related снижает число обращений к базе, но требует кода, который приводит плоскую выборку к дереву. Как правило, содержание базы стоит дороже, поэтому, если можно снизить на нее нагрузку за счет кода в приложении, так и поступают.

С другой стороны, желание выбрать все за раз может обернуться медленным запросом, особенно если в нем участвуют много таблиц. В нагруженных проектах это иногда невозможно, поскольку таблицы разносят по разным базам. В этом случае подход fetch related остается единственным вариантом.

Очевидно, нельзя сказать, какой способ выборки предпочтительней. Важно понимать достоинства и недостатки каждого и верно применять в текущих условиях.

\section{Группировка в базе}

Рассмотрим третий способ группировать данные~--- делать это запросом в базе. С помощью функций \code{json(b)\_agg} и \code{json(b)\_object\_agg} можно превратить часть полей во вложенный массив с типом \code{json(b)}. Если расширить протоколы JDBC типом JSON, как мы делали выше, вызов \code{jdbc/query} вернет вложенные коллекции Clojure.

Агрегация JSON не входит в стандарт SQL и поэтому доступна не во всех базах. Однако спрос на эту возможность привел к тому, что в том или ином виде она работает не только в PostgreSQL, но и в MySQL или Sqlite. Далее по тексту речь идет именно о PostgreSQL; для других баз синтаксис будет другим.

У агрегации в базе свои преимущества и недостатки. Запрос можно составить так, что данным не требуется обработка~--- они сразу готовы к отправке. За счет этого уходит код, что мы писали для обхода и группировки. С другой стороны, агрегация занимает ресурсы базы, что порой не подходит нагруженным проектам. Усложняется синтаксис SQL: когда вложенность больше двух уровней, запрос трудно читать и поддерживать.

Функция \code{jsonb\_agg} принимает колонку и возвращает массив \code{jsonb} со значениями этих колонок. Другая функция \code{row\_to\_json} принимает любую запись и возвращает JSON, где ключи~--- имена полей записи. Эти функции группируют целые таблицы и подзапросы, а не только колонки.

Вернемся к примеру с авторами, статьями и комментариями. Для начала выберем статьи с комментариями:


\begin{english}
  \begin{sql/lines}
SELECT
  p.id        as "post/id",
  p.title     as "post/title",
  p.author_id as "post/author-id",
  json_agg(row_to_json(c)) FILTER
          (WHERE c IS NOT NULL) as "post/comments"
FROM posts p
LEFT JOIN comments c ON c.post_id = p.id
GROUP BY p.id;
  \end{sql/lines}
\end{english}

Результат:

\begin{english}
  \begin{text*}{fontsize=\small}
 post/id |         post/title          | post/author-id | ..
---------+-----------------------------+----------------+---
      10 | Introduction to Python      |              1 | ..
      20 | Thoughts on LISP            |              1 | ..
      30 | Learning Clojure            |              2 | ..
      40 | Working on my pet project   |              2 | ..
  \end{text*}
\end{english}

%% TODO: at the bottom of the page?

\begin{english}
  \begin{text*}{fontsize=\small}
.. |                    post/comments                   |
-- +----------------------------------------------------+
.. | [{"id":100, ...}, {"id":200, ...}]                 |
.. |                                                    |
.. | [{"id":300, ...}]                                  |
.. |                                                    |
  \end{text*}
\end{english}

%% \begin{english}
%%   \begin{text}
%%  post/id |         post/title          | post/author-id |                                                       post/comments
%% ---------+-----------------------------+----------------+----------------------------------------------------------------------------------------------------------------------------
%%       10 | Introduction to Python      |              1 | [{"id":100,"text":"Thanks for sharing this!","post_id":10}, {"id":200,"text":"Nice reading, it was useful.","post_id":10}]
%%       20 | Thoughts on LISP            |              1 |
%%       30 | Learning Clojure            |              2 | [{"id":300,"text":"TL;DR: you must learn lisp","post_id":30}]
%%       40 | Working on my pet project   |              2 |
%%   \end{text}
%% \end{english}


%% \begin{table}[H]
%% %% \resizebox{\columnwidth}{!}{
%% \begin{tabular}{|l|l|l|l}
%% \hline
%%  post/id & post/title                  & post/author-id & \ldots \\
%% \hline
%%       10 & Introduction to Python      &              1 & \ldots \\
%%       20 & Thoughts on LISP            &              1 & \ldots \\
%%       30 & Learning Clojure            &              2 & \ldots \\
%%       40 & Working on my pet project   &              2 & \ldots \\
%% \hline
%% \end{tabular}%}
%% \end{table}

%% \begin{table}[H]
%% %% \resizebox{\columnwidth}{!}{
%% \begin{tabular}{l|l|}
%% \hline
%% \ldots & post/comments \\
%% \hline
%% \ldots & \mintinline{json}{[{"id": 100, ...}, {"id": 200, ...}]} \\
%% \ldots & \\
%% \ldots & \mintinline{json}{[{"id":300, ...}]} \\
%% \ldots & \\
%% \hline
%% \end{tabular}%}
%% \end{table}

Статья, у которой нет комментариев, осталась в выборке. Поле \code{post/comments} носит тип \code{json}; в нем массив объектов, где каждый объект представляет запись таблицы \code{comments}.

Выражение \code{FILTER} после \code{json\_agg} отсекает пустые элементы \coderef{5}. Если этого не сделать, получим массив с одним элементом \code{NULL}, что семантически неверно.

Теперь выберем авторов и присоединим к ним запрос выше со статьями и комментариями. Поместим его в подзапрос и сгруппируем еще раз по авторам. При наборе подобного SQL важны отступы, чтобы не запутаться с логическим уровнем.

\begin{english}
  \begin{sql}
SELECT
  a.id                         as "author/id",
  a.name                       as "author/name",
  json_agg(row_to_json(posts)) as "author/posts"
FROM
  authors a,
  (SELECT
    p.id        as "post/id",
    p.title     as "post/title",
    p.author_id as "post/author-id",
    json_agg(row_to_json(c)) FILTER
            (WHERE c IS NOT NULL) as "post/comments"
  FROM posts p
  LEFT JOIN comments c ON c.post_id = p.id
  GROUP BY p.id
) AS posts
WHERE a.id = posts."post/author-id"
GROUP BY a.id;
  \end{sql}
\end{english}

Если выполнить запрос, получим данные как на следующей странице. Они готовы к отправке клиенту: не требуется ни сортировка, ни дополнительный обход.

\begin{english}
  \begin{clojure*}{fontsize=\small}
[{:author/id 1
  :author/name "Ivan Petrov"
  :author/posts
    [{:post/id 10
      :post/title "Introduction to Python"
      :post/author-id 1
      :post/comments
        [{:id 100
          :text "Thanks for sharing this!"
          :post_id 10}
         {:id 200
          :text "Nice reading, it was useful."
          :post_id 10}]}
     {:post/id 20
      :post/title "Thoughts on LISP"
      :post/author-id 1
      :post/comments nil}]}
 {:author/id 2
  :author/name "Ivan Rublev"
  :author/posts
    [{:post/id 30
      :post/title "Learning Clojure"
      :post/author-id 2
      :post/comments
        [{:id 300
          :text "TL;DR: you must learn lisp"
          :post_id 30}]}
     {:post/id 40
      :post/title "Working on my pet project"
      :post/author-id 2
      :post/comments nil}]}]
  \end{clojure*}
\end{english}

Библиотеки HugSQL и HoneySQL помогают строить такие запросы по частям. В обоих случаях внутреннюю часть (статьи и комментарии) выносят в отдельную сущность и ссылаются на нее. В HugSQL мы бы вынесли подзапрос в сниппет, а в HoneySQL поместили бы его в переменную. С таким подходом главный запрос выглядит чище и удобней для чтения.

Рассмотрим другой пример группировки. Предположим, таблица хранит данные о товарах: артикул, название и так далее. У товара могут быть десятки характеристик: жанр книги, размер талии или разъем питания. Чтобы не добавлять бесконечно столбцы к товарам, вынесем характеристики в отдельную таблицу с именем характеристики, значением и ссылкой на товар.

Подготовим таблицы товаров:

\begin{english}
  \begin{sql}
CREATE TABLE goods (
  id SERIAL PRIMARY KEY,
  title TEXT NOT NULL
);
  \end{sql}
\end{english}

\noindent
и атрибутов:

\begin{english}
  \begin{sql}
CREATE TABLE good_attrs (
  id SERIAL PRIMARY KEY,
  good_id INTEGER NOT NULL REFERENCES goods(id),
  attr TEXT NOT NULL,
  val JSONB
);
  \end{sql}
\end{english}

Добавим несколько товаров с характеристиками:

\begin{english}
  \begin{sql}
INSERT INTO goods (id, title)
VALUES
  (1, 'iPhone 99x'),
  (2, 'Galaxy 33.plus'),
  (3, 'G. Orwell 1984');

INSERT INTO good_attrs (good_id, attr, val)
VALUES
  (1, 'phone.display.diag', '145'),
  (1, 'phone.wifi.support', 'true'),
  (3, 'book.pages', '215'),
  (3, 'book.genre', '"dystopia"');
  \end{sql}
\end{english}

Обратите внимание, что значение характеристики носит тип \code{jsonb}. Это значит, нам доступно все богатство его типов, например:

\begin{itemize}

\item
  размер одежды в виде строки (буквы <<L>>, <<M>>);

\item
  число портов натуральным числом (2, 3);

\item
  поддержка Wi-Fi (истина или ложь);

\item
  ссылки на сторонние ресурсы (массив строк).

\end{itemize}

Хотелось бы извлечь товары одним запросом, чтобы получить структуру как в примере ниже:

\begin{english}
  \begin{clojure}
[{:id 1
  :title "iPhone 99x"
  :attrs {:phone.display.diag 145
          :phone.wifi.support true}}

 {:id 2
  :title "Galaxy 33.plus"
  :attrs nil}

 {:id 3
  :title "G. Orwell 1984"
  :attrs {:book.genre "dystopia"
          :book.pages 215}}]
  \end{clojure}
\end{english}

Однако при выборке в лоб через JOIN получим задвоение товаров, что требует обработки результата.

Функция \code{json\_object\_agg} принимает списки ключей и значений и строит объект JSON. Напишем вложенный запрос, который группирует колонки \code{attr} и \code{val} таблицы \code{good\_attrs}:

\begin{english}
  \begin{clojure}
SELECT
  ga.good_id,
  jsonb_object_agg(ga.attr, ga.val) as attrs
FROM good_attrs ga
  GROUP BY ga.good_id;
  \end{clojure}
\end{english}

Результат:

%% \begin{table}[H]
%% %% \resizebox{\columnwidth}{!}{
%% \begin{tabular}{|l|l|}
%% \hline
%% \code{good\_id} & \code{attrs} \\
%% \hline
%% 3 & \code{\{"book.genre": "dystopia"{},} \\
%%   & \code{\phantom{ }"book.pages": 215\}} \\
%% 1 & \code{\{"phone.display.diag": 145{},} \\
%%   & \code{\phantom{ }"phone.wifi.support": true\}} \\
%% \hline
%% \end{tabular}%}
%% \end{table}

\begin{english}
  \begin{text*}{fontsize=\small}
id |                          attrs
---+---------------------------------------------------------
 3 | {"book.genre": "dystopia", "book.pages": 215}
 1 | {"phone.display.diag": 145, "phone.wifi.support": true}
  \end{text*}
\end{english}

Поместим его в подзапрос и присоединим к товарам при помощи \code{LEFT JOIN}:

\begin{english}
  \begin{sql}
SELECT
  g.id,
  g.title,
  a.attrs
FROM
  goods g
LEFT JOIN (
  SELECT
    ga.good_id,
    jsonb_object_agg(ga.attr, ga.val) as attrs
  FROM good_attrs ga
    GROUP BY ga.good_id
) a ON a.good_id = g.id;
  \end{sql}
\end{english}

Результат:

%% \begin{table}[H]
%% \begin{tabular}{|l|l|l|}
%% \hline
%% \code{id} & \code{title} & \code{attrs} \\
%% \hline
%% 1 & iPhone 99x     & \code{\{"phone.display.diag": 145{},} \\
%%   &                & \code{\phantom{ }"phone.wifi.support": true\}} \\
%% 2 & Galaxy 33.plus & \\
%% 3 & G. Orwell 1984 & \code{\{"book.genre": "dystopia"{},} \\
%%   &                & \code{\phantom{ }"book.pages": 215\}} \\
%% \hline
%% \end{tabular}
%% \end{table}

\begin{english}
  \begin{text}
 id |     title      |             attrs
----+----------------+------------------------------
  1 | iPhone 99x     | {"phone.display.diag": 145,
    |                |  "phone.wifi.support": true}
  2 | Galaxy 33.plus |
  3 | G. Orwell 1984 | {"book.genre": "dystopia",
    |                |  "book.pages": 215}
  \end{text}
\end{english}

Товар, у которого нет характеристик, остался в выборке. Если передать итоговый запрос в \code{jdbc/query}, получим именно ту структуру, на которую рассчитывали.

В этом преимущество \code{json(b)}: PostgreSQL предлагает множество функций для этого типа, в том числе группировку. Любое поле \code{json(b)} будет прочитано в Clojure за счет протокола. Это может быть массив, словарь и любая их комбинация.

Еще один прием, связанный с группировкий~--- использовать \code{row\_to\_json} в сочетании с оператором \code{UNION}. Он объединяет несколько запросов по вертикали, при этом обязательно, чтобы состав полей (их число и типы) был одинаков во всех запросах. Пример с числом и строкой:

\begin{english}
  \begin{sql}
select 1 as id, 'foo' as name
UNION
select 2 as id, 'bar' as name;
  \end{sql}
\end{english}

%% \begin{table}[H]
%% \begin{tabular}{|l|l|}
%% \hline
%% id & name \\
%% \hline
%% 1 & foo \\
%% 2 & bar \\
%% \hline
%% \end{tabular}
%% \end{table}

\begin{english}
  \begin{text}
 id | name
----+------
  1 | foo
  2 | bar
  \end{text}
\end{english}

Иногда в проекте бывает несколько похожих сущностей в разных таблицах. Например, договоры с юрлицами и населением; администраторы и пользователи; крупные и малые поставщики. Из-за разной структуры их нельзя объединить в один запрос. Но поскольку функция \code{row\_to\_json} приводит запись к json, можно объединить результаты любых записей.

Покажем это на примере. Предположим, администраторы системы хранятся отдельно от пользователей, но в какой-то момент нужно увидеть и тех, и других. Создадим таблицу администраторов:

\begin{english}
  \begin{sql}
CREATE TABLE admins (
  id SERIAL,
  full_name TEXT NOT NULL,
  email TEXT
);
  \end{sql}
\end{english}

\noindent
и несколько записей:

\begin{english}
  \begin{sql}
INSERT INTO admins (full_name, email)
VALUES ('Petr Smirnov', 'petr@test.com'),
       ('Oleg Ivanov', 'oleg@test.com');
  \end{sql}
\end{english}

Ниже~--- запрос, который выберет обе сущности. Обратите внимание на поля \code{id} и \code{type} в обеих частях. Первичный ключ (\code{id}) нужен настолько часто, что логично вынести его на верхний уровень запроса. Поле \code{type} содержит строку с типом сущности: <<user>> для пользователя и <<admin>> для администратора. По этому полю легко понять, что находится в \code{entity}.

\begin{english}
  \begin{sql}
SELECT
  u.id AS id,
  'user' AS type,
  row_to_json(u) AS entity
FROM
  users u
UNION ALL
SELECT
  a.id AS id,
  'admin' AS type,
  row_to_json(a) AS entity
FROM
  admins a;
  \end{sql}
\end{english}

Результат в консоли \code{psql}:

%% \begin{table}[H]
%% %% \resizebox{\columnwidth}{!}{
%% \begin{tabular}{|l|l|l|}
%% \hline
%% id & type & entity \\
%% \hline
%%   1 & user  & \mintinline{json}{{"id":1,"fname":"Ivan", ...}} \\
%%   3 & user  & \mintinline{json}{{"id":3,"fname":"Huan", ...}} \\
%%   1 & admin & \mintinline{json}{{"id":1,"full_name":"Petr Smirnov", ...}} \\
%%   2 & admin & \mintinline{json}{{"id":2,"full_name":"Oleg Ivanov", ...}} \\
%% \hline
%% \end{tabular}%}
%% \end{table}


\begin{english}
  \begin{text}
id | type  |                 entity
---+-------+-----------------------------------------
 1 | user  | {"id":1,"fname":"Ivan", ...}
 3 | user  | {"id":3,"fname":"Huan", ...}
 1 | admin | {"id":1,"full_name":"Petr Smirnov", ...}
 2 | admin | {"id":2,"full_name":"Oleg Ivanov", ...}
  \end{text}
\end{english}

\noindent
и в Clojure:

\begin{english}
  \begin{clojure}
[{:id 1
  :type "user"
  :entity {:id 1
           :fname "Ivan"
           :lname "Petrov"
           ...}}
 {:id 3
  :type "user"
  :entity {:id 3
           :fname "Huan"
           :lname nil
           ...}}
 {:id 1
  :type "admin"
  :entity {:id 1
           :full_name "Petr Smirnov"
           :email "petr@test.com"}}
 {:id 2
  :type "admin"
  :entity {:id 2
           :full_name "Oleg Ivanov"
           :email "oleg@test.com"}}]
  \end{clojure}
\end{english}

При обходе выборки проверим поле \code{type} оператором \code{case} и вызовем нужный обработчик:

\begin{english}
  \begin{clojure}
(doseq [{:keys [id type entity]} result]
  (case type
    "user" (process-user ...)
    "admin" (process-admin ...)))
  \end{clojure}
\end{english}

Еще одно замечание касается оператора \code{UNION}. Обратите внимание, что мы использовали его \code{-ALL} версию. Если опустить частицу \code{ALL} после \code{UNION}, база попытается убрать дубликаты записей. Чтобы проверить запись на повтор, ее сравнивают с уже накопленными записями. А поскольку тип json не поддерживает сравнение, получим ошибку:

\begin{english}
  \begin{sql}
SELECT
  u.id AS id,
  'user' AS type,
  row_to_json(u) AS entity
FROM
  users u
UNION
SELECT
  a.id AS id,
  'admin' AS type,
  row_to_json(a) AS entity
FROM
  admins a;

-- ERROR: could not identify an equality operator
-- for type json. LINE 4: row_to_json(u) AS entity
  \end{sql}
\end{english}

Чтобы отсечь дубликаты, используйте \code{to\_jsonb} вместо прежней \code{row\_to\_json}. Эта функция вернет результат с типом \code{jsonb}, который поддерживает сравнение. Как следствие, оператор \code{UNION ALL} не вызовет ошибку для поля этого типа.

Группировка в базе может быть удачным решением, которое сэкономит время и код. Однако она зависит от объема данных и их структуры. Опробуйте выборку на больших данных (сотни тысяч записей) и оцените время и план исполнения. Если данных нет, сгенерируйте их спекой. В первой книге о Clojure мы рассмотрели, как это сделать модулем \code{gen}.

\section{Миграции}

С развитием проекта в базе появляются новые таблицы, индексы, триггеры. Чтобы контролировать изменения в базе, придумана концепция миграций. В этом разделе мы рассмотрим ее общие принципы и как они работают в Clojure.

Технически миграция выглядят как .sql-файл. В нем находится код, который создает таблицы и другие сущности базы. Различают up- и down-миграции, они же прямые и обратные. Как правило, прямые описывают новые сущности, например создают таблицу и индексы для нее. Down-миграция совершает обратное: удаляет индекс и таблицу. В редких случаях отмена не требуется, и тогда миграция состоит только из up-части.

Каждая миграция имеет уникальный идентификатор. Чаще всего это дата в формате ISO или время Unix. Идентификатор должен поддаваться сортировке, чтобы однозначно определить порядок миграций.

Миграции похожи на дерево коммитов: с ними базу можно <<накатить>> или <<откатить>> до определенной версии. Подобно тому, как с помощью git мы переключаемся на нужную версию кода, базу данных переключают на нужное состояние. Для этого нужно знать, какая миграция текущая и в какую сторону двигаться.

Сведения о миграциях хранится в базе. Как правило, движок миграций создает таблицу \code{migrations} примерно такой структуры:

\begin{english}
  \begin{sql}
create table migrations (
  migration_id text primary key,
  created_at timestamp,
  description text
);
  \end{sql}
\end{english}

Таблица запоминает, какие миграции и когда мы применили. При запуске миграций программа читает таблицу и сканирует файлы на диске. Файлы называют по принципу \code{<time/id>-<description>.<up/down>.sql}. Объясним значения в угловых скобках:

\begin{itemize}

\item
  \code{<time/id>}~--- время или идентификатор, по которому сортируются миграции;

\item
  \code{<description>}~--- короткое описание миграции;

\item
  \code{<up/down>}~--- признак прямой или обратной миграции.

\end{itemize}

Примеры файлов:

\begin{english}
  \begin{text}
20210830075251-create-users-table.up.sql
20210830075251-create-users-table.down.sql

20210831064602-create-profiles-table.up.sql
20210831064602-create-profiles-table.down.sql
  \end{text}
\end{english}

Движок группирует файлы примерно в такую структуру:

\begin{english}
  \begin{clojure}
(def migrations
  [{:id 20210830075251
    :description "Create users table"
    :up "...-create-users-table.up.sql"
    :down "...-create-users-table.down.sql"}
   {:id 20210831064602
    :description "Create profiles table"
    :up "...-create-profiles-table.up.sql"
    :down "...-create-profiles-table.down.sql"}])
  \end{clojure}
\end{english}

В зависимости от того, какая версия базы сейчас и что мы хотим сделать, сработают разные алгоритмы. Наиболее частый сценарий~--- migrate forward, то есть применить миграции, что еще не были обработаны. Технически это значит отфильтровать список миграций по id и выбрать файлы с частичкой \code{up}:

\begin{english}
  \begin{clojure}
(->> migrations
     (filter (fn [{:keys [id]}]
               (> id current-id)))
     (sort-by :id)
     (map :up))

;; ("20210831064602-create-profiles-table.up.sql" ...)
  \end{clojure}
\end{english}

Каждуя миграция выполняется в транзакции. Если изменения прошли без ошибок, в таблицу \code{migrations} попадает номер миграции, которую только что выполнили. Даже если миграция <<упала>> где-то на полпути, не останется ее промежуточных следов.

При движении в обратную сторону стратегия меняется. Если нужно вернуться к прошлой версии базы, указывают нужный идентификатор, и программа применяет down-файлы, чей идентификатор находится между указанным и текущим. При этом порядок миграций обратный: от новых к старым.

\begin{english}
  \begin{clojure}
(defn match-migration
  [{:keys [id]}]
  (and (>= id target_id)
       (< id current-id)))

(->> migrations
     (filter match-migration)
     (sort-by :id)
     (reverse)
     (map :down))
  \end{clojure}
\end{english}

У миграций несколько преимуществ. Прежде всего, это автоматизация. Не нужно подключаться к базе и добавлять колонку вручную. Достаточно вызвать прогон миграций на удаленной машине.

При разработке приходится работать с разными версиями кода и, соответственно, базы. Переключать базу должно быть так же удобно, как и ветку в git.

Случается, что изменения в таблицах были неудачны, и это выяснилось после запуска в бою. В этом случае изменения открывают обратной миграцией. Конечно, лучше всего избежать этой ситуации, но иметь средство тоже не помешает.

Наконец, когда схема базы описана в файле, это означает контроль за ней. Проект легче запустить локально, а новичкам проще понять систему таблиц.

Clojure предлагает несколько библиотек для миграций. Мы рассмотрим две из них: Migratus и Ragtime.

\subsection{Migratus}

\def\urlmigratus{https://github.com/yogthos/migratus}

Проект \footurl{Migratus}{\urlmigratus}[Migratus] состоит из двух частей: библиотеки и плагина к lein. Проще всего начать работу при помощи плагина. Добавьте его в проект:

\begin{english}
  \begin{clojure}
:plugins [... [migratus-lein "0.7.3"]]
  \end{clojure}
\end{english}

Напишем несколько миграций. В папке \code{resources/migrations} создайте пока что пустые файлы:

\begin{english}
  \begin{bash}
> mkdir -p resources/migrations
> cd resources/migrations

touch 20210830075251-create-users-table.up.sql
touch 20210830075251-create-users-table.down.sql
  \end{bash}
\end{english}

Теперь наполним их. Содержимое up-миграции:

\begin{english}
  \begin{sql}
CREATE TYPE user_status AS ENUM
       ('active', 'pending', 'blocked');

--;;

CREATE TABLE users(
  id serial primary key,
  name text not null,
  status user_status not null,
  email text
);

--;;

CREATE INDEX idx_users_name ON users(name);
  \end{sql}
\end{english}

Это прямая (up) половина первой миграции. Она создает тип-перечисление, таблицу \code{users} и индекс на имя пользователя. Чтобы откатить эти шаги, поместите в down-файл следующий код:

\begin{english}
  \begin{sql}
DROP INDEX idx_users_name;

--;;

DROP TABLE users;

--;;

DROP TYPE user_status;
  \end{sql}
\end{english}

Обратите внимание, что порядок удаления сущностей обратный. Нельзя удалить индекс и тип-перечисление, пока существует таблица.

Когда миграции готовы, применим их к базе. Для этого укажем параметры подключения. В файле \code{project.clj} добавьте ключ \code{:migratus} со словарем:

\begin{english}
  \begin{clojure}
{:store :database
 :migration-dir "migrations"
 :db {:dbtype "postgresql"
      :dbname "migration_test"
      :host "127.0.0.1"
      :user "book"
      :password "book"}}
  \end{clojure}
\end{english}

Ключ \code{:migration-dir} указывает папку относительно ресурсов, в которой хранятся миграции. В нашем случае это \code{re\-so\-ur\-ces/mig\-ra\-ti\-ons}. В поле \code{:db} находится знакомая вам JDBC-спека. Выполните в терминале:

\begin{english}
  \begin{bash}
> lein migratus migrate
  \end{bash}
\end{english}

Вы увидите список миграций, которые плагин применил к базе данных. Подключитесь к ней с помощью \code{psql} или другой утилиты~--- появится таблица \code{users}. Кроме того, исследуйте таблицу миграций под названием \code{schema\_migrations}:

\begin{english}
  \begin{clojure}
SELECT * FROM schema_migrations;
  \end{clojure}
\end{english}

В ней окажется запись с датой и именем миграции:

%% \begin{table}[H]
%% %% \resizebox{\columnwidth}{!}{
%% \begin{tabular}{|l|l|l|}
%% \hline
%% id     &         applied         &      description \\
%% \hline
%% 20210830075251 & 2021-08-28 09:28:26.911 & create-users-table \\
%% \hline
%% \end{tabular}%}
%% \end{table}

\begin{english}
  \begin{text*}{fontsize=\small}
         id     |       applied       |      description
----------------+---------------------+-----------------------
 20210830075251 | 2021-08-28 09:28:26 | create-users-table
  \end{text*}
\end{english}

Повторный запуск миграций ничего не даст, потому что миграция \code{20210830075251} уже обработана, а новых не появилось. Чтобы откатить изменения, выполните команду \code{rollback}:

\begin{english}
  \begin{clojure}
> lein migratus rollback
  \end{clojure}
\end{english}

Это действие означает откатить последнюю транзакцию. После нее не останется таблицы \code{users} и связанных с ней сущностей. Из таблицы \code{schema\_migrations} исчезнут сведения о миграции \code{20210830075251}, и ее можно будет применить снова. Применение и откат миграций можно повторять сколько угодно раз при условии, что откат удаляет все изменения прямой части.

\subsection{Несколько запросов в миграции}

Обратите внимание на строку \code{--;;} между запросами в файлах. С точки зрения SQL это обычный комментарий, однако здесь у него особая роль.

По умолчанию Migratus рассматривает файл как единый запрос и выполняет его с помощью \code{jdbc/execute!}. Но не всегда миграцию можно описать одним запросом. В примере выше понадобилось три выражения, чтобы создать перечисление, таблицу и индекс.

Для таких случаев строка \code{--;;} служит разделителем запросов. Migratus разбивает файл и выполняет запросы по одному в транзакции. За счет этого не нужно создавать несколько файлов на каждый запрос.

О разделителе часто забывают новички. Это тот случай, который придется запомнить.

\subsection{Миграции с профилями}

При запуске миграций в \code{lein} доступны все опции этого инструмента, в том числе профили. С их помощью легко нацелить Migratus на другую базу или папку с файлами. Например, по умолчанию команда \code{lein migratus migrate} работает с локальной базой, но с профилем \code{staging} подключается к удаленной тестовой машине:

\begin{english}
  \begin{bash}
> lein with-profile staging migratus migrate
  \end{bash}
\end{english}

Для этого задайте иные настройки \code{:migratus} в профиле \code{:staging}. Обратите внимание, что необязательно копировать их все. Профили \code{lein} подлежат глубокому слиянию, поэтому достаточно только отличия от корневых настроек \code{:migratus}.

\begin{english}
  \begin{clojure}
{:profiles
 {:staging
  {:migratus
   {:db {:dbname "prod_db"
         :host ~(System/getenv "DB_HOST")
         :user ~(System/getenv "DB_USER")
         :password ~(System/getenv "DB_PASSWORD")}}}}}
  \end{clojure}
\end{english}

Когда приложение развертывают на тестовой машине, в базе должны быть минимальные данные для проверки. Обычно это пользователь с известным паролем, несколько товаров, покупок и так далее. Поместим их в миграцию, которая выполняется только на удаленной машине. Создайте каталог \code{env/staging/resources/\-migrations} и файл в нем:

\begin{english}
  \begin{sql}
-- 20210830075415-add-test-data.up.sql

INSERT INTO users(id, name, status, email, ...)
VALUES
 (1, 'Test1', 'active',  'test1@test.com', ...),
 (2, 'Test2', 'pending', 'test2@test.com', ...),
 (3, 'Test3', 'blocked', 'test3@test.com', ...);
  \end{sql}
\end{english}

Укажите профилю \code{:staging} дополнительный путь ресурсов. Он заменит текущий \code{resources}, и папка \code{migrations} будет взята из нового пути.

\begin{english}
  \begin{clojure}
{:resource-paths ["env/staging/resources"]}
  \end{clojure}
\end{english}

Важно понимать, что Migratus ищет файлы только в одной папке: невозможно сделать так, чтобы использовались одновременно \code{resources/migrations} и \code{env/staging/resources/migrations}. Поэтому миграции накатывают в два этапа: в первый раз основные, во второй~--- специфичные для текущего окружения, если это необходимо.

\begin{english}
  \begin{bash}
> lein migratus migrate
> lein with-profile staging migratus migrate
  \end{bash}
\end{english}

\subsection{Параметры подключения}

До сих пор мы указывали подключение к базе явно. Это подойдет для локальной разработки, но не промышленного запуска. Чтобы запустить миграции на удаленной базе, передайте ее параметры в переменных среды. Для этого изменим значения словаря \code{:db} на формы \code{~(System/getenv ...)}:

\begin{english}
  \begin{clojure}
{:store :database
 :migration-dir "migrations"
 :db {:dbtype "postgresql"
      :dbname ~(System/getenv "DB_NAME")
      :host ~(System/getenv "DB_HOST")
      :user ~(System/getenv "DB_USER")
      :password ~(System/getenv "DB_PASSWORD")}}
  \end{clojure}
\end{english}

Синтаксис \code{\textasciitilde{}<form>} внутри макроса \code{defproject} означет вычислить форму. При запуске \code{lein} на месте \code{~(System/getenv "ENV\_NAME")} окажется значение одноименной переменной. Чтобы запустить миграции, укажите переменные процессу \code{lein}:

\begin{english}
  \begin{bash}
> DB_USER=book DB_PASSWORD=secret lein migratus migrate
  \end{bash}
\end{english}

Мы подробно разобрали конфигурацию и переменные среды в пятой главе первой книги.

\subsection{Миграции в коде}

Иногда миграциями управляют не командой \code{lein}, напрямую из Clojure. Для этого Migratus должен быть подключен не виде плагина к \code{lein}, а библиотекой:

\begin{english}
  \begin{clojure}
{:dependencies [[migratus "1.3.5"]]}
  \end{clojure}
\end{english}

Приведем минимальный код, чтобы запустить миграции в коде:

\begin{english}
  \begin{clojure}
(ns ...
  (:require
   [migratus.core :as migratus]))

(def config
  {:store :database
   :migration-dir "migrations"
   :db {...}})

(migratus/init config)

(migratus/migrate config)
(migratus/rollback config)
  \end{clojure}
\end{english}

Процесс сводится к простым шагам: объявить конфигурацию, инициировать библиотеку и вызывать функции \code{migrate} или \code{rollback} с конфигурацией.

Запуск миграций помещают в начало работы программы. Если приложение запущено на нескольких машинах, выполнять миграции должен только один экземпляр. Проще всего задать этот признак переменной среды: всем ложь и только одной машине~--- истину.

Если проект основан на системе (библиотеки Component и Integrant), создайте компонент \code{Migration}, который зависит от базы данных. При запуске (метод \code{start} или \code{init-key}) он вызывает \code{migratus/migrate} с конфигурацией. В поле \code{:db} конфигурации указывают компонент базы.

\subsection{Программные миграции}

Как правило, изменения в базе данных описывают на языке SQL. Однако не все действия можно выполнить с его помощью. Предположим, нужно заполнить колонку данными из стороннего источника. В этом случае помогут программные миграции.

Технические подобные миграции~--- это файлы .edn со словарем. Ключи \code{:up} и \code{:down} указывают на функции Clojure. Функции принимают один параметр~--- конфигурацию~--- и выполняют действия с базой. Код функции остается на ваше усмотрение. С помощью библиотек вы можете читать данные из сети или файлов и записывать в базу. Обратная программная миграция удаляет то, что внесла ее прямая часть.

Пусть таблица \code{requests} собирает сведения о просмотрах страниц. У нас есть только IP-адрес пользователя, но хотелось бы знать страну, город и другие данные. Исходные поля таблицы:

\begin{english}
  \begin{sql}
SELECT * FROM requests;
  \end{sql}
\end{english}

\begin{english}
  \begin{text}
 id |       ip       | country_code
----+----------------+--------------
  1 | 24.198.249.0   |
  2 | 187.33.237.120 |
  \end{text}
\end{english}


Создайте файл \code{20210831070224-update-country-by-ip.edn} со словарем внутри:

\begin{english}
  \begin{clojure}
{:ns book.migrations.update-country
 :up-fn migrate-up
 :down-fn migrate-down}
  \end{clojure}
\end{english}

Поле \code{:ns} указывает на пространство, а \code{:up-fn} и \code{:down-fn}~--- на функции прямой и обратной миграций. Технически возможно держать несколько миграций в одном Clojure-модуле, но лучше резделить их.

В файл \code{book/migrations/update\_country.clj} поместим модуль миграции. Начнем с шапки:

\begin{english}
  \begin{clojure}
(ns book.migrations.update-country
  (:require
   [clojure.java.jdbc :as jdbc]
   [clj-http.client :as client]))
  \end{clojure}
\end{english}

\def\urliploc{https://iplocation.com}

Код страны получим с помощью сервиса \footurl{IP Location}{\urliploc}[IP Location] по HTTP API. Сервис принимает POST-запрос с адресом и выдает JSON с информацией о нем. Напишем функцию:

\begin{english}
  \begin{clojure}
(defn get-ip-info [ip]
  (:body
   (client/post "https://iplocation.com"
                {:form-params {:ip ip}
                 :as :json})))
  \end{clojure}
\end{english}

Прямая миграция выбирает записи с пустым кодом страны и обходит в цикле. Для каждого IP-адреса она выполняет HTTP-запрос и обновляет запись с найденным кодом.

\begin{english}
  \begin{clojure}
(defn migrate-up [{:keys [db]}]
  (let [query "SELECT id, ip FROM requests
               WHERE country_code IS NULL"
        rows (jdbc/query db query)]
    (doseq [{:keys [id ip]} rows]
      (let [{:keys [country_code]} (get-ip-info ip)]
        (jdbc/update! db :requests
                      {:country_code country_code}
                      ["id = ?" id])))))
  \end{clojure}
\end{english}

Обратная миграция сбрасывает коды стран в \code{NULL}:

\begin{english}
  \begin{clojure}
(defn migrate-down [{:keys [db]}]
  (jdbc/update! db :requests
                {:country_code nil}
                ["true"]))
  \end{clojure}
\end{english}

Запустите миграции в терминале. По окончании в таблице \code{requests} появятся коды стран:

\begin{english}
  \begin{clojure}
SELECT * FROM requests;
  \end{clojure}
\end{english}

\begin{english}
  \begin{text}
 id |       ip       | country_code
----+----------------+--------------
  1 | 24.198.249.0   | US
  2 | 187.33.237.120 | BR
  \end{text}
\end{english}

При откате коды пропадут из таблицы.

Код миграции можно улучшить: добавить логирование и перехват ошибок, вести запросы параллельно при помощи \code{pmap}. В запрос \code{SELECT} дописать оператор \code{FOR UPDATE}, чтобы заблокировать запись на время транзакции. Предлагаем читателю поработать над кодом в свободное время.

\subsection{Ragtime}

\def\urlragtime{https://github.com/weavejester/ragtime}

Коротко рассмотрим вторую библиотеку под названием \footurl{Ragtime}{\urlragtime}[Ragtime]. Ее принцип такой же, что мы рассмотрели выше. Это .sql-файлы в папке, их чтение и обход, таблица с именами обработанных миграций. В отличие от Migratus, Ragtime более гибок: если первый привязан к драйверу JDBC, то Ragtime основан на протоколах, которые легко адаптировать под любую базу, не обязательно реляционную.

Протоколы \code{DataStore} и \code{Migration} описывают хранилище данных и миграцию. Встроенный пакет \code{ragtime.jdbc} расширяет их для JDBC-совместимых баз, как это делает Migratus. За счет этого Ragtime можно применить к разным базам, например Cassandra, MongoDB или Datomic. Работая в Exoscale, автор написал библиотеку миграций для Cassandra на базе Ragtime. Присмотритесь к этой библиотеке, если в проекте участвуют не только JDBC-совместимые базы.

Мы не будем рассматривать Ragtime столь же подробно, как Migratus. К этому моменту читатель достаточно опытен, чтобы разобраться с библиотекой самостоятельно.

\section{Next.JDBC}

\def\urlnextjdbc{https://github.com/seancorfield/next-jdbc}

Библиотека \footurl{Next.JDBC}{\urlnextjdbc}[Next JDBC]~--- это следующий этап в адаптации JDBC для Clojure. Проект ставит следующие цели:

\begin{itemize}

\item
  ускорить обработку выборки. Автор считает неоптимальным текущее проеобразование \code{ResultSet} в коллекцию Clojure. На больших результатах алгоритм действительно замедляется.

\def\urldatafy{https://clojure.github.io/clojure/branch-master/clojure.datafy-api.html}

\item
  Обеспечить более тесную связь с Clojure за счет \footurl{протокола Datafy}{\urldatafy}[Datafy]. Протокол появился в Clojure 1.11 и служит посредником между сущностями Java и Clojure.

\item
  Предложить более понятный API. Прежняя библиотека различает функции \code{query}, \code{execute!}, \code{db-do-com\-mands} и другие; вдобавок она обязывает помнить об их особенностях. Next.JDBC планирует сократить разнообразие API.

\end{itemize}

Коротко опробуем библиотеку. Подключим ее к проекту:

\begin{english}
  \begin{clojure}
;; project.clj
[com.github.seancorfield/next.jdbc "1.2.709"]

;; module.clj
(ns ...
  (:require
   [next.jdbc :as jdbc]
   [next.jdbc.sql :as jdbc.sql]
   [next.jdbc.prepare :as jdbc.prepare]
   [next.jdbc.result-set :as jdbc.rs]))
  \end{clojure}
\end{english}

В отличии от предшественника, Next.JDBC не следует правилу <<все в одном файле>>. Смысловые части разнесены по отдельным модулям.

Роль источника данных играет объект \code{datasource}, который получают из JDBC-спеки. Однажды получив, его передают в функции первым аргументом.

\begin{english}
  \begin{clojure}
(def db-spec {:dbtype "postgresql" :dbname "test" ...})

(def ds (jdbc/get-datasource db-spec))
  \end{clojure}
\end{english}

Объект \code{datasource} хранит открытое соединение и не порождает новое на каждый запрос. Подобную ошибку легко совершить в \code{clojure.java.jdbc}, когда JDBC-спека не содержит поля \code{:datasource} или \code{:connection}, и обращение к базе замедляется на порядок. Содержимое \code{datasource} легко проверить функцией \code{bean}:

\begin{english}
  \begin{clojure}
(bean ds)

{:class next.jdbc.connection$url_PLUS_etc$...
 :connection #object[...PgConnection 0x352c5229...]
 :loginTimeout 0}
  \end{clojure}
\end{english}

Прочитаем таблицу пользователей:

\begin{english}
  \begin{clojure}
(first (jdbc/execute! ds ["SELECT * FROM users"]))

#:users{:id 1
        :fname "Ivan"
        :lname "Petrov"
        :email "test@test.com"
        :age 30
        :created_at #inst "2021-08-10T07:36:03"}
  \end{clojure}
\end{english}

Обратите внимание, что ключи словарей квалифицированы, то есть содержат пространство с именем таблицы. За счет пространств легко понять, какой таблице принадлежит поле. Пространства работают в том числе для связанных таблиц. Убедимся в этом на примере соединения с профилями:

\begin{english}
  \begin{clojure}
(first
  (jdbc/execute! ds
    ["SELECT *
      FROM users u, profiles p
      WHERE p.user_id = u.id"]))

{:users/id 1
 :users/lname "Petrov"
 :users/fname "Ivan"
 :users/created_at #inst "2021-08-10T07:36:03"
 :profiles/id 1
 :profiles/user_id 1
 :profiles/avatar "kitten.jpg"}
  \end{clojure}
\end{english}

Видим, что поля из разных таблиц обрели разные пространства. Это освобождает нас от расстановки псевдонимов вручную:

\begin{english}
  \begin{sql}
SELECT
  u.id     AS "user/id",
  u.fname  AS "user/fname",
  ...
  p.id     AS "profile/id",
  ...
  \end{sql}
\end{english}

Важно понимать, что поиск таблицы для поля не бесплатен, а требует отдельного запроса в базу. Пример выше с пользователем и профилем порождает следующий запрос:

\begin{english}
  \begin{sql*}{fontsize=\small}
SELECT c.oid, a.attnum, a.attname, c.relname, n.nspname,
a.attnotnull OR (t.typtype = 'd' AND t.typnotnull),
pg_catalog.pg_get_expr(d.adbin, d.adrelid) LIKE '%nextval(%' FROM
pg_catalog.pg_class c JOIN pg_catalog.pg_namespace n
ON (c.relnamespace = n.oid) JOIN pg_catalog.pg_attribute a
ON (c.oid = a.attrelid) JOIN pg_catalog.pg_type t ON (a.atttypid
= t.oid) LEFT JOIN pg_catalog.pg_attrdef d ON (d.adrelid =
a.attrelid AND d.adnum = a.attnum) JOIN (SELECT 32824 AS oid , 1
AS attnum UNION ALL SELECT 32824, 2 UNION ALL SELECT 32824, 3
UNION ALL SELECT 32824, 4 UNION ALL SELECT 32824, 5 UNION ALL
SELECT 32824, 6 UNION ALL SELECT 32824, 8 UNION ALL SELECT 32824,
9 UNION ALL SELECT 32835, 1 UNION ALL SELECT 32835, 2 UNION ALL
SELECT 32835, 3) vals ON (c.oid = vals.oid AND a.attnum =
vals.attnum)
  \end{sql*}
\end{english}

Который, в свою очередь, дает сведения о колонках и таблицах:

\begin{english}
  \begin{text}
  oid  | attnum |  attname   | relname  | nspname | ? | ?
-------+--------+------------+----------+---------+---+---
 32835 |      3 | avatar     | profiles | public  | f |
 32835 |      2 | user_id    | profiles | public  | t |
 32835 |      1 | id         | profiles | public  | t | t
 32824 |      9 | created_at | users    | public  | f |
 32824 |      8 | year_birth | users    | public  | f |
 32824 |      6 | city       | users    | public  | f |
 32824 |      5 | age        | users    | public  | f |
 32824 |      4 | email      | users    | public  | f |
 32824 |      3 | lname      | users    | public  | f |
 32824 |      2 | fname      | users    | public  | f |
 32824 |      1 | id         | users    | public  | t | t
  \end{text}
\end{english}

Если подход кажется вам расточительным, отключите квалификацию полей параметром \code{builder-fn}:

\begin{english}
  \begin{clojure}
(jdbc/execute!
 ds
 ["SELECT * FROM users ..."]
 {:builder-fn jdbc.rs/as-unqualified-maps})
  \end{clojure}
\end{english}

Кроме функции \code{as-unqualified-maps}, вам доступны \code{as-arra\-ys} для векторов и другие обработчики.

Вспомогательные функции \code{get-by-id}, \code{find-by-keys}, \code{update!}, \code{insert!} и аналоги перешли в модуль \code{next.jdbc.sql}. Они отличаются только тем, что принимают первым параметром \code{datasource}:

\begin{english}
  \begin{clojure}
(jdbc.sql/get-by-id ds :users 1)

(jdbc.sql/insert! ds :users {:id 199 :fname "Test"})

(jdbc.sql/query ds ["select * from users"])
  \end{clojure}
\end{english}

Макрос \code{with-transaction} тоже почти не изменился. Он принимает вектор, где первый элемент~--- символ, а второй~--- текущий \code{datasource}. С первым символом будет связан новый \code{datasource} с транзакционным соединением. В примере ниже мы открываем транзакцию с двумя запросами. Первый добавляет товар, второй записывает для него скидку 33%.

\begin{english}
  \begin{clojure}
(jdbc/with-transaction [tx ds]
  (let [{:items/keys [id]}
        (jdbc.sql/insert! tx :items {...})]
    (jdbc.sql/insert!
       tx
       :sales
       {:item_id id :ratio 0.66})))
  \end{clojure}
\end{english}

Как мы выяснили, поддержка JSON открывает новые горизонты в работе с базой. Next.JDBC предлагает протоколы для чтения и установки нестандартных типов. Подготовим функцию для перевода \code{PGobject} в Clojure:

\begin{english}
  \begin{clojure}
(defn pg->clj [^PGobject pg-obj]
  (let [pg-val (.getValue pg-obj)
        pg-type (.getType pg-obj)]
    (case pg-type
      ("json" "jsonb")
      (json/parse-string pg-val keyword)
      ;; else
      pg-obj)))
  \end{clojure}
\end{english}

\noindent
и расширим с ее помощью протокол:

\begin{english}
  \begin{clojure}
(extend-protocol jdbc.rs/ReadableColumn
  PGobject
  (read-column-by-label [v _]
    (pg->clj v))
  (read-column-by-index [v _ _]
    (pg->clj v)))
  \end{clojure}
\end{english}

Обратите внимание, что у протокола два метода: получить поле по индексу и имени. В нашем случае реализации совпадают. При чтении колонки с типом \code{json(b)} получим коллекцию Clojure:

\begin{english}
  \begin{clojure}
(first (jdbc.sql/query ds ["select * from items"]))

#:items{:id 1
        :title "Cap"
        :attrs {:size "XL"
                :color "red"
                :country "China"}}
  \end{clojure}
\end{english}

Расширим установку параметров. Любая коллекция Clojure станет объектом \code{PGobject} с типом json. Вспомогательная функция:

\begin{english}
  \begin{clojure}
(defn ->pg-object [data]
  (doto (new PGobject)
    (.setType "json")
    (.setValue (json/generate-string data))))
  \end{clojure}
\end{english}

\noindent
и протокол:

\begin{english}
  \begin{clojure}
(extend-protocol jdbc.prepare/SettableParameter
  clojure.lang.IPersistentCollection
  (set-parameter [v ^PreparedStatement pr-st idx]
    (.setObject pr-st idx (->pg-object v))))
  \end{clojure}
\end{english}

Вставка товара с JSON-атирибутами:

\begin{english}
  \begin{clojure}
(jdbc.sql/insert!
  ds
  :items
  {:title "t-shirt"
   :attrs {:size "XXL" :brand "Abibas"}})

#:items{:id 1
        :title "t-shirt"
        :attrs {:size "XXL" :brand "Abibas"}}
  \end{clojure}
\end{english}

\def\urljdbcnextmig{https://github.com/seancorfield/next-jdbc/tree/develop/doc}

Как видно, интерфейс Next.JDBC в целом похож на предшественника. Функции ведут себя так же, но дают больше контроля за происходящим. Если у вас долгий опыт работы с \code{clojure.java.jdbc}, перейти на Next.JDBC будет несложно. Тонкости перехода описаны в \footurl{документации}{\urljdbcnextmig}[Next JDBC docs] проекта. Там же вы узнаете о других возможностях JDBC.next.

\section{Заключение}

Реляционные базы данных основаны на модели реляционной алгебры. Модель описывает отношения между сущностями и операции над ними: проекция, пересечение, объединение и другие. В базах данных модель представлена таблицами и операторами SQL. Как правило, оператор принимает несколько таблиц и возвращает табличный результат.

SQL~--- строго декларативный язык: в нем нет циклов, переменных и прочих возможностей, доступных в языках программирования. Говорят, что SQL не полон по Тьюрингу. Существуют несколько стандартов SQL, датированных годами: 92, 99, 2008 и другие. Кроме обычных возможностей, современные базы предлагают расширенные операторы и типы данных.

В мире Java доступ к базам обеспечивает библиотека JDBC. Это универсальный интерфейс, который учитывает особенности каждой базы и приводит их к общему виду. JDBC нуждается в драйвере~--- библиотеке для конкретной базы данных, которая связывает высокоуровневый API с вводом-выводом. JDBC-драйверы доступны не только для классических баз PostgreSQL или MySQL, но и экзотических решений вроде файлов CSV и Excel.

Clojure предлагает легковесную обертку над JDBC~--- пакет \code{clojure.java.jdbc}. В ней доступны емкие и удобные функции для выборки, вставки и других операций с базой. Макрос \code{with-transaction} радикально упрощает работу с транзакциями. Библиотека содержит функции для типовых случаев: найти запись по \code{id}, по ключам, вставить из словаря и другие.

Чтобы связать типы Clojure с типами базы, расширьте протоколы. С их помощью сделают так, чтобы значение \code{Timestamp} из базы становилось \code{DateTime} из пакета JodaTime. Полезно обеспечить бесшовную связь с JSON, потому что этот тип несет колоссальные преимущества. Связь типов работает в обе стороны. Для установки параметров служит отдельный протокол, которые приводит типы Clojure в \code{PGObject} и другие объекты, известные JDBC.

Наибольшая опасность в SQL исходит от инъекций. Так называют прием, когда в запрос попадает вредоносный текст, например чтение системных таблиц или всегда истинное условие. Вероятность инъекции высока, если вы строите запросы конкатенацией ("склейкой") строк, а также внедряете параметры в тело запроса. Тем же опасен и текст с кавычками: их умелая расстановка может нарушить логику запроса. Чтобы обезопасить запрос от кавычек, библиотеки экранируют их на этапе установки параметров.

В боевых проектах вы столкнетесь с тем, что запросы занимают много места и затрудняют чтение кода. Кроме того, SQL неудобно строить по условию, когда заранее неизвестно, нужно ли делать отбор по некоторому полю или нет. Здесь вам помогут библиотеки. Некоторые из них выносят запросы в файл и порождают функции, которые выполняют эти запросы. Другие строят SQL из коллекций~--- комбинаций списков и словарей.

Как правило, реляционные базы возвращают данные в виде плоских таблиц. На практике нас интересуют вложенные данные, например магазин и его товары, публикации и комментарии к ним. Существует два способа сгруппировать данные. Первый~--- получить плоский ответ и обработать на стороне Clojure. Второй~--- выполнить группировку в базе функциями \code{array\_agg} или аналогами. Выбор способа зависит от окружения, объема данных и ваших навыков: в какой среде вы чувствуете себя уверенней.

Миграциями называют историю изменений базы. Как правило, это sql-файлы, которые добавляют таблицы, поля или индексы. Специальный код обходит эти файлы и применяет к базе. Отдельная таблица хранит имена обработанных миграций, чтобы не выполнить их повторно. Миграции автоматизируют рутину, позволяют оперативно откатить неудачные изменения. В локальной разработке ими переключают схему в соответствии с версией кода.

Библиотека \code{clojure.java.jdbc}~--- не единственная для работы с базой данных в Clojure. Обратите внимание на ее преемника JDBC.next. Новая библиотека работает с данными эффективней, что заметно на больших выборках. JDBC.next тесно связана с Clojure за счет встроенного протокола Datafy. Ее функции дают больше контроля за тем, что происходит с базой.
